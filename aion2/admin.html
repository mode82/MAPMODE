<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE · ADMIN99</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;

      --stroke:#1f2a3a;
      --stroke2:#27344a;

      --text:#e7eef8;
      --muted:#9fb0c6;

      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
      background: radial-gradient(1200px 700px at 12% -10%, rgba(124,196,255,.18), transparent 60%),
                  radial-gradient(900px 600px at 85% 0%, rgba(57,217,138,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      overflow:hidden;
      touch-action:none;
    }

    /* layout */
    .app{
      position:relative;
      height:100%;
      display:grid;
      grid-template-columns: 1fr;
    }

    .topbar{
      position:absolute;
      left:16px; right:16px; top:14px;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      z-index:30;
      pointer-events:none;
    }

    .brandWrap{
      display:flex; align-items:center; gap:10px;
      pointer-events:auto;
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(14,22,38,.82), rgba(11,18,32,.72));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      cursor:pointer;
      user-select:none;
    }
    .brand .dot{
      width:10px; height:10px; border-radius:99px;
      background:var(--accent);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }
    .brand .t1{font-weight:800; letter-spacing:.4px}
    .brand .t2{font-size:12px; color:var(--muted); margin-top:2px}
    .brandText{display:flex; flex-direction:column; line-height:1.05}

    .gamesTop{
      display:flex; align-items:center; gap:8px;
      pointer-events:auto;
    }

    .gSlot{
      min-width:150px;
      max-width:220px;
      height:42px;
      display:flex; align-items:center; justify-content:center;
      padding:0 12px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(14,22,38,.78), rgba(11,18,32,.68));
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      cursor:pointer;
      user-select:none;
      color:var(--text);
      font-weight:800;
      letter-spacing:.2px;
      overflow:hidden;
    }
    .gSlot.off{
      opacity:.45;
      filter:saturate(.8);
    }
    .gSlot .label{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      width:100%;
      text-align:center;
    }

    .rightBtns{
      display:flex; align-items:center; gap:8px;
      pointer-events:auto;
    }

    .btn{
      appearance:none;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(14,22,38,.86), rgba(11,18,32,.76));
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      user-select:none;
    }
    .btn:hover{border-color: var(--stroke2)}
    .btn.danger{
      border-color: rgba(255,93,93,.65);
      box-shadow: 0 0 0 2px rgba(255,93,93,.12), var(--shadow2);
    }
    .btn.ghost{
      background: rgba(14,22,38,.42);
    }

    /* canvas */
    .stage{
      position:absolute;
      inset:0;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      z-index:0;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    /* panels */
    .panelLeft, .panelRight{
      position:absolute;
      top:74px;
      bottom:18px;
      width:330px;
      padding:12px;
      z-index:20;
      pointer-events:none;
    }
    .panelLeft{left:16px}
    .panelRight{right:16px}

    .card{
      pointer-events:auto;
      border:1px solid var(--stroke);
      border-radius:18px;
      background: linear-gradient(180deg, rgba(14,22,38,.78), rgba(11,18,32,.66));
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      padding:12px;
    }
    .card + .card{margin-top:10px}
    .card h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color:var(--muted);
      font-weight:900;
      text-transform:uppercase;
    }

    .row{display:flex; align-items:center; gap:8px}
    .row + .row{margin-top:8px}

    .input{
      flex:1;
      border:1px solid var(--stroke);
      background: rgba(7,11,18,.55);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:800;
      outline:none;
    }
    .input:focus{border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 2px rgba(124,196,255,.12)}

    .small{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }

    /* lists */
    .list{
      max-height: 46vh;
      overflow:auto;
      padding-right:6px;
    }
    .list::-webkit-scrollbar{width:8px}
    .list::-webkit-scrollbar-thumb{background: rgba(39,52,74,.7); border-radius:10px}
    .list::-webkit-scrollbar-track{background: rgba(0,0,0,.15)}

    .chipRow{
      display:flex; flex-wrap:wrap; gap:8px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 10px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background: rgba(7,11,18,.45);
      cursor:pointer;
      user-select:none;
      font-weight:900;
      letter-spacing:.2px;
    }
    .chip .sw{
      width:10px;height:10px;border-radius:99px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }
    .chip.off{opacity:.42}
    .chip:hover{border-color: var(--stroke2)}
    .chip:active{transform: translateY(1px)}

    /* modals */
    .modalBackdrop{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      z-index:60;
      display:none;
      align-items:center;
      justify-content:center;
      padding:20px;
    }
    .modalBackdrop.on{display:flex}
    .modal{
      width:min(920px, 100%);
      max-height: calc(100vh - 40px);
      overflow:auto;
      border:1px solid var(--stroke);
      border-radius:20px;
      background: linear-gradient(180deg, rgba(14,22,38,.92), rgba(11,18,32,.86));
      box-shadow: var(--shadow);
      padding:14px;
    }

    .modalHeader{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      position:sticky; top:0;
      background: linear-gradient(180deg, rgba(14,22,38,.98), rgba(14,22,38,.84));
      backdrop-filter: blur(12px);
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(31,42,58,.55);
      margin-bottom:12px;
    }
    .modalHeader .title{
      font-weight:1000;
      letter-spacing:.2px;
    }
    .modalHeader .sub{
      font-size:12px; color:var(--muted); margin-top:2px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 920px){
      .panelLeft, .panelRight{width: 300px}
    }
    @media (max-width: 760px){
      .panelLeft, .panelRight{
        width:auto;
        left:10px; right:10px;
        top:auto;
        bottom:12px;
        pointer-events:none;
      }
      .panelRight{display:none}
      .panelLeft{
        bottom:12px;
      }
      .topbar{left:10px; right:10px; top:10px}
      .gSlot{min-width: 120px; max-width: 160px}
    }
  </style>
</head>

<body>
<div class="app">

  <div class="topbar">
    <div class="brandWrap">
      <div class="brand" id="brandBtn" title="게임 목록 열기">
        <div class="dot"></div>
        <div class="brandText">
          <div class="t1" id="brandTitle">MAPMODE</div>
          <div class="t2" id="brandSub">ADMIN99</div>
        </div>
      </div>

      <div class="gamesTop" title="카테고리 1~4">
        <div class="gSlot" id="gSlot1"><div class="label">카테고리 1</div></div>
        <div class="gSlot" id="gSlot2"><div class="label">카테고리 2</div></div>
        <div class="gSlot" id="gSlot3"><div class="label">카테고리 3</div></div>
        <div class="gSlot" id="gSlot4"><div class="label">카테고리 4</div></div>
      </div>
    </div>

    <div class="rightBtns">
      <button class="btn ghost" id="btnCats">카테고리</button>
      <button class="btn" id="btnPages">페이지</button>
      <button class="btn danger" id="btnOpacityReset">마커 초기화</button>
    </div>
  </div>

  <div class="stage">
    <canvas id="cv"></canvas>
  </div>

  <div class="panelLeft">
    <div class="card">
      <h3>현재 상태</h3>
      <div class="row">
        <input class="input" id="logoUrl" placeholder="로고 URL (로고 클릭 시 입력)" />
      </div>
      <div class="row">
        <div class="small" id="statusLine">로드 중...</div>
      </div>
      <div class="row">
        <button class="btn" id="btnExport">state.json 내보내기</button>
        <button class="btn danger" id="btnResetAll">전체 초기화</button>
      </div>
      <div class="row">
        <div class="small">※ Shift + 선 드래그: 연결선을 곡선으로 조절 (저장됨)</div>
      </div>
    </div>

    <div class="card">
      <h3>카테고리 필터</h3>
      <div class="chipRow" id="catChips"></div>
      <div class="row">
        <div class="small">비활성화된 카테고리는 index에서 숨김 + 해당 카테고리 마커도 전부 숨김</div>
      </div>
    </div>
  </div>

  <div class="panelRight">
    <div class="card">
      <h3>도구</h3>
      <div class="row">
        <button class="btn" id="btnSaveRemote">원격 저장</button>
        <button class="btn ghost" id="btnLoadRemote">원격 불러오기</button>
      </div>
      <div class="row">
        <button class="btn ghost" id="btnClearLocal">로컬 초기화</button>
      </div>
      <div class="row">
        <div class="small">우클릭: 마커 추가 / 드래그: 이동 / 휠: 확대·축소</div>
      </div>
    </div>
  </div>

  <!-- Games dropdown -->
  <div class="modalBackdrop" id="gameDropBackdrop">
    <div class="modal" style="width:min(680px,100%);">
      <div class="modalHeader">
        <div>
          <div class="title">게임(카테고리) 목록</div>
          <div class="sub">선택 / 추가 / 비활성화</div>
        </div>
        <div class="row" style="gap:8px;">
          <button class="btn ghost" id="btnCloseGameDrop">닫기</button>
        </div>
      </div>

      <div class="row">
        <input class="input" id="newGameName" placeholder="새 게임(카테고리) 이름" />
        <button class="btn" id="btnAddGame">추가</button>
      </div>

      <div class="list" id="gameDropList" style="margin-top:10px;"></div>
      <div class="row" style="margin-top:10px;">
        <div class="small">※ 상단 카테고리 1~4는 서로 독립이며, 각 항목은 on/off가 저장됩니다.</div>
      </div>
    </div>
  </div>

  <!-- Pages modal -->
  <div class="modalBackdrop" id="pagesBackdrop">
    <div class="modal">
      <div class="modalHeader">
        <div>
          <div class="title">페이지 관리</div>
          <div class="sub">페이지 추가 / 삭제 / URL 편집</div>
        </div>
        <div class="row" style="gap:8px;">
          <button class="btn ghost" id="btnClosePages">닫기</button>
        </div>
      </div>

      <div class="grid2">
        <div class="card">
          <h3>페이지 추가</h3>
          <div class="row">
            <input class="input" id="newPageName" placeholder="페이지 이름" />
          </div>
          <div class="row">
            <input class="input" id="newPageUrl" placeholder="지도 이미지 URL" />
          </div>
          <div class="row">
            <button class="btn" id="btnAddPage">추가</button>
          </div>
          <div class="row">
            <div class="small">페이지 URL은 assets/aion2/maps/ 등 GitHub 경로를 사용하세요.</div>
          </div>
        </div>

        <div class="card">
          <h3>페이지 목록</h3>
          <div class="list" id="pageRows"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Categories modal -->
  <div class="modalBackdrop" id="catsBackdrop">
    <div class="modal">
      <div class="modalHeader">
        <div>
          <div class="title">카테고리 편집</div>
          <div class="sub">추가 / 삭제 / 텍스트 / on/off</div>
        </div>
        <div class="row" style="gap:8px;">
          <button class="btn" id="btnAddCat">추가</button>
          <button class="btn ghost" id="btnCloseCats">닫기</button>
        </div>
      </div>

      <div class="card">
        <h3>카테고리 목록</h3>
        <div class="list" id="catRows"></div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="btnSaveCats">저장</button>
        </div>
        <div class="row">
          <div class="small">※ 카테고리 off 시: 해당 카테고리 마커가 모두 숨김(동기화)</div>
        </div>
      </div>
    </div>
  </div>

</div>

<script>
/* ===============================
   MAPMODE · ADMIN99 (single file)
   =============================== */

/* fixed constants (do not change) */
const LS_AUTH_KEY = "mapmode_admin_auth_v99";
const LS_KEY = "mapmode_state_v99";
const PASSWORD = "0000000001";
const AUTH_MS = 24*60*60*1000;
const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

/* dom */
const $ = (id)=>document.getElementById(id);
const cv = $("cv");
const ctx = cv.getContext("2d");

const brandBtn = $("brandBtn");
const brandTitle = $("brandTitle");
const brandSub = $("brandSub");

const gSlot1 = $("gSlot1");
const gSlot2 = $("gSlot2");
const gSlot3 = $("gSlot3");
const gSlot4 = $("gSlot4");

const statusLine = $("statusLine");
const logoUrl = $("logoUrl");
const catChips = $("catChips");

const btnExport = $("btnExport");
const btnResetAll = $("btnResetAll");
const btnSaveRemote = $("btnSaveRemote");
const btnLoadRemote = $("btnLoadRemote");
const btnClearLocal = $("btnClearLocal");
const btnOpacityReset = $("btnOpacityReset");

const btnPages = $("btnPages");
const pagesBackdrop = $("pagesBackdrop");
const btnClosePages = $("btnClosePages");
const newPageName = $("newPageName");
const newPageUrl = $("newPageUrl");
const btnAddPage = $("btnAddPage");
const pageRows = $("pageRows");

const btnCats = $("btnCats");
const catsBackdrop = $("catsBackdrop");
const btnCloseCats = $("btnCloseCats");
const btnAddCat = $("btnAddCat");
const btnSaveCats = $("btnSaveCats");
const catRows = $("catRows");

const gameDropBackdrop = $("gameDropBackdrop");
const gameDropList = $("gameDropList");
const btnCloseGameDrop = $("btnCloseGameDrop");
const newGameName = $("newGameName");
const btnAddGame = $("btnAddGame");

/* state */
const defaultCats = [
  {id:"all", name:"전체", color:"#7cc4ff", on:true},
  {id:"boss", name:"보스", color:"#ff5d5d", on:true},
  {id:"farm", name:"파밍", color:"#39d98a", on:true},
  {id:"etc", name:"기타", color:"#ffd60a", on:true},
];

const defaultState = {
  v: 99,
  title: "MAPMODE",
  subtitle: "ADMIN99",
  logoUrl: "",
  // games (categories 1~4 use first 4 items; list supports on/off)
  games: [
    "아이온2|1",
    "카테고리2|1",
    "카테고리3|1",
    "카테고리4|1"
  ],
  currentGame: 0,
  pages: [
    {id:"p1", name:"지도1", url:"", on:true}
  ],
  currentPage: "p1",
  categories: defaultCats.map(x=>({...x})),
  markers: [], // {x,y,r,n,t,cat,chainId,chainOrder,alphaOff?, memo?, youtube?, curve?}
  ui: { opacityOff: {} }
};

let S = mergeState(defaultState, loadFromLocal() || null);

/* ===============================
   auth (24h)
   =============================== */
function hasAuth(){
  const t = +localStorage.getItem(LS_AUTH_KEY) || 0;
  return (Date.now() - t) < AUTH_MS;
}
function ensureAuth(){
  if(hasAuth()) return true;
  const pw = prompt("ADMIN 비밀번호를 입력하세요");
  if(pw === PASSWORD){
    localStorage.setItem(LS_AUTH_KEY, String(Date.now()));
    return true;
  }
  alert("비밀번호가 틀렸습니다.");
  return false;
}

/* ===============================
   utilities
   =============================== */
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

function mergeState(base, incoming){
  const merged = deepClone(base);
  if(incoming && typeof incoming === "object"){
    // shallow merge for known keys, preserving structure
    for(const k of Object.keys(merged)){
      if(k in incoming) merged[k] = deepClone(incoming[k]);
    }
    // keep unknown keys too (forward compatible)
    for(const k of Object.keys(incoming)){
      if(!(k in merged)) merged[k] = deepClone(incoming[k]);
    }
  }

  // normalize
  if(!Array.isArray(merged.games)) merged.games = deepClone(base.games);
  if(!Array.isArray(merged.pages)) merged.pages = deepClone(base.pages);
  if(!Array.isArray(merged.categories)) merged.categories = defaultCats.map(x=>({...x}));
  if(!Array.isArray(merged.markers)) merged.markers = [];

  // fix games raw
  merged.games = merged.games.map(g=>{
    if(typeof g !== "string") return "카테고리|1";
    if(!g.includes("|")) return g + "|1";
    return g;
  });

  // ensure currentGame index
  if(typeof merged.currentGame !== "number" || merged.currentGame < 0) merged.currentGame = 0;
  if(merged.currentGame >= merged.games.length) merged.currentGame = 0;

  // ensure currentPage
  const pageIds = new Set(merged.pages.map(p=>p && p.id).filter(Boolean));
  if(!merged.currentPage || !pageIds.has(merged.currentPage)){
    merged.currentPage = merged.pages[0]?.id || "p1";
  }

  // categories must contain "all"
  if(!merged.categories.find(c=>c.id==="all")){
    merged.categories.unshift({id:"all", name:"전체", color:"#7cc4ff", on:true});
  }

    // ✅ categories: deep-clone each entry to avoid any accidental shared references
    if(Array.isArray(merged.categories)){
      merged.categories = merged.categories.map(c=>({
        id: c.id, name: c.name, color: c.color, on: (typeof c.on==="boolean"?c.on:true)
      }));
      // ensure unique ids
      const seen = new Set();
      for(const c of merged.categories){
        if(!c.id || seen.has(c.id)) c.id = ("cat_"+Math.random().toString(36).slice(2,9));
        seen.add(c.id);
      }
    }
    return merged;
}

function saveToLocal(){
  localStorage.setItem(LS_KEY, JSON.stringify(S));
  status("로컬 저장됨");
}
function loadFromLocal(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(e){ return null; }
}
function clearLocal(){
  localStorage.removeItem(LS_KEY);
  status("로컬 초기화됨");
}

async function saveToRemote(){
  // GitHub Pages는 직접 PUT이 안 되므로, "내보내기" 또는 별도 업로드 방식 사용.
  // 여기서는 상태 표시만 유지 (기존 동작 유지)
  status("원격 저장: 내보내기(state.json)로 반영하세요");
}
async function loadFromRemote(){
  try{
    const res = await fetch(REMOTE_STATE_URL.href + "?t=" + Date.now(), {cache:"no-store"});
    if(!res.ok) throw new Error("HTTP "+res.status);
    const data = await res.json();
    S = mergeState(S, data);
    saveToLocal();
    status("원격 불러오기 완료");
    renderAll();
    draw();
  }catch(e){
    console.error(e);
    alert("원격 불러오기 실패: " + (e?.message||e));
  }
}

function status(t){
  statusLine.textContent = t;
}

/* ===============================
   pages
   =============================== */
function currentPageObj(){
  return S.pages.find(p=>p.id===S.currentPage) || S.pages[0];
}
function renderPages(){
  pageRows.innerHTML = "";
  for(const p of S.pages){
    const row = document.createElement("div");
    row.className = "row";
    row.style.marginBottom = "8px";

    const name = document.createElement("input");
    name.className = "input";
    name.value = p.name || "";
    name.placeholder = "페이지 이름";
    name.addEventListener("input", ()=>{
      p.name = name.value;
      saveToLocal();
      renderAll();
    });

    const url = document.createElement("input");
    url.className = "input";
    url.value = p.url || "";
    url.placeholder = "지도 URL";
    url.addEventListener("input", ()=>{
      p.url = url.value;
      saveToLocal();
    });

    const onBtn = document.createElement("button");
    onBtn.className = "btn ghost";
    onBtn.textContent = p.on===false ? "OFF" : "ON";
    onBtn.addEventListener("click", ()=>{
      p.on = (p.on===false) ? true : false;
      onBtn.textContent = p.on===false ? "OFF" : "ON";
      saveToLocal();
      renderAll();
      draw();
    });

    const selBtn = document.createElement("button");
    selBtn.className = "btn";
    selBtn.textContent = (p.id===S.currentPage) ? "선택됨" : "선택";
    selBtn.addEventListener("click", ()=>{
      S.currentPage = p.id;
      saveToLocal();
      renderPages();
      draw();
    });

    const delBtn = document.createElement("button");
    delBtn.className = "btn danger";
    delBtn.textContent = "삭제";
    delBtn.addEventListener("click", ()=>{
      if(S.pages.length<=1){ alert("페이지는 최소 1개 필요"); return; }
      if(!confirm("삭제할까요?")) return;
      S.pages = S.pages.filter(x=>x!==p);
      if(!S.pages.find(x=>x.id===S.currentPage)) S.currentPage = S.pages[0].id;
      saveToLocal();
      renderAll();
      draw();
    });

    row.appendChild(name);
    row.appendChild(url);
    row.appendChild(onBtn);
    row.appendChild(selBtn);
    row.appendChild(delBtn);

    pageRows.appendChild(row);
  }
}

/* ===============================
   categories
   =============================== */
function getCat(id){
  return S.categories.find(c=>c.id===id) || S.categories[0];
}
function renderCats(){
  // chips
  catChips.innerHTML = "";
  for(const c of S.categories){
    const chip = document.createElement("div");
    chip.className = "chip" + (c.on===false ? " off" : "");
    chip.title = c.id==="all" ? "전체 토글" : "카테고리 토글";
    const sw = document.createElement("div");
    sw.className = "sw";
    sw.style.background = c.color || "#7cc4ff";
    chip.appendChild(sw);

    const t = document.createElement("div");
    t.textContent = c.name || "";
    chip.appendChild(t);

    chip.addEventListener("click", ()=>{
      if(c.id==="all"){
        const turnOn = (c.on===false);
        c.on = turnOn;
        for(const cc of S.categories){
          if(cc.id==="all") continue;
          cc.on = turnOn;
        }
      }else{
        c.on = (c.on===false) ? true : false;
        // keep master in sync: if any off => all off
        const anyOff = S.categories.some(x=>x.id!=="all" && x.on===false);
        const allOn = S.categories.every(x=>x.id==="all" || x.on!==false);
        const master = S.categories.find(x=>x.id==="all");
        if(master){
          master.on = allOn;
          if(anyOff) master.on = false;
        }
      }
      saveToLocal();
      renderCats();
      draw();
    });

    catChips.appendChild(chip);
  }
}

function renderCatRows(){
  catRows.innerHTML = "";
  for(const c of S.categories){
    const row = document.createElement("div");
    row.className = "row";
    row.style.marginBottom = "8px";

    const name = document.createElement("input");
    name.className = "input";
    name.value = c.name || "";
    name.placeholder = "카테고리 이름";
    name.disabled = (c.id==="all");
    name.addEventListener("input", ()=>{
      c.name = name.value;
      saveToLocal();
      renderCats();
    });

    const color = document.createElement("input");
    color.className = "input";
    color.value = c.color || "#7cc4ff";
    color.placeholder = "#RRGGBB";
    color.disabled = (c.id==="all");
    color.addEventListener("input", ()=>{
      c.color = color.value;
      saveToLocal();
      renderCats();
    });

    const onBtn = document.createElement("button");
    onBtn.className = "btn ghost";
    onBtn.textContent = (c.on===false) ? "OFF" : "ON";
    onBtn.addEventListener("click", ()=>{
      if(c.id==="all"){
        const turnOn = (c.on===false);
        c.on = turnOn;
        for(const cc of S.categories){
          if(cc.id==="all") continue;
          cc.on = turnOn;
        }
      }else{
        c.on = (c.on===false) ? true : false;
        const anyOff = S.categories.some(x=>x.id!=="all" && x.on===false);
        const allOn = S.categories.every(x=>x.id==="all" || x.on!==false);
        const master = S.categories.find(x=>x.id==="all");
        if(master){
          master.on = allOn;
          if(anyOff) master.on = false;
        }
      }
      onBtn.textContent = (c.on===false) ? "OFF" : "ON";
      saveToLocal();
      renderCats();
      draw();
    });

    const delBtn = document.createElement("button");
    delBtn.className = "btn danger";
    delBtn.textContent = "삭제";
    delBtn.disabled = (c.id==="all");
    delBtn.addEventListener("click", ()=>{
      if(c.id==="all") return;
      if(!confirm("삭제할까요? (해당 카테고리 마커는 '전체'로 이동)")) return;
      // move markers to fallback
      const fallback = S.categories.find(x=>x.id==="all") || S.categories[0];
      for(const m of S.markers){
        if(m.cat === c.id) m.cat = fallback.id;
      }
      S.categories = S.categories.filter(x=>x!==c);
      saveToLocal();
      renderAll();
      draw();
    });

    row.appendChild(name);
    row.appendChild(color);
    row.appendChild(onBtn);
    row.appendChild(delBtn);
    catRows.appendChild(row);
  }
}

btnAddCat.addEventListener("click", ()=>{
  const id = "cat_" + Math.random().toString(36).slice(2,9);
  S.categories.push({id, name:"새 카테고리", color:"#7cc4ff", on:true});
  saveToLocal();
  renderAll();
});

btnSaveCats.addEventListener("click", ()=>{
  // just ensure local persistence
  saveToLocal();
  renderAll();
  draw();
  status("카테고리 저장됨");
});

/* visible markers (respect category on/off + page on/off) */
function getVisibleMarkers(){
  const p = currentPageObj();
  if(!p || p.on===false) return [];
  return S.markers.filter(m=>{
    if(m.pageId && m.pageId !== p.id) return false;
    const c = getCat(m.cat);
    if(c && c.on===false && c.id!=="all") return false;
    // master all off hides everything
    const master = S.categories.find(x=>x.id==="all");
    if(master && master.on===false) return false;
    return true;
  });
}

/* ===============================
   games dropdown (top slots 1-4)
   =============================== */
function parseGameRaw(raw){
  const [name,on] = String(raw||"").split("|");
  return { name: (name||"").trim(), on: (on!=="0") };
}
function makeGameRaw(name, on){
  return `${(name||"").trim()}|${on?1:0}`;
}
function setGameRawAtIndex(i, raw){
  if(!S.games[i]) S.games[i] = makeGameRaw("카테고리", true);
  S.games[i] = raw;
  saveToLocal();
  renderGamesTop();
  renderGameDropList();
}
function setGameOnAtIndex(i, on){
  const g = parseGameRaw(S.games[i]||"");
  setGameRawAtIndex(i, makeGameRaw(g.name||`카테고리${i+1}`, on));
}

function fitSlot1Text(){
  // ✅ FIX: 카테고리1(아이온2) 폰트 자동 맞춤
  const el = gSlot1.querySelector(".label");
  if(!el) return;
  el.style.fontSize = "14px";
  const maxW = gSlot1.clientWidth - 20;
  const len = el.scrollWidth;
  if(len > maxW){
    const scale = Math.max(.72, maxW/len);
    el.style.fontSize = (14*scale).toFixed(1) + "px";
  }
}

function renderGamesTop(){
  const slots = [gSlot1,gSlot2,gSlot3,gSlot4];
  for(let i=0;i<4;i++){
    const raw = (S.games && S.games[i]) ? S.games[i] : "";
    const {name,on} = parseGameRaw(raw);
    const label = slots[i].querySelector(".label");
    label.textContent = name || `카테고리 ${i+1}`;
    slots[i].classList.toggle("off", !on);
  }
  fitSlot1Text();
}

function openGameList(){
  gameDropBackdrop.classList.add("on");
  renderGameDropList();
  newGameName.value = "";
  newGameName.focus();
}
function closeGameList(){ gameDropBackdrop.classList.remove("on"); }

function renderGameDropList(){
  gameDropList.innerHTML = "";
  S.games.forEach((raw, idx)=>{
    const g = parseGameRaw(raw);
    const row = document.createElement("div");
    row.className = "row";
    row.style.marginBottom = "8px";

    const name = document.createElement("input");
    name.className = "input";
    name.value = g.name;
    name.placeholder = "이름";
    name.addEventListener("input", ()=>{
      // ✅ FIX: 해당 idx만 수정 (참조/상태 공유 금지)
      const curr = parseGameRaw(S.games[idx]||"");
      setGameRawAtIndex(idx, makeGameRaw(name.value, curr.on));
    });

    const onBtn = document.createElement("button");
    onBtn.className = "btn ghost";
    onBtn.textContent = g.on ? "ON" : "OFF";
    onBtn.addEventListener("click", ()=>{
      setGameOnAtIndex(idx, !g.on);
    });

    const useBtn = document.createElement("button");
    useBtn.className = "btn";
    useBtn.textContent = (idx===S.currentGame) ? "선택됨" : "선택";
    useBtn.addEventListener("click", ()=>{
      S.currentGame = idx;
      saveToLocal();
      renderGameDropList();
      renderGamesTop();
      draw();
    });

    const delBtn = document.createElement("button");
    delBtn.className = "btn danger";
    delBtn.textContent = "삭제";
    delBtn.addEventListener("click", ()=>{
      if(S.games.length<=4){
        alert("기본 4개 카테고리는 유지하는 것을 권장합니다.");
      }
      if(!confirm("삭제할까요?")) return;
      S.games.splice(idx,1);
      if(S.currentGame >= S.games.length) S.currentGame = 0;
      saveToLocal();
      renderGameDropList();
      renderGamesTop();
      draw();
    });

    row.appendChild(name);
    row.appendChild(onBtn);
    row.appendChild(useBtn);
    row.appendChild(delBtn);

    gameDropList.appendChild(row);
  });
}

// top slot click: open game list
function onTopSlotClickFactory(i){
  return ()=>{
    if(!ensureAuth()) return;
    openGameList();
    // focus the corresponding row
    setTimeout(()=>{
      const rows = gameDropList.querySelectorAll(".row");
      const row = rows[i];
      const inp = row?.querySelector("input");
      inp?.focus();
      inp?.select();
    }, 30);
  };
}
gSlot1.addEventListener("click", onTopSlotClickFactory(0));
gSlot2.addEventListener("click", onTopSlotClickFactory(1));
gSlot3.addEventListener("click", onTopSlotClickFactory(2));
gSlot4.addEventListener("click", onTopSlotClickFactory(3));

brandBtn.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  openGameList();
});

btnCloseGameDrop.addEventListener("click", closeGameList);
gameDropBackdrop.addEventListener("click", (e)=>{
  if(e.target===gameDropBackdrop) closeGameList();
});

btnAddGame.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  const name = (newGameName.value||"").trim();
  if(!name){ alert("이름을 입력하세요"); return; }
  // allow duplicate names, but they remain independent by index (no shared state)
  S.games.push(makeGameRaw(name, true));
  saveToLocal();
  renderGameDropList();
  renderGamesTop();
  newGameName.value = "";
  newGameName.focus();
});

/* ===============================
   map image handling
   =============================== */
let img = new Image();
img.crossOrigin = "anonymous";

function loadPageImage(){
  const p = currentPageObj();
  if(!p || !p.url){
    img = new Image();
    draw();
    return;
  }
  const url = p.url;
  img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = ()=>{ draw(); };
  img.onerror = ()=>{ draw(); };
  img.src = url;
}

/* ===============================
   camera / transforms
   =============================== */
function resize(){
  const dpr = Math.max(1, window.devicePixelRatio||1);
  const rect = cv.getBoundingClientRect();
  cv.width = Math.floor(rect.width * dpr);
  cv.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}
window.addEventListener("resize", resize);

function getImageSize(){
  const w = img?.naturalWidth || 1;
  const h = img?.naturalHeight || 1;
  return {w,h};
}

// map transform state
S.map = S.map || { scale:1, tx:0, ty:0 };

function screenToWorld(sx,sy){
  return {
    x: (sx - S.map.tx) / S.map.scale,
    y: (sy - S.map.ty) / S.map.scale
  };
}
function worldToNorm(wx,wy){
  const {w:imgW, h:imgH} = getImageSize();
  return { x: wx / imgW, y: wy / imgH };
}
function worldFromNorm(nx,ny){
  const {w:imgW, h:imgH} = getImageSize();
  return { x: nx * imgW, y: ny * imgH };
}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* ===============================
   draw helpers
   =============================== */
function drawArrowheadWorld(x1,y1,x2,y2, sizeWorld){
    // Chevron style (">") arrowhead in world space
    const dx = x2-x1, dy = y2-y1;
    const len = Math.hypot(dx,dy);
    if(len < 1e-6) return;

    const ux = dx/len, uy = dy/len;
    const px = -uy, py = ux;

    const tipX = x2, tipY = y2;
    const backX = x2 - ux*sizeWorld;
    const backY = y2 - uy*sizeWorld;

    const wing = sizeWorld*0.60;

    const leftX  = backX + px*wing, leftY  = backY + py*wing;
    const rightX = backX - px*wing, rightY = backY - py*wing;

    ctx.beginPath();
    ctx.moveTo(leftX, leftY);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(rightX, rightY);
    ctx.stroke();
  }

/* ===============================
   draw
   =============================== */
function getMarkerAlpha(m){
  const key = m.id || m.n || "";
  return S.ui?.opacityOff?.[key] ? 0.3 : 1.0;
}

function draw(){
  const rect = cv.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  ctx.clearRect(0,0,W,H);

  // background image
  const {w:imgW, h:imgH} = getImageSize();
  if(img && img.naturalWidth){
    ctx.save();
    ctx.translate(S.map.tx, S.map.ty);
    ctx.scale(S.map.scale, S.map.scale);
    ctx.drawImage(img, 0,0, imgW, imgH);
    ctx.restore();
  }else{
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.04)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // visible markers
  const visible = getVisibleMarkers();

  // draw chains (connecting markers by chainId and chainOrder)
  // build chains map
  const chains = new Map();
  for(const m of visible){
    if(!m.chainId) continue;
    if(!chains.has(m.chainId)) chains.set(m.chainId, []);
    chains.get(m.chainId).push(m);
  }

  // draw chain lines
  ctx.save();
  ctx.translate(S.map.tx, S.map.ty);
  ctx.scale(S.map.scale, S.map.scale);

  const zoom = S.map.scale;
  const lineW = clamp(3/zoom, 1.1, 3.2);

  for(const [cid, ms] of chains){
    ms.sort((a,b)=> (a.chainOrder??0) - (b.chainOrder??0));

ctx.save();
        ctx.globalAlpha = 0.92;

        ctx.lineWidth = lineW; // ✅ FIX
        ctx.strokeStyle = "rgba(255,255,255,.78)";
        ctx.fillStyle = "rgba(255,255,255,.78)";

        // Chain segments (support optional quadratic curves per segment)
        for(let i=0;i<ms.length-1;i++){
          const a = ms[i], b = ms[i+1];
          if(a.chainId !== b.chainId) continue;

          const A0 = worldFromNorm(a.x, a.y);
          const B0 = worldFromNorm(b.x, b.y);

          // unit direction in world space
          const dx = B0.x - A0.x, dy = B0.y - A0.y;
          const dlen = Math.hypot(dx, dy);
          if(dlen < 1e-6) continue;
          const ux = dx / dlen, uy = dy / dlen;

          const halfStroke = Math.max(2, lineW) * 0.5;
          const ar = (a.r||0);
          const br = (b.r||0);

          const startX = A0.x + ux*(ar + halfStroke);
          const startY = A0.y + uy*(ar + halfStroke);
          const endX   = B0.x - ux*(br + halfStroke);
          const endY   = B0.y - uy*(br + halfStroke);

          if(Math.hypot(endX-startX, endY-startY) < 10) continue;

          // optional curve stored on the *start marker* (normalized offset)
          const curveN = (typeof a.curve === "number") ? a.curve : 0;
          const hasCurve = Math.abs(curveN) > 1e-6;

          ctx.beginPath();
          ctx.moveTo(startX, startY);

          if(hasCurve){
            // control point in norm space: midpoint + perpendicular * curveN
            const midNx = (a.x + b.x) * 0.5;
            const midNy = (a.y + b.y) * 0.5;

            const ndx = (b.x - a.x), ndy = (b.y - a.y);
            const nlen = Math.hypot(ndx, ndy) || 1;
            const nux = ndx / nlen, nuy = ndy / nlen;
            const npx = -nuy, npy = nux;

            const ctrlN = { x: midNx + npx*curveN, y: midNy + npy*curveN };
            const C0 = worldFromNorm(ctrlN.x, ctrlN.y);

            ctx.quadraticCurveTo(C0.x, C0.y, endX, endY);
            ctx.stroke();

            // arrow head follows curve tangent near end (control -> end)
            const arrowSize = 0.02 * Math.min(imgW, imgH) * zoom;
            drawArrowheadWorld(C0.x, C0.y, endX, endY, arrowSize);
          }else{
            ctx.lineTo(endX, endY);
            ctx.stroke();

            const arrowSize = 0.02 * Math.min(imgW, imgH) * zoom;
            drawArrowheadWorld(startX, startY, endX, endY, arrowSize); // ✅ FIX
          }
        }

        ctx.restore();
  }

  // draw markers
  for(const m of visible){
    const p = worldFromNorm(m.x, m.y);
    const alpha = getMarkerAlpha(m);

    ctx.save();
    ctx.globalAlpha = alpha;

    // marker circle
    const r = (m.r || 18);
    ctx.lineWidth = clamp(3/zoom, 1.2, 3.2);
    const c = getCat(m.cat);
    ctx.strokeStyle = c?.color || "#7cc4ff";
    ctx.fillStyle = "rgba(0,0,0,.0)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.stroke();

    // marker number
    ctx.fillStyle = "#ffffff";
    ctx.font = `${clamp(18/zoom, 10, 18)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(m.n||""), p.x, p.y);

    // marker text
    const t = (m.t||"").trim();
    if(t){
      ctx.font = `${clamp(14/zoom, 10, 14)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif`;
      ctx.fillStyle = "rgba(231,238,248,.92)";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(t, p.x + r + 10, p.y);
    }

    ctx.restore();
  }

  ctx.restore();
}

/* ===============================
   interactions (pan/zoom + marker drag)
   =============================== */
let isPanning = false;
let panStart = {x:0,y:0, tx:0, ty:0};

let draggingMarker = null;
let draggingMarkerId = null;
  // ---------- curve editing (chain lines) ----------
  let curveDrag = null; // { a: markerObj, b: markerObj, pointerId }
  function worldToScreenPt(p){ return { x: p.x * S.map.scale + S.map.tx, y: p.y * S.map.scale + S.map.ty }; }

  function distPointToSeg(px,py, ax,ay, bx,by){
    const abx=bx-ax, aby=by-ay;
    const apx=px-ax, apy=py-ay;
    const ab2=abx*abx+aby*aby;
    const t = ab2 ? Math.max(0, Math.min(1, (apx*abx+apy*aby)/ab2)) : 0;
    const cx = ax + abx*t, cy = ay + aby*t;
    const dx = px - cx, dy = py - cy;
    return Math.hypot(dx,dy);
  }

  function pickNearestChainSegmentAtScreen(sx, sy){
    const visible = getVisibleMarkers();
    // build in-chain ordered list (as draw() does)
    const byChain = new Map();
    for(const m of visible){
      if(!m.chainId) continue;
      if(!byChain.has(m.chainId)) byChain.set(m.chainId, []);
      byChain.get(m.chainId).push(m);
    }
    let best = null, bestD = 1e9;

    for(const [cid, ms] of byChain){
      ms.sort((a,b)=> (a.chainOrder??0) - (b.chainOrder??0));
      for(let i=0;i<ms.length-1;i++){
        const a = ms[i], b = ms[i+1];
        if(a.chainId !== b.chainId) continue;

        const A0 = worldFromNorm(a.x, a.y);
        const B0 = worldFromNorm(b.x, b.y);
        const As = worldToScreenPt(A0);
        const Bs = worldToScreenPt(B0);

        const d = distPointToSeg(sx, sy, As.x, As.y, Bs.x, Bs.y);
        if(d < bestD){
          bestD = d;
          best = { a, b, chainId: cid };
        }
      }
    }
    if(best && bestD <= 14) return best; // hit threshold (px)
    return null;
  }

  function setCurveFromPointer(seg, sx, sy){
    const a = seg.a, b = seg.b;
    // convert pointer to norm, compute signed perpendicular offset from midpoint
    const pWorld = screenToWorld(sx, sy);
    const pNorm = worldToNorm(pWorld.x, pWorld.y);

    const midNx = (a.x + b.x) * 0.5;
    const midNy = (a.y + b.y) * 0.5;

    const ndx = (b.x - a.x), ndy = (b.y - a.y);
    const nlen = Math.hypot(ndx, ndy) || 1;
    const nux = ndx / nlen, nuy = ndy / nlen;
    const npx = -nuy, npy = nux;

    const vx = pNorm.x - midNx, vy = pNorm.y - midNy;
    let curveN = vx*npx + vy*npy;

    // clamp to keep things sane
    curveN = Math.max(-0.5, Math.min(0.5, curveN));
    a.curve = curveN;
  }


function pickMarkerAtScreen(sx,sy){
  const visible = getVisibleMarkers();
  // reverse so top-most last drawn is picked first
  for(let i=visible.length-1;i>=0;i--){
    const m = visible[i];
    const p = worldFromNorm(m.x, m.y);
    const spx = p.x * S.map.scale + S.map.tx;
    const spy = p.y * S.map.scale + S.map.ty;
    const r = (m.r||18) * S.map.scale;
    const d = Math.hypot(sx-spx, sy-spy);
    if(d <= r+8) return m;
  }
  return null;
}

cv.addEventListener("pointerdown", (e)=>{
  if(!ensureAuth()) return;
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  const hitM = pickMarkerAtScreen(sx, sy);
  if(hitM){
    draggingMarker = hitM;
    draggingMarkerId = e.pointerId;
    cv.setPointerCapture(e.pointerId);
    isPanning = false;
    return;
  }

  // otherwise pan
  draggingMarker = null;
    draggingMarkerId = null;

    // Shift + drag on a chain line to adjust curvature (minimal UI)
    if(e.shiftKey){
      const seg = pickNearestChainSegmentAtScreen(sx, sy);
      if(seg){
        curveDrag = { ...seg, pointerId: e.pointerId };
        setCurveFromPointer(seg, sx, sy);
        saveToLocal();
        saveToRemote();
        isPanning = false;
        draw();
        return;
      }
    }

    isPanning = true;
  panStart = {x:sx, y:sy, tx:S.map.tx, ty:S.map.ty};
});

cv.addEventListener("pointermove", (e)=>{
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
    if(curveDrag && curveDrag.pointerId === e.pointerId){
      setCurveFromPointer(curveDrag, sx, sy);
      saveToLocal();
      draw();
      return;
    }

  if(draggingMarker && draggingMarkerId === e.pointerId){
    const w = screenToWorld(sx, sy);
    const n = worldToNorm(w.x, w.y);
    draggingMarker.x = clamp(n.x, 0, 1);
    draggingMarker.y = clamp(n.y, 0, 1);
    saveToLocal();
    draw();
    return;
  }

  if(isPanning){
    const dx = sx - panStart.x;
    const dy = sy - panStart.y;
    S.map.tx = panStart.tx + dx;
    S.map.ty = panStart.ty + dy;
    draw();
  }
});

cv.addEventListener("pointerup", (e)=>{
    if(curveDrag){
      saveToLocal();
      saveToRemote();
      curveDrag = null;
      draw();
      return;
    }
  if(draggingMarkerId === e.pointerId){
    draggingMarker = null;
    draggingMarkerId = null;
    saveToLocal();
    saveToRemote();
  }
  isPanning = false;
});
cv.addEventListener("pointercancel", ()=>{
  draggingMarker = null;
  draggingMarkerId = null;
  isPanning = false;
});

cv.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  const before = screenToWorld(sx, sy);
  const zoomFactor = Math.exp(-e.deltaY * 0.001);
  const newScale = clamp(S.map.scale * zoomFactor, 0.2, 8);

  S.map.scale = newScale;
  const after = screenToWorld(sx, sy);

  // keep pointer stable
  S.map.tx += (after.x - before.x) * S.map.scale;
  S.map.ty += (after.y - before.y) * S.map.scale;

  draw();
}, {passive:false});

/* right click: add marker */
cv.addEventListener("contextmenu", (e)=>{
  e.preventDefault();
  if(!ensureAuth()) return;
  const rect = cv.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const w = screenToWorld(sx, sy);
  const n = worldToNorm(w.x, w.y);

  const nextN = (S.markers.reduce((mx,m)=>Math.max(mx, +m.n||0), 0) + 1);

  const master = S.categories.find(x=>x.id==="all");
  const firstEnabled = S.categories.find(x=>x.id!=="all" && x.on!==false) || S.categories[0];

  const m = {
    id: "m_" + Math.random().toString(36).slice(2,9),
    pageId: S.currentPage,
    x: clamp(n.x, 0, 1),
    y: clamp(n.y, 0, 1),
    r: 18,
    n: nextN,
    t: "",
    cat: (master && master.on===false) ? "all" : (firstEnabled?.id || "all"),
    chainId: null,
    chainOrder: 0,
    memo: "",
    youtube: "",
    curve: 0
  };

  S.markers.push(m);
  saveToLocal();
  draw();
});

/* ===============================
   buttons / modals
   =============================== */
btnPages.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  pagesBackdrop.classList.add("on");
  renderPages();
});
btnClosePages.addEventListener("click", ()=>pagesBackdrop.classList.remove("on"));
pagesBackdrop.addEventListener("click", (e)=>{ if(e.target===pagesBackdrop) pagesBackdrop.classList.remove("on"); });

btnAddPage.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  const name = (newPageName.value||"").trim();
  const url = (newPageUrl.value||"").trim();
  if(!name){ alert("페이지 이름 입력"); return; }
  const id = "p_" + Math.random().toString(36).slice(2,9);
  S.pages.push({id, name, url, on:true});
  if(!S.currentPage) S.currentPage = id;
  newPageName.value = "";
  newPageUrl.value = "";
  saveToLocal();
  renderPages();
  loadPageImage();
  draw();
});

btnCats.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  catsBackdrop.classList.add("on");
  renderCatRows();
});
btnCloseCats.addEventListener("click", ()=>catsBackdrop.classList.remove("on"));
catsBackdrop.addEventListener("click", (e)=>{ if(e.target===catsBackdrop) catsBackdrop.classList.remove("on"); });

btnOpacityReset.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  S.ui = S.ui || {};
  S.ui.opacityOff = {};
  saveToLocal();
  draw();
});

btnSaveRemote.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  saveToRemote();
});
btnLoadRemote.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  loadFromRemote();
});

btnClearLocal.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  if(!confirm("로컬 상태를 초기화할까요?")) return;
  clearLocal();
  S = mergeState(defaultState, null);
  saveToLocal();
  renderAll();
  loadPageImage();
  draw();
});

btnExport.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  const blob = new Blob([JSON.stringify(S,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "state.json";
  a.click();
  URL.revokeObjectURL(a.href);
});

btnResetAll.addEventListener("click", ()=>{
  if(!ensureAuth()) return;
  if(!confirm("전체 초기화할까요?")) return;
  S = mergeState(defaultState, null);
  saveToLocal();
  renderAll();
  loadPageImage();
  draw();
});

/* logo URL: click-to-edit behavior */
logoUrl.addEventListener("focus", ()=>{
  // keep UX simple; already editable
});
/* ===============================
   init
   =============================== */
function renderAll(){
  brandTitle.textContent = S.title || "MAPMODE";
  brandSub.textContent = S.subtitle || "ADMIN99";
  logoUrl.value = S.logoUrl || "";

  renderGamesTop();
  renderCats();
  renderPages();
}

logoUrl.addEventListener("change", ()=>{
  S.logoUrl = logoUrl.value;
  saveToLocal();
});

renderAll();
resize();
loadPageImage();
draw();

</script>
</body>
</html>
