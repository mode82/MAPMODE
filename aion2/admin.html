<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE · ADMIN</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;

      --stroke:#1f2a3a;
      --stroke2:#27344a;

      --text:#e7eef8;
      --muted:#9fb0c6;

      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r10:10px;
      --r12:12px;
      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      --topH: 56px;
      --sideW: 320px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "Malgun Gothic", Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 900px at 25% 10%, #0e1b33 0%, rgba(14,27,51,0) 55%),
                  radial-gradient(900px 700px at 85% 20%, #112244 0%, rgba(17,34,68,0) 52%),
                  var(--bg);
      color: var(--text);
      overflow:hidden;
    }

    a{ color:inherit; text-decoration:none; }
    button, input, select, textarea{ font:inherit; color:inherit; }

    .app{
      height:100%;
      display:grid;
      grid-template-rows: var(--topH) 1fr;
      grid-template-columns: 1fr;
    }

    /* Top bar */
    .top{
      position:sticky;
      top:0;
      z-index:50;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(7,11,18,.92) 0%, rgba(7,11,18,.55) 100%);
      border-bottom:1px solid rgba(39,52,74,.7);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    .logoBtn{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.55);
      box-shadow: var(--shadow2);
      cursor:pointer;
      user-select:none;
    }
    .logoBtn:hover{ border-color: rgba(124,196,255,.55); }
    .logoImg{
      height:20px;
      width:auto;
      display:block;
      filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
    }
    .logoFallback{
      font-family: var(--mono);
      letter-spacing:.5px;
      font-weight:700;
      font-size:12px;
      opacity:.95;
    }

    .topCats{
      display:flex;
      align-items:center;
      gap:8px;
      flex:1;
      min-width:0;
      overflow:auto hidden;
      padding-bottom:2px;
      scrollbar-width: none;
    }
    .topCats::-webkit-scrollbar{ height:0; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.45);
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
      box-shadow: 0 8px 24px rgba(0,0,0,.20);
    }
    .pill:hover{ border-color: rgba(124,196,255,.55); }
    .pill.active{
      border-color: rgba(124,196,255,.75);
      background: rgba(124,196,255,.14);
    }
    .pill .dot{
      width:8px; height:8px; border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }

    .topRight{
      display:flex;
      align-items:center;
      gap:8px;
      flex:0 0 auto;
    }

    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.45);
      box-shadow: 0 8px 24px rgba(0,0,0,.20);
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{ border-color: rgba(124,196,255,.55); }
    .btn.danger{
      border-color: rgba(255,93,93,.55);
      background: rgba(255,93,93,.12);
    }
    .btn.ok{
      border-color: rgba(57,217,138,.55);
      background: rgba(57,217,138,.10);
    }
    .btn.ghost{
      background: rgba(14,22,38,.22);
    }
    .btn:disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    /* Main layout */
    .main{
      height:100%;
      display:grid;
      grid-template-columns: var(--sideW) 1fr var(--sideW);
      gap:10px;
      padding:10px;
      overflow:hidden;
    }

    .panel{
      height:100%;
      border-radius: 18px;
      border:1px solid rgba(39,52,74,.7);
      background: rgba(11,18,32,.55);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-width:0;
    }
    .panelHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(39,52,74,.55);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: linear-gradient(180deg, rgba(14,22,38,.55) 0%, rgba(14,22,38,.15) 100%);
    }
    .panelHeader .title{
      font-weight:800;
      letter-spacing:.2px;
      font-size:13px;
      opacity:.96;
    }
    .panelHeader .sub{
      font-size:12px;
      color: var(--muted);
      opacity:.95;
    }
    .panelBody{
      padding:12px;
      overflow:auto;
      min-height:0;
    }

    .card{
      border:1px solid rgba(39,52,74,.65);
      background: rgba(14,22,38,.40);
      border-radius:16px;
      box-shadow: 0 8px 24px rgba(0,0,0,.18);
      padding:12px;
    }
    .card + .card{ margin-top:10px; }

    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grow{ flex:1; min-width:0; }
    .muted{ color: var(--muted); }
    .tiny{ font-size:11px; }
    .small{ font-size:12px; }
    .hr{ height:1px; background: rgba(39,52,74,.55); margin:10px 0; }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .label{
      font-size:12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .input, .select, .textarea{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(7,11,18,.35);
      color: var(--text);
      padding:10px 10px;
      outline:none;
    }
    .input:focus, .select:focus, .textarea:focus{
      border-color: rgba(124,196,255,.65);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }
    .textarea{ min-height:70px; resize: vertical; }

    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .item{
      border:1px solid rgba(39,52,74,.65);
      background: rgba(7,11,18,.22);
      border-radius:16px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .itemTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.30);
      font-size:11px;
      color: var(--muted);
      white-space:nowrap;
    }
    .badge .miniDot{
      width:7px; height:7px; border-radius:50%;
      background: rgba(124,196,255,.85);
      box-shadow: 0 0 0 3px rgba(124,196,255,.10);
    }

    .pageBtn{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(14,22,38,.22);
      cursor:pointer;
      user-select:none;
      box-shadow: 0 8px 24px rgba(0,0,0,.16);
    }
    .pageBtn:hover{ border-color: rgba(124,196,255,.55); }
    .pageBtn.active{
      border-color: rgba(124,196,255,.75);
      background: rgba(124,196,255,.12);
    }
    .pageBtn .name{
      font-weight:800;
      font-size:13px;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pageBtn .meta{
      font-size:11px;
      color: var(--muted);
      flex:0 0 auto;
      white-space:nowrap;
    }

    /* Canvas */
    .canvasWrap{
      height:100%;
      min-width:0;
      border-radius: 18px;
      border:1px solid rgba(39,52,74,.7);
      background: rgba(11,18,32,.35);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:hidden;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: none; /* we handle pan/zoom */
      cursor: grab;
    }
    canvas.dragging{ cursor: grabbing; }

    .hud{
      position:absolute;
      left:12px;
      bottom:12px;
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(14,22,38,.48);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      user-select:none;
      font-size:12px;
      color: var(--muted);
    }
    .hud b{ color: var(--text); }

    /* Inline flyouts (no center popups) */
    .flyout{
      position:absolute;
      z-index:60;
      width:min(520px, calc(100vw - 24px));
      border-radius: 18px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(11,18,32,.92);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:hidden;
      transform-origin: top left;
    }
    .flyoutHeader{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(39,52,74,.55);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background: rgba(14,22,38,.45);
    }
    .flyoutHeader .t{ font-weight:900; font-size:13px; }
    .flyoutBody{ padding:12px; }
    .xbtn{
      width:34px; height:34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(7,11,18,.35);
      cursor:pointer;
    }
    .xbtn:hover{ border-color: rgba(124,196,255,.55); }

    .palette{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .swatch{
      width:30px; height:30px;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.75);
      cursor:pointer;
      box-shadow: 0 8px 24px rgba(0,0,0,.18);
    }
    .swatch:hover{ border-color: rgba(124,196,255,.55); }

    .toggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(14,22,38,.22);
      user-select:none;
    }
    .toggle .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .toggle .left .dot{
      width:10px; height:10px; border-radius:50%;
      background: rgba(124,196,255,.85);
      box-shadow: 0 0 0 3px rgba(124,196,255,.10);
    }
    .toggle .left .name{
      font-weight:800;
      font-size:13px;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .toggle .right{
      display:flex;
      align-items:center;
      gap:6px;
      flex:0 0 auto;
    }
    .chipBtn{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(7,11,18,.28);
      cursor:pointer;
      font-size:12px;
      white-space:nowrap;
    }
    .chipBtn:hover{ border-color: rgba(124,196,255,.55); }
    .chipBtn.danger{ border-color: rgba(255,93,93,.55); }
    .chipBtn.danger:hover{ border-color: rgba(255,93,93,.75); }

    .footerPad{ height:28px; }

    /* responsive but same layout */
    @media (max-width: 1100px){
      :root{ --sideW: 300px; }
    }
    @media (max-width: 980px){
      :root{ --sideW: 280px; --topH: 60px; }
      .top{ padding:10px; }
      .btn{ padding:8px 9px; }
      .logoBtn{ padding:8px 9px; }
    }
    @media (max-width: 860px){
      :root{ --sideW: 260px; }
    }

    /* small helpers */
    .k{
      font-family: var(--mono);
      font-size:11px;
      color: rgba(231,238,248,.92);
      background: rgba(7,11,18,.35);
      border:1px solid rgba(39,52,74,.75);
      padding:2px 7px;
      border-radius:999px;
    }
  </style>
</head>

<body>
<div class="app">

  <!-- TOP -->
  <div class="top" id="topBar">
    <div class="logoBtn" id="logoBtn" title="로고 URL 설정">
      <img class="logoImg" id="logoImg" alt="MAPMODE" style="display:none;" />
      <div class="logoFallback" id="logoFallback">MAPMODE</div>
    </div>

    <div class="topCats" id="topCats"></div>

    <div class="topRight">
      <button class="btn ghost" id="btnExport" title="state.json 내보내기">state.json 내보내기</button>
      <button class="btn danger" id="btnResetAll" title="전체 초기화">전체 초기화</button>
      <button class="btn ok" id="btnAuth" title="관리자 로그인">관리자 로그인</button>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">

    <!-- LEFT -->
    <div class="panel" id="leftPanel">
      <div class="panelHeader">
        <div>
          <div class="title">좌측 메뉴바</div>
          <div class="sub">페이지 관리</div>
        </div>
        <div class="badge" title="현재 선택된 카테고리/페이지">
          <span class="miniDot"></span>
          <span id="leftBadgeText">-</span>
        </div>
      </div>
      <div class="panelBody">
        <div class="card">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
            <div class="col grow" style="gap:4px;">
              <div style="font-weight:900; font-size:13px;">페이지</div>
              <div class="small muted">카테고리별로 별도 페이지 목록</div>
            </div>
            <button class="btn" id="btnAddPage">페이지 추가</button>
          </div>
          <div id="pageAddInline" style="margin-top:10px; display:none;">
            <div class="item">
              <div class="field">
                <div class="label">페이지 이름</div>
                <input class="input" id="newPageName" placeholder="예: 게임1" />
              </div>
              <div class="field">
                <div class="label">페이지 URL (선택)</div>
                <input class="input" id="newPageUrl" placeholder="예: https://..." />
              </div>
              <div class="field">
                <div class="label">지도 이미지 URL</div>
                <input class="input" id="newPageMap" placeholder="/assets/aion2/maps/xxx.png" />
              </div>
              <div class="row">
                <button class="btn ok grow" id="btnAddPageConfirm">추가</button>
                <button class="btn ghost" id="btnAddPageCancel">닫기</button>
              </div>
            </div>
          </div>
          <div class="hr"></div>
          <div class="list" id="pageList"></div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div class="col" style="gap:4px;">
              <div style="font-weight:900; font-size:13px;">추후 기능 (비활성)</div>
              <div class="small muted">구조만 준비 (기본 OFF)</div>
            </div>
          </div>
          <div class="hr"></div>
          <div class="toggle">
            <div class="left">
              <div class="dot"></div>
              <div class="name">Google 로그인</div>
            </div>
            <div class="right">
              <span class="k" id="googleLoginState">OFF</span>
              <button class="chipBtn" id="btnToggleGoogle" title="토글 (구조만)">ON/OFF</button>
            </div>
          </div>
          <div style="height:8px;"></div>
          <div class="toggle">
            <div class="left">
              <div class="dot"></div>
              <div class="name">결제 기능</div>
            </div>
            <div class="right">
              <span class="k" id="paymentState">OFF</span>
              <button class="chipBtn" id="btnTogglePayment" title="토글 (구조만)">ON/OFF</button>
            </div>
          </div>
        </div>

        <div class="footerPad"></div>
      </div>
    </div>

    <!-- CENTER -->
    <div class="canvasWrap" id="canvasWrap">
      <canvas id="c"></canvas>
      <div class="hud" id="hud">
        <span>Zoom <b id="hudZoom">1.00x</b></span>
        <span class="muted">·</span>
        <span>마커 <b id="hudMarkers">0</b></span>
        <span class="muted">·</span>
        <span>선 <b id="hudEdges">0</b></span>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel" id="rightPanel">
      <div class="panelHeader">
        <div>
          <div class="title">우측 메뉴바</div>
          <div class="sub">마커/관리자 툴</div>
        </div>
        <button class="btn" id="btnEditMarkerCats">카테고리/색상 편집</button>
      </div>
      <div class="panelBody">

        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div class="col" style="gap:4px;">
              <div style="font-weight:900; font-size:13px;">마커 카테고리</div>
              <div class="small muted">카테고리 단위 ON/OFF</div>
            </div>
          </div>
          <div class="hr"></div>
          <div class="list" id="markerCatToggles"></div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div class="col" style="gap:4px;">
              <div style="font-weight:900; font-size:13px;">관리자 툴</div>
              <div class="small muted">빠른 색상표 / 선 / 마커</div>
            </div>
          </div>
          <div class="hr"></div>

          <div class="field">
            <div class="label">빠른 색상표</div>
            <div class="palette" id="quickPalette"></div>
          </div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn grow" id="btnHideLines">모든 선 제거</button>
            <button class="btn grow" id="btnShowLines">모든 선 표시</button>
          </div>

          <div style="height:8px;"></div>

          <button class="btn danger" id="btnClearMarkers" style="width:100%;">마커 초기화</button>

          <div style="height:8px;"></div>

          <div class="row">
            <button class="btn grow" id="btnToggleHideNumbers">마커 숫자 가리기</button>
            <button class="btn grow" id="btnToggleMarkerEdit">마커 편집</button>
          </div>

          <div class="hr"></div>

          <div class="field">
            <div class="label">선택한 마커</div>
            <div class="input" id="selectedMarkerName" style="padding:10px 10px; opacity:.95;">-</div>
          </div>

          <div style="height:10px;"></div>

          <div class="field">
            <div class="label">유튜브 링크</div>
            <input class="input" id="ytTitle" placeholder="유튜브 표시명" />
          </div>
          <div class="field">
            <div class="label">유튜브 설명</div>
            <textarea class="textarea" id="ytDesc" placeholder="설명 텍스트"></textarea>
          </div>
          <div class="field">
            <div class="label">유튜브 URL</div>
            <input class="input" id="ytUrl" placeholder="https://..." />
          </div>
          <div class="row">
            <button class="btn ok grow" id="btnSaveYt">저장</button>
            <button class="btn ghost" id="btnClearYt">비우기</button>
          </div>
        </div>

        <div class="footerPad"></div>
      </div>
    </div>

  </div>

  <!-- FLYOUTS -->
  <div class="flyout" id="flyLogo" style="display:none;">
    <div class="flyoutHeader">
      <div class="t">로고 URL 설정</div>
      <button class="xbtn" data-close="flyLogo">✕</button>
    </div>
    <div class="flyoutBody">
      <div class="field">
        <div class="label">로고 이미지 URL</div>
        <input class="input" id="logoUrlInput" placeholder="/assets/logo/MAPMODELOGO2.png" />
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn ok grow" id="btnLogoApply">적용</button>
        <button class="btn ghost" data-close="flyLogo">닫기</button>
      </div>
      <div class="small muted" style="margin-top:8px;">
        로고 길이에 맞춰 버튼 크기가 자동으로 유지됩니다.
      </div>
    </div>
  </div>

  <div class="flyout" id="flyMarkerCats" style="display:none;">
    <div class="flyoutHeader">
      <div class="t">카테고리/색상 편집</div>
      <button class="xbtn" data-close="flyMarkerCats">✕</button>
    </div>
    <div class="flyoutBody">
      <div class="card" style="padding:10px;">
        <div class="row" style="justify-content:space-between; align-items:flex-start;">
          <div class="col" style="gap:4px;">
            <div style="font-weight:900; font-size:13px;">빠른 색상표</div>
            <div class="small muted">카테고리 색상 지정에 사용</div>
          </div>
        </div>
        <div style="height:8px;"></div>
        <div class="palette" id="editPalette"></div>
        <div style="height:10px;"></div>
        <div class="row">
          <div class="field grow">
            <div class="label">RGB / HEX</div>
            <input class="input" id="colorInput" placeholder="#ffffff 또는 rgb(255,255,255)" />
          </div>
          <button class="btn" id="btnApplyColorToSelectedCat">선택 카테고리 색 적용</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row" style="justify-content:space-between;">
        <div class="col" style="gap:4px;">
          <div style="font-weight:900; font-size:13px;">카테고리 목록</div>
          <div class="small muted">추가/삭제/이름/색/기본 크기</div>
        </div>
        <button class="btn" id="btnAddMarkerCat">추가</button>
      </div>

      <!-- inline add (below, not centered) -->
      <div id="markerCatAddInline" style="margin-top:10px; display:none;">
        <div class="item">
          <div class="field">
            <div class="label">새 카테고리 이름</div>
            <input class="input" id="newMarkerCatName" placeholder="예: 포탈, 보스, NPC..." />
          </div>
          <div class="row">
            <button class="btn ok grow" id="btnAddMarkerCatConfirm">추가</button>
            <button class="btn ghost" id="btnAddMarkerCatCancel">닫기</button>
          </div>
        </div>
      </div>

      <div class="list" id="markerCatEditor" style="margin-top:10px;"></div>
    </div>
  </div>

  <div class="flyout" id="flyMarkerEdit" style="display:none;">
    <div class="flyoutHeader">
      <div class="t">마커 편집</div>
      <button class="xbtn" data-close="flyMarkerEdit">✕</button>
    </div>
    <div class="flyoutBody">
      <div class="row" style="gap:10px; align-items:flex-start;">
        <div class="badge" title="마커 번호/카테고리">
          <span class="miniDot"></span>
          <span id="editBadge">-</span>
        </div>
        <div class="grow"></div>
        <button class="btn danger" id="btnDeleteMarker">삭제</button>
      </div>

      <div style="height:10px;"></div>

      <div class="field">
        <div class="label">마커 이름</div>
        <input class="input" id="editName" placeholder="마커 이름" />
      </div>

      <div class="field">
        <div class="label">카테고리</div>
        <select class="select" id="editCat"></select>
      </div>

      <div class="field">
        <div class="label">유튜브 표시명</div>
        <input class="input" id="editYtTitle" placeholder="인덱스에서 보일 이름" />
      </div>

      <div class="field">
        <div class="label">유튜브 URL</div>
        <input class="input" id="editYtUrl" placeholder="https://..." />
      </div>

      <div class="row">
        <div class="field grow">
          <div class="label">마커 원 크기 (1~100px)</div>
          <input class="input" id="editSize" type="number" min="1" max="100" />
        </div>
        <div class="field grow">
          <div class="label">마커 텍스트 크기</div>
          <input class="input" id="editTextSize" type="number" min="1" max="200" />
        </div>
      </div>

      <div class="row">
        <div class="field grow">
          <div class="label">텍스트 굵기</div>
          <select class="select" id="editWeight">
            <option value="400">400</option>
            <option value="500">500</option>
            <option value="600">600</option>
            <option value="700">700</option>
            <option value="800">800</option>
            <option value="900">900</option>
          </select>
        </div>
        <div class="field grow">
          <div class="label">글씨 색상</div>
          <input class="input" id="editTextColor" placeholder="#ffffff" />
        </div>
      </div>

      <div class="field">
        <div class="label">빠른 색상표</div>
        <div class="palette" id="editTextPalette"></div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn grow" id="btnNewSequence">새로운 번호로 시작</button>
        <button class="btn grow" id="btnContinueFromHere">해당 마커를 이어서 시작</button>
      </div>

      <div style="height:10px;"></div>

      <div class="row">
        <button class="btn ok grow" id="btnSaveMarker">저장</button>
        <button class="btn ghost" data-close="flyMarkerEdit">닫기</button>
      </div>

      <div class="small muted" style="margin-top:10px;">
        엔터 키를 누르면 저장되고 창이 닫힙니다.
      </div>
    </div>
  </div>

</div>

<script>
/* ============================================================
   MAPMODE · ADMIN (single HTML)
   - GitHub 구조 기준:
     /aion2/admin.html
     /aion2/data/state.json
     /assets/aion2/maps/
     /assets/logo/MAPMODELOGO2.png
   - localStorage:
     LS_AUTH_KEY=mapmode_admin_auth_v99
     LS_KEY=mapmode_state_v99
   - PASSWORD=0000000001
   - AUTH_MS=24h
   - REMOTE_STATE_URL=new URL("./data/state.json", location.href)
   ============================================================ */

(() => {
  "use strict";

  /* ===== Fixed constants ===== */
  const LS_AUTH_KEY = "mapmode_admin_auth_v99";
  const LS_KEY      = "mapmode_state_v99";
  const PASSWORD    = "0000000001";
  const AUTH_MS     = 24 * 60 * 60 * 1000;
  const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

  /* ===== Quick colors ===== */
  const QUICK = [
    { name:"빨", c:"#ff3b30" },
    { name:"주", c:"#ff9500" },
    { name:"노", c:"#ffd60a" },
    { name:"초", c:"#34c759" },
    { name:"파", c:"#0a84ff" },
    { name:"흰", c:"#ffffff" },
    { name:"검", c:"#000000" }
  ];

  /* ===== State schema ===== */
  const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + "_" + Date.now()));
  const now = () => Date.now();

  function defaultState(){
    // 4 top categories fixed
    const topCats = Array.from({length:4}).map((_,i)=>({
      id: "topcat_" + (i+1),
      name: "카테고리" + (i+1),
      pages: [
        // initial placeholder page for each category
        {
          id: uid(),
          name: "페이지1",
          url: "",
          mapImageUrl: "/assets/aion2/maps/map1.png",
          // marker categories toggles are global, but markers belong to markerCatId.
          markers: [],
          edges: [], // {id, from, to, ctrl:{x,y}|null}
          showLines: true,
          // numbering control per markerCat sequence
          activeSeqByCat: {}, // markerCatId -> {seqId, nextNum}
          seqCounter: 0
        }
      ],
      selectedPageId: null
    }));

    // marker categories (global list)
    const markerCats = [
      {
        id: "mcat_all",
        name: "전체",
        color: "#7cc4ff",
        baseSize: 26,
        enabled: true,
        hideNumbers: false,
        deletable: false
      }
    ];

    return {
      version: 1,
      updatedAt: now(),
      logoUrl: "/assets/logo/MAPMODELOGO2.png",
      features: { googleLoginEnabled:false, paymentEnabled:false },
      topCats,
      markerCats,
      ui: {
        currentTopCatId: topCats[0].id,
        currentMarkerCatId: markerCats[0].id,
        markerEditEnabled: true
      }
    };
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

  function parseColor(s){
    if(!s) return null;
    s = (""+s).trim();
    // allow rgb(...)
    if(/^rgb\(/i.test(s)) return s;
    if(/^#([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(s)) return s;
    return null;
  }

  /* ===== Persistence ===== */
  let state = null;

  function loadFromLocal(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      return obj && typeof obj==="object" ? obj : null;
    }catch(e){ return null; }
  }

  async function loadFromRemote(){
    try{
      const res = await fetch(REMOTE_STATE_URL.toString(), { cache:"no-store" });
      if(!res.ok) return null;
      const obj = await res.json();
      return obj && typeof obj==="object" ? obj : null;
    }catch(e){ return null; }
  }

  function saveLocal(){
    try{
      state.updatedAt = now();
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    }catch(e){}
  }

  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 400);
  }

  /* ===== Auth ===== */
  function isAuthed(){
    try{
      const raw = localStorage.getItem(LS_AUTH_KEY);
      if(!raw) return false;
      const obj = JSON.parse(raw);
      if(!obj || typeof obj!=="object") return false;
      return (obj.exp && now() < obj.exp);
    }catch(e){
      return false;
    }
  }

  function setAuth(){
    const exp = now() + AUTH_MS;
    localStorage.setItem(LS_AUTH_KEY, JSON.stringify({ exp }));
  }

  function clearAuth(){
    localStorage.removeItem(LS_AUTH_KEY);
  }

  function ensureAuth(){
    if(isAuthed()) return true;
    const pw = prompt("관리자 비밀번호를 입력하세요");
    if(pw === null) return false;
    if((pw+"") === PASSWORD){
      setAuth();
      return true;
    }
    alert("비밀번호가 올바르지 않습니다.");
    return false;
  }

  /* ===== DOM ===== */
  const $ = (sel, root=document) => root.querySelector(sel);

  const topCatsEl = $("#topCats");
  const logoBtn = $("#logoBtn");
  const logoImg = $("#logoImg");
  const logoFallback = $("#logoFallback");

  const btnExport = $("#btnExport");
  const btnResetAll = $("#btnResetAll");
  const btnAuth = $("#btnAuth");

  const leftBadgeText = $("#leftBadgeText");
  const pageList = $("#pageList");
  const btnAddPage = $("#btnAddPage");
  const pageAddInline = $("#pageAddInline");
  const newPageName = $("#newPageName");
  const newPageUrl = $("#newPageUrl");
  const newPageMap = $("#newPageMap");
  const btnAddPageConfirm = $("#btnAddPageConfirm");
  const btnAddPageCancel = $("#btnAddPageCancel");

  const googleLoginState = $("#googleLoginState");
  const paymentState = $("#paymentState");
  const btnToggleGoogle = $("#btnToggleGoogle");
  const btnTogglePayment = $("#btnTogglePayment");

  const markerCatToggles = $("#markerCatToggles");

  const quickPalette = $("#quickPalette");
  const btnHideLines = $("#btnHideLines");
  const btnShowLines = $("#btnShowLines");
  const btnClearMarkers = $("#btnClearMarkers");
  const btnToggleHideNumbers = $("#btnToggleHideNumbers");
  const btnToggleMarkerEdit = $("#btnToggleMarkerEdit");

  const selectedMarkerName = $("#selectedMarkerName");
  const ytTitle = $("#ytTitle");
  const ytDesc = $("#ytDesc");
  const ytUrl = $("#ytUrl");
  const btnSaveYt = $("#btnSaveYt");
  const btnClearYt = $("#btnClearYt");

  const canvasWrap = $("#canvasWrap");
  const canvas = $("#c");
  const ctx = canvas.getContext("2d");

  const hudZoom = $("#hudZoom");
  const hudMarkers = $("#hudMarkers");
  const hudEdges = $("#hudEdges");

  // flyouts
  const flyLogo = $("#flyLogo");
  const logoUrlInput = $("#logoUrlInput");
  const btnLogoApply = $("#btnLogoApply");

  const flyMarkerCats = $("#flyMarkerCats");
  const btnEditMarkerCats = $("#btnEditMarkerCats");
  const editPalette = $("#editPalette");
  const colorInput = $("#colorInput");
  const btnApplyColorToSelectedCat = $("#btnApplyColorToSelectedCat");
  const btnAddMarkerCat = $("#btnAddMarkerCat");
  const markerCatAddInline = $("#markerCatAddInline");
  const newMarkerCatName = $("#newMarkerCatName");
  const btnAddMarkerCatConfirm = $("#btnAddMarkerCatConfirm");
  const btnAddMarkerCatCancel = $("#btnAddMarkerCatCancel");
  const markerCatEditor = $("#markerCatEditor");

  const flyMarkerEdit = $("#flyMarkerEdit");
  const editBadge = $("#editBadge");
  const btnDeleteMarker = $("#btnDeleteMarker");
  const editName = $("#editName");
  const editCat = $("#editCat");
  const editYtTitle = $("#editYtTitle");
  const editYtUrl = $("#editYtUrl");
  const editSize = $("#editSize");
  const editTextSize = $("#editTextSize");
  const editWeight = $("#editWeight");
  const editTextColor = $("#editTextColor");
  const editTextPalette = $("#editTextPalette");
  const btnNewSequence = $("#btnNewSequence");
  const btnContinueFromHere = $("#btnContinueFromHere");
  const btnSaveMarker = $("#btnSaveMarker");

  /* ===== UI helpers ===== */
  function placeFlyoutNear(el, fly, preferred="bottom"){
    // calculate absolute position
    const r = el.getBoundingClientRect();
    const wrap = document.body.getBoundingClientRect();
    fly.style.display = "block";
    fly.style.visibility = "hidden";

    const fr = fly.getBoundingClientRect();
    const pad = 10;
    let x = r.left;
    let y = (preferred==="bottom") ? (r.bottom + 8) : (r.top - fr.height - 8);

    // keep inside viewport
    x = clamp(x, pad, window.innerWidth - fr.width - pad);
    y = clamp(y, pad + 56, window.innerHeight - fr.height - pad);

    fly.style.left = (x - wrap.left) + "px";
    fly.style.top  = (y - wrap.top) + "px";
    fly.style.visibility = "visible";
  }

  function hideFlyout(fly){ fly.style.display="none"; }
  function showFlyoutNear(el, fly, preferred){ placeFlyoutNear(el, fly, preferred); }

  function closeAllFlyouts(){
    hideFlyout(flyLogo);
    hideFlyout(flyMarkerCats);
    hideFlyout(flyMarkerEdit);
  }

  document.addEventListener("click", (e)=>{
    const closeId = e.target?.getAttribute?.("data-close");
    if(closeId){
      const fly = document.getElementById(closeId);
      if(fly) hideFlyout(fly);
      return;
    }
  });

  window.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      closeAllFlyouts();
    }
  });

  /* ===== State accessors ===== */
  function getTopCat(id){
    return state.topCats.find(c=>c.id===id) || state.topCats[0];
  }
  function curTopCat(){
    return getTopCat(state.ui.currentTopCatId);
  }
  function curPage(){
    const cat = curTopCat();
    const sel = cat.selectedPageId || (cat.pages[0] && cat.pages[0].id);
    if(!cat.selectedPageId) cat.selectedPageId = sel;
    return cat.pages.find(p=>p.id===sel) || cat.pages[0];
  }
  function getMarkerCat(id){
    return state.markerCats.find(m=>m.id===id) || state.markerCats[0];
  }
  function curMarkerCat(){
    return getMarkerCat(state.ui.currentMarkerCatId);
  }

  function ensureAllStructures(){
    // Ensure selectedPageId exists
    for(const cat of state.topCats){
      if(!cat.selectedPageId && cat.pages[0]) cat.selectedPageId = cat.pages[0].id;
      if(cat.selectedPageId && !cat.pages.some(p=>p.id===cat.selectedPageId)){
        cat.selectedPageId = cat.pages[0]?.id || null;
      }
      // ensure pages fields
      for(const p of cat.pages){
        p.markers = Array.isArray(p.markers) ? p.markers : [];
        p.edges = Array.isArray(p.edges) ? p.edges : [];
        if(typeof p.showLines !== "boolean") p.showLines = true;
        p.activeSeqByCat = p.activeSeqByCat && typeof p.activeSeqByCat==="object" ? p.activeSeqByCat : {};
        p.seqCounter = (typeof p.seqCounter==="number") ? p.seqCounter : 0;
      }
    }
    // ensure markerCats
    state.markerCats = Array.isArray(state.markerCats) ? state.markerCats : [];
    if(!state.markerCats.length){
      state.markerCats.push({
        id:"mcat_all", name:"전체", color:"#7cc4ff", baseSize:26, enabled:true, hideNumbers:false, deletable:false
      });
    }
    // ensure features
    state.features = state.features && typeof state.features==="object" ? state.features : { googleLoginEnabled:false, paymentEnabled:false };
    if(typeof state.features.googleLoginEnabled !== "boolean") state.features.googleLoginEnabled = false;
    if(typeof state.features.paymentEnabled !== "boolean") state.features.paymentEnabled = false;
    // ui
    state.ui = state.ui && typeof state.ui==="object" ? state.ui : { currentTopCatId: state.topCats[0]?.id, currentMarkerCatId: state.markerCats[0]?.id, markerEditEnabled:true };
    if(!state.ui.currentTopCatId) state.ui.currentTopCatId = state.topCats[0]?.id;
    if(!state.ui.currentMarkerCatId) state.ui.currentMarkerCatId = state.markerCats[0]?.id;
    if(typeof state.ui.markerEditEnabled !== "boolean") state.ui.markerEditEnabled = true;
  }

  /* ===== Top categories UI ===== */
  function renderTopCats(){
    topCatsEl.innerHTML = "";
    state.topCats.forEach((cat)=>{
      const b = document.createElement("div");
      b.className = "pill" + (cat.id===state.ui.currentTopCatId ? " active" : "");
      b.innerHTML = `<span class="dot"></span><span>${escapeHtml(cat.name)}</span>`;
      b.addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        state.ui.currentTopCatId = cat.id;
        // keep previous selected page
        if(!cat.selectedPageId && cat.pages[0]) cat.selectedPageId = cat.pages[0].id;
        saveLocal();
        renderAll();
      });
      topCatsEl.appendChild(b);
    });
  }

  /* ===== Logo ===== */
  function applyLogo(){
    const url = state.logoUrl || "";
    if(url){
      logoImg.src = url;
      logoImg.style.display = "block";
      logoFallback.style.display = "none";
      logoImg.onerror = ()=>{
        logoImg.style.display = "none";
        logoFallback.style.display = "block";
      };
    }else{
      logoImg.style.display = "none";
      logoFallback.style.display = "block";
    }
  }

  /* ===== Left pages UI ===== */
  function renderPages(){
    const cat = curTopCat();
    const page = curPage();

    leftBadgeText.textContent = `${cat.name} · ${page?.name || "-"}`;

    pageList.innerHTML = "";
    cat.pages.forEach((p)=>{
      const btn = document.createElement("div");
      btn.className = "pageBtn" + (p.id===page.id ? " active" : "");
      const mCount = (p.markers||[]).length;
      btn.innerHTML = `
        <div class="name">${escapeHtml(p.name || "페이지")}</div>
        <div class="meta">${mCount} 마커</div>
      `;
      btn.addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        cat.selectedPageId = p.id;
        saveLocal();
        renderAll();
      });
      pageList.appendChild(btn);

      // inline edit controls per page
      const item = document.createElement("div");
      item.className = "item";
      item.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <div class="badge"><span class="miniDot"></span><span>설정</span></div>
          <div class="row" style="gap:6px;">
            <button class="chipBtn" data-act="rename">이름</button>
            <button class="chipBtn" data-act="url">URL</button>
            <button class="chipBtn" data-act="map">지도</button>
            <button class="chipBtn danger" data-act="del">삭제</button>
          </div>
        </div>
        <div class="small muted" style="line-height:1.35;">
          <div><span class="k">URL</span> ${escapeHtml(p.url || "-")}</div>
          <div style="margin-top:6px;"><span class="k">지도</span> ${escapeHtml(p.mapImageUrl || "-")}</div>
        </div>
      `;
      item.querySelector('[data-act="rename"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        const v = prompt("페이지 이름", p.name || "");
        if(v===null) return;
        p.name = (v+"").trim() || p.name;
        saveLocal(); renderAll();
      });
      item.querySelector('[data-act="url"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        const v = prompt("페이지 URL", p.url || "");
        if(v===null) return;
        p.url = (v+"").trim();
        saveLocal(); renderAll();
      });
      item.querySelector('[data-act="map"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        const v = prompt("지도 이미지 URL", p.mapImageUrl || "");
        if(v===null) return;
        p.mapImageUrl = (v+"").trim();
        // reload background image
        loadMapImageForCurrentPage(true);
        saveLocal(); renderAll();
      });
      item.querySelector('[data-act="del"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        if(cat.pages.length<=1){
          alert("최소 1개 페이지는 유지되어야 합니다.");
          return;
        }
        const ok = confirm("해당 페이지를 삭제할까요?");
        if(!ok) return;
        const idx = cat.pages.findIndex(x=>x.id===p.id);
        if(idx>=0){
          cat.pages.splice(idx,1);
          if(cat.selectedPageId===p.id){
            cat.selectedPageId = cat.pages[0]?.id || null;
          }
          saveLocal();
          renderAll();
        }
      });
      pageList.appendChild(item);
    });
  }

  function togglePageAddInline(show){
    pageAddInline.style.display = show ? "block" : "none";
    if(show){
      newPageName.value = "";
      newPageUrl.value = "";
      newPageMap.value = "/assets/aion2/maps/";
      setTimeout(()=>newPageName.focus(), 0);
    }
  }

  /* ===== Marker categories (global) ===== */
  function renderMarkerCatToggles(){
    const page = curPage();
    markerCatToggles.innerHTML = "";

    // "전체" toggle is markerCats[0] by default but must exist
    state.markerCats.forEach((mc)=>{
      const row = document.createElement("div");
      row.className = "toggle";
      const dotColor = mc.color || "#7cc4ff";
      row.innerHTML = `
        <div class="left">
          <div class="dot" style="background:${escapeHtml(dotColor)}; box-shadow:0 0 0 3px ${escapeHtml(hexToRgba(dotColor, .12))};"></div>
          <div class="name">${escapeHtml(mc.name)}</div>
        </div>
        <div class="right">
          <span class="k">${mc.enabled ? "ON" : "OFF"}</span>
          <button class="chipBtn" data-act="toggle">${mc.enabled ? "비활성" : "활성"}</button>
          <button class="chipBtn" data-act="select">선택</button>
        </div>
      `;
      row.querySelector('[data-act="toggle"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        mc.enabled = !mc.enabled;
        saveLocal();
        renderAll();
      });
      row.querySelector('[data-act="select"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        state.ui.currentMarkerCatId = mc.id;
        saveLocal();
        renderAll();
      });
      if(mc.id === state.ui.currentMarkerCatId){
        row.style.borderColor = "rgba(124,196,255,.75)";
        row.style.background = "rgba(124,196,255,.10)";
      }
      markerCatToggles.appendChild(row);
    });

    // update tools buttons label states based on current marker cat
    const mcat = curMarkerCat();
    btnToggleHideNumbers.textContent = (mcat.hideNumbers ? "마커 숫자 보이기" : "마커 숫자 가리기");
    btnToggleMarkerEdit.textContent = (state.ui.markerEditEnabled ? "마커 편집 ON" : "마커 편집 OFF");
  }

  function renderMarkerCatEditor(){
    markerCatEditor.innerHTML = "";
    const selectedId = state.ui.currentMarkerCatId;
    for(const mc of state.markerCats){
      const item = document.createElement("div");
      item.className = "item";
      const isSel = mc.id === selectedId;
      item.style.borderColor = isSel ? "rgba(124,196,255,.75)" : "rgba(39,52,74,.65)";
      const canDel = !!mc.deletable;

      item.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <div class="row" style="gap:10px;">
            <div class="swatch" style="width:32px;height:32px;border-radius:12px;background:${escapeHtml(mc.color)}"></div>
            <div class="col" style="gap:4px;">
              <div style="font-weight:900; font-size:13px;">${escapeHtml(mc.name)}</div>
              <div class="small muted">기본 크기: <span class="k">${mc.baseSize}px</span> · 숫자: <span class="k">${mc.hideNumbers ? "숨김" : "표시"}</span></div>
            </div>
          </div>
          <div class="row" style="gap:6px;">
            <button class="chipBtn" data-act="select">선택</button>
            <button class="chipBtn" data-act="rename">이름</button>
            <button class="chipBtn" data-act="size">크기</button>
            <button class="chipBtn" data-act="hide">${mc.hideNumbers ? "숫자표시" : "숫자숨김"}</button>
            <button class="chipBtn ${canDel ? "danger" : ""}" data-act="del" ${canDel ? "" : "disabled"}>삭제</button>
          </div>
        </div>
      `;

      item.querySelector('[data-act="select"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        state.ui.currentMarkerCatId = mc.id;
        saveLocal(); renderAll();
      });

      item.querySelector('[data-act="rename"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        const v = prompt("카테고리 이름", mc.name || "");
        if(v===null) return;
        mc.name = (v+"").trim() || mc.name;
        saveLocal(); renderAll();
      });

      item.querySelector('[data-act="size"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        const v = prompt("기본 마커 크기(px, 1~100)", mc.baseSize);
        if(v===null) return;
        let n = Number(v);
        if(!Number.isFinite(n)) return;
        n = clamp(Math.round(n), 1, 100);
        applyMarkerCatBaseSize(mc.id, n);
        saveLocal(); renderAll();
      });

      item.querySelector('[data-act="hide"]').addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        mc.hideNumbers = !mc.hideNumbers;
        saveLocal(); renderAll();
      });

      const delBtn = item.querySelector('[data-act="del"]');
      if(canDel){
        delBtn.addEventListener("click", ()=>{
          if(!ensureAuth()) return;
          const ok = confirm("카테고리를 삭제할까요? (해당 카테고리 마커는 '전체'로 이동됩니다)");
          if(!ok) return;
          deleteMarkerCat(mc.id);
          saveLocal(); renderAll();
        });
      }

      markerCatEditor.appendChild(item);
    }
  }

  function addMarkerCat(name){
    const id = uid();
    state.markerCats.push({
      id,
      name: name || "새카테고리",
      color: "#7cc4ff",
      baseSize: 26,
      enabled: true,
      hideNumbers: false,
      deletable: true
    });
    state.ui.currentMarkerCatId = id;
    // ensure sequences map exists (per page) will be created on demand
  }

  function deleteMarkerCat(markerCatId){
    if(markerCatId === "mcat_all") return;
    // move markers to all
    for(const top of state.topCats){
      for(const p of top.pages){
        for(const m of p.markers){
          if(m.markerCatId === markerCatId){
            m.markerCatId = "mcat_all";
          }
        }
        // cleanup sequence state
        if(p.activeSeqByCat && p.activeSeqByCat[markerCatId]){
          delete p.activeSeqByCat[markerCatId];
        }
      }
    }
    // remove cat
    const idx = state.markerCats.findIndex(x=>x.id===markerCatId);
    if(idx>=0) state.markerCats.splice(idx,1);
    if(state.ui.currentMarkerCatId === markerCatId) state.ui.currentMarkerCatId = "mcat_all";
  }

  function applyMarkerCatColor(markerCatId, color){
    const mc = getMarkerCat(markerCatId);
    mc.color = color;

    // apply to existing markers: category color drives marker fill color
    for(const top of state.topCats){
      for(const p of top.pages){
        for(const m of p.markers){
          if(m.markerCatId === markerCatId){
            m.fill = color;
          }
        }
      }
    }
  }

  function applyMarkerCatBaseSize(markerCatId, baseSize){
    const mc = getMarkerCat(markerCatId);
    mc.baseSize = baseSize;

    // apply to markers: keep their textScale, but update size to baseSize for consistency per category
    for(const top of state.topCats){
      for(const p of top.pages){
        for(const m of p.markers){
          if(m.markerCatId === markerCatId){
            const ts = (typeof m.textScale === "number" && m.textScale>0) ? m.textScale : (m.textSize && m.size ? (m.textSize/m.size) : 0.45);
            m.size = baseSize;
            m.textScale = ts;
            m.textSize = Math.max(8, Math.round(m.size * m.textScale));
          }
        }
      }
    }
  }

  /* ===== Feature toggles (structure only) ===== */
  function renderFeatureToggles(){
    googleLoginState.textContent = state.features.googleLoginEnabled ? "ON" : "OFF";
    paymentState.textContent = state.features.paymentEnabled ? "ON" : "OFF";
  }

  /* ===== Utility HTML escaping ===== */
  function escapeHtml(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function hexToRgba(hex, a){
    hex = (hex||"").trim();
    if(!hex.startsWith("#")) return "rgba(124,196,255,"+a+")";
    let h = hex.slice(1);
    if(h.length===3) h = h.split("").map(ch=>ch+ch).join("");
    if(h.length<6) return "rgba(124,196,255,"+a+")";
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  /* ===== Canvas / Map rendering ===== */
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let vw = 0, vh = 0;

  const view = {
    scale: 1,
    tx: 0,
    ty: 0
  };

  let mapImg = new Image();
  let mapReady = false;

  function resizeCanvas(){
    const r = canvasWrap.getBoundingClientRect();
    vw = Math.max(1, Math.floor(r.width));
    vh = Math.max(1, Math.floor(r.height));
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(vw * dpr);
    canvas.height = Math.floor(vh * dpr);
    canvas.style.width = vw + "px";
    canvas.style.height = vh + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  window.addEventListener("resize", resizeCanvas);

  function worldToScreen(pt){
    return {
      x: pt.x * view.scale + view.tx,
      y: pt.y * view.scale + view.ty
    };
  }
  function screenToWorld(pt){
    return {
      x: (pt.x - view.tx) / view.scale,
      y: (pt.y - view.ty) / view.scale
    };
  }

  function fitToImage(){
    if(!mapReady) return;
    const iw = mapImg.naturalWidth || mapImg.width;
    const ih = mapImg.naturalHeight || mapImg.height;
    if(iw<=0 || ih<=0) return;

    const pad = 40;
    const sx = (vw - pad*2) / iw;
    const sy = (vh - pad*2) / ih;
    const s = clamp(Math.min(sx, sy), 0.05, 6);
    view.scale = s;
    view.tx = (vw - iw*s) * 0.5;
    view.ty = (vh - ih*s) * 0.5;
  }

  function loadMapImageForCurrentPage(forceFit=false){
    const p = curPage();
    const url = (p.mapImageUrl || "").trim();
    mapReady = false;

    // placeholder grid if empty
    if(!url){
      mapImg = new Image();
      mapImg.onload = ()=>{};
      draw();
      return;
    }

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = ()=>{
      mapImg = img;
      mapReady = true;
      if(forceFit) fitToImage();
      draw();
    };
    img.onerror = ()=>{
      mapReady = false;
      draw();
    };
    img.src = url;
  }

  function drawChecker(){
    const g = ctx.createLinearGradient(0,0,vw,vh);
    g.addColorStop(0,"rgba(39,52,74,.22)");
    g.addColorStop(1,"rgba(39,52,74,.08)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,vw,vh);

    const step = 48;
    ctx.strokeStyle = "rgba(39,52,74,.28)";
    ctx.lineWidth = 1;
    for(let x=0;x<vw;x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,vh); ctx.stroke();
    }
    for(let y=0;y<vh;y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(vw,y); ctx.stroke();
    }
  }

  function draw(){
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,vw,vh);

    drawChecker();

    // draw map
    if(mapReady){
      const iw = mapImg.naturalWidth || mapImg.width;
      const ih = mapImg.naturalHeight || mapImg.height;
      const x = view.tx;
      const y = view.ty;
      const w = iw * view.scale;
      const h = ih * view.scale;

      // subtle shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,.35)";
      ctx.shadowBlur = 24;
      ctx.shadowOffsetY = 14;
      roundRect(ctx, x-2, y-2, w+4, h+4, 16);
      ctx.fillStyle = "rgba(0,0,0,.15)";
      ctx.fill();
      ctx.restore();

      ctx.save();
      roundRect(ctx, x, y, w, h, 16);
      ctx.clip();
      ctx.drawImage(mapImg, x, y, w, h);
      ctx.restore();

      // border
      ctx.save();
      roundRect(ctx, x, y, w, h, 16);
      ctx.strokeStyle = "rgba(124,196,255,.16)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }else{
      // message
      ctx.save();
      ctx.fillStyle = "rgba(231,238,248,.85)";
      ctx.font = "800 14px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
      ctx.fillText("지도 이미지 URL을 설정하세요", 22, 34);
      ctx.fillStyle = "rgba(159,176,198,.9)";
      ctx.font = "500 12px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
      ctx.fillText("/assets/aion2/maps/ 폴더의 이미지를 사용하세요", 22, 56);
      ctx.restore();
    }

    // draw edges + arrows
    const p = curPage();
    const edges = p.edges || [];
    const markers = p.markers || [];

    // visible marker categories
    const enabledCats = new Set(state.markerCats.filter(x=>x.enabled).map(x=>x.id));
    const showAll = enabledCats.has("mcat_all"); // if '전체' is ON, everything is visible
    const visibleMarker = (m) => {
      if(!m) return false;
      if(showAll) return true;
      return enabledCats.has(m.markerCatId);
    };

    // show lines based on p.showLines and button
    if(p.showLines){
      for(const e of edges){
        const a = markers.find(m=>m.id===e.from);
        const b = markers.find(m=>m.id===e.to);
        if(!a || !b) continue;
        if(!visibleMarker(a) || !visibleMarker(b)) continue;

        const col = a.fill || "#7cc4ff";
        const A = worldToScreen({x:a.x, y:a.y});
        const B = worldToScreen({x:b.x, y:b.y});
        const Cw = e.ctrl ? worldToScreen(e.ctrl) : null;

        drawEdgeWithArrow(A, B, Cw, col);

        // draw control handle when in marker edit mode and near selected? (only if edge has ctrl or is being dragged)
        // (No extra UI unless interacting)
      }
    }

    // draw markers
    for(const m of markers){
      if(!visibleMarker(m)) continue;
      drawMarker(m);
    }

    updateHud();
  }

  function roundRect(ctx, x,y,w,h,r){
    r = Math.max(0, Math.min(r, Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawMarker(m){
    const mc = getMarkerCat(m.markerCatId);
    const hideNum = !!mc.hideNumbers;

    const s = worldToScreen({x:m.x, y:m.y});
    const size = (m.size || mc.baseSize || 26) * view.scale;
    const r = Math.max(6, size/2);

    const fill = m.fill || mc.color || "#7cc4ff";
    const alpha = m.dimmed ? 0.30 : 1.0;

    // circle
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI*2);
    ctx.fillStyle = fill;
    ctx.fill();

    // subtle ring
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = Math.max(1, 2 * view.scale);
    ctx.stroke();
    ctx.restore();

    // number
    if(!hideNum){
      ctx.save();
      const textSize = (m.textSize || Math.max(10, Math.round((m.size || 26) * (m.textScale || 0.45)))) * view.scale;
      const weight = m.textWeight || 800;
      ctx.font = `${weight} ${Math.max(10, textSize)}px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
      ctx.fillStyle = "#000000";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(m.num || 1), s.x, s.y);
      ctx.restore();
    }

    // marker text (no background)
    if(m.name){
      ctx.save();
      const tSize = (m.labelSize || Math.max(12, Math.round((m.textSize || 12)))) * view.scale;
      ctx.font = `700 ${Math.max(10, tSize)}px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
      ctx.fillStyle = (m.labelColor || "#e7eef8");
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      const offset = r + 8*view.scale;
      ctx.fillText(m.name, s.x + offset, s.y);
      ctx.restore();
    }
  }

  function drawEdgeWithArrow(A, B, C, color){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, 3 * view.scale);
    ctx.globalAlpha = 0.95;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // curve or straight
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    if(C){
      ctx.quadraticCurveTo(C.x, C.y, B.x, B.y);
    }else{
      ctx.lineTo(B.x, B.y);
    }
    ctx.stroke();

    // arrow at end (at B, tangent direction)
    const t = 0.98;
    let px, py, dx, dy;
    if(C){
      // derivative of quadratic Bezier: 2(1-t)(C-A)+2t(B-C)
      const qx = (1-t)*(1-t)*A.x + 2*(1-t)*t*C.x + t*t*B.x;
      const qy = (1-t)*(1-t)*A.y + 2*(1-t)*t*C.y + t*t*B.y;
      px = qx; py = qy;
      dx = 2*(1-t)*(C.x - A.x) + 2*t*(B.x - C.x);
      dy = 2*(1-t)*(C.y - A.y) + 2*t*(B.y - C.y);
    }else{
      px = A.x + (B.x-A.x)*t;
      py = A.y + (B.y-A.y)*t;
      dx = (B.x-A.x);
      dy = (B.y-A.y);
    }
    const ang = Math.atan2(dy, dx);
    const len = Math.max(10, 14 * view.scale);
    const wing = Math.max(6, 8 * view.scale);

    ctx.fillStyle = color;
    ctx.globalAlpha = 0.98;
    ctx.beginPath();
    ctx.moveTo(B.x, B.y);
    ctx.lineTo(B.x - len*Math.cos(ang) + wing*Math.cos(ang + Math.PI/2),
               B.y - len*Math.sin(ang) + wing*Math.sin(ang + Math.PI/2));
    ctx.lineTo(B.x - len*Math.cos(ang) - wing*Math.cos(ang + Math.PI/2),
               B.y - len*Math.sin(ang) - wing*Math.sin(ang + Math.PI/2));
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function updateHud(){
    hudZoom.textContent = view.scale.toFixed(2) + "x";
    const p = curPage();
    hudMarkers.textContent = String((p.markers||[]).length);
    hudEdges.textContent = String((p.edges||[]).length);
  }

  /* ===== Interaction ===== */
  let pointerDown = false;
  let pointerId = null;
  let startPt = {x:0,y:0};
  let startView = {tx:0,ty:0,scale:1};
  let draggingCanvas = false;
  let draggingMarker = false;
  let draggingEdge = false;
  let dragEdgeId = null;
  let selectedMarkerId = null;
  let lastTapTime = 0;

  function findMarkerAtScreen(x,y){
    const p = curPage();
    const enabledCats = new Set(state.markerCats.filter(x=>x.enabled).map(x=>x.id));
    const showAll = enabledCats.has("mcat_all");
    const visible = (m)=> showAll ? true : enabledCats.has(m.markerCatId);

    // check topmost (last)
    for(let i=p.markers.length-1; i>=0; i--){
      const m = p.markers[i];
      if(!visible(m)) continue;
      const s = worldToScreen(m);
      const r = ((m.size || getMarkerCat(m.markerCatId).baseSize || 26) * view.scale)/2;
      const dx = x - s.x, dy = y - s.y;
      if(dx*dx + dy*dy <= r*r) return m;
    }
    return null;
  }

  function distPointToSegment(px,py, ax,ay, bx,by){
    const vx = bx-ax, vy = by-ay;
    const wx = px-ax, wy = py-ay;
    const c1 = vx*wx + vy*wy;
    if(c1<=0) return Math.hypot(px-ax, py-ay);
    const c2 = vx*vx + vy*vy;
    if(c2<=c1) return Math.hypot(px-bx, py-by);
    const t = c1/c2;
    const projx = ax + t*vx, projy = ay + t*vy;
    return Math.hypot(px-projx, py-projy);
  }

  function hitEdgeAtScreen(x,y){
    const p = curPage();
    if(!p.showLines) return null;

    const enabledCats = new Set(state.markerCats.filter(x=>x.enabled).map(x=>x.id));
    const showAll = enabledCats.has("mcat_all");
    const visible = (m)=> showAll ? true : enabledCats.has(m.markerCatId);

    let best = null;
    let bestD = Infinity;

    for(const e of (p.edges||[])){
      const a = p.markers.find(m=>m.id===e.from);
      const b = p.markers.find(m=>m.id===e.to);
      if(!a || !b) continue;
      if(!visible(a) || !visible(b)) continue;

      const A = worldToScreen(a);
      const B = worldToScreen(b);
      let d;
      if(e.ctrl){
        const C = worldToScreen(e.ctrl);
        // sample quadratic
        d = sampleQuadDistance(x,y,A,C,B);
      }else{
        d = distPointToSegment(x,y,A.x,A.y,B.x,B.y);
      }
      if(d < bestD){
        bestD = d;
        best = e;
      }
    }

    if(best && bestD <= Math.max(10, 12*view.scale)){
      return best;
    }
    return null;
  }

  function sampleQuadDistance(x,y,A,C,B){
    let best = Infinity;
    let prev = {x:A.x,y:A.y};
    const steps = 18;
    for(let i=1;i<=steps;i++){
      const t = i/steps;
      const qx = (1-t)*(1-t)*A.x + 2*(1-t)*t*C.x + t*t*B.x;
      const qy = (1-t)*(1-t)*A.y + 2*(1-t)*t*C.y + t*t*B.y;
      const d = distPointToSegment(x,y, prev.x,prev.y, qx,qy);
      best = Math.min(best, d);
      prev = {x:qx,y:qy};
    }
    return best;
  }

  function selectMarker(m){
    if(!m){
      selectedMarkerId = null;
      selectedMarkerName.textContent = "-";
      ytTitle.value = "";
      ytDesc.value = "";
      ytUrl.value = "";
      return;
    }
    selectedMarkerId = m.id;
    selectedMarkerName.textContent = m.name || `마커 ${m.num || ""}`.trim() || "-";

    ytTitle.value = m.ytTitle || "";
    ytDesc.value = m.ytDesc || "";
    ytUrl.value = m.ytUrl || "";
  }

  function openMarkerEdit(m, anchorEl){
    if(!state.ui.markerEditEnabled) return;
    if(!m) return;
    // populate
    const mc = getMarkerCat(m.markerCatId);
    editBadge.textContent = `${mc.name} · #${m.num || 1}`;
    editName.value = m.name || "";
    buildEditCatOptions(m.markerCatId);
    editYtTitle.value = m.ytTitle || "";
    editYtUrl.value = m.ytUrl || "";
    editSize.value = clamp(Math.round(m.size || mc.baseSize || 26), 1, 100);

    // ensure textScale
    if(!(typeof m.textScale==="number") || m.textScale<=0){
      m.textScale = (m.textSize && m.size) ? (m.textSize/m.size) : 0.45;
    }
    if(!m.textSize){
      m.textSize = Math.max(8, Math.round((m.size || mc.baseSize || 26) * m.textScale));
    }
    editTextSize.value = Math.round(m.textSize);

    editWeight.value = String(m.textWeight || 800);
    editTextColor.value = m.labelColor || "#e7eef8";

    // show near right panel header (no center)
    const anchor = anchorEl || $("#rightPanel");
    showFlyoutNear(anchor, flyMarkerEdit, "top");
    setTimeout(()=>editName.focus(), 0);
  }

  function buildEditCatOptions(selectedId){
    editCat.innerHTML = "";
    for(const mc of state.markerCats){
      const opt = document.createElement("option");
      opt.value = mc.id;
      opt.textContent = mc.name;
      editCat.appendChild(opt);
    }
    editCat.value = selectedId || "mcat_all";
  }

  function ensureSequenceForMarkerCat(page, markerCatId){
    page.activeSeqByCat = page.activeSeqByCat || {};
    if(!page.activeSeqByCat[markerCatId]){
      page.seqCounter = (typeof page.seqCounter==="number") ? page.seqCounter : 0;
      const seqId = "seq_" + (++page.seqCounter) + "_" + uid().slice(0,8);
      page.activeSeqByCat[markerCatId] = { seqId, nextNum: 1 };
    }
    return page.activeSeqByCat[markerCatId];
  }

  function setNewSequence(page, markerCatId){
    page.seqCounter = (typeof page.seqCounter==="number") ? page.seqCounter : 0;
    const seqId = "seq_" + (++page.seqCounter) + "_" + uid().slice(0,8);
    page.activeSeqByCat = page.activeSeqByCat || {};
    page.activeSeqByCat[markerCatId] = { seqId, nextNum: 1 };
  }

  function continueSequenceFromMarker(page, marker){
    page.activeSeqByCat = page.activeSeqByCat || {};
    page.activeSeqByCat[marker.markerCatId] = { seqId: marker.seqId, nextNum: (marker.num || 1) + 1 };
  }

  function addMarkerAt(world, markerCatId){
    const p = curPage();
    const mc = getMarkerCat(markerCatId);
    const seq = ensureSequenceForMarkerCat(p, markerCatId);

    const num = seq.nextNum;
    seq.nextNum += 1;

    const baseSize = mc.baseSize || 26;

    const m = {
      id: uid(),
      x: world.x,
      y: world.y,
      markerCatId,
      seqId: seq.seqId,
      num,
      name: "",

      // visuals
      fill: mc.color || "#7cc4ff",
      size: baseSize,
      textScale: 0.45,
      textSize: Math.max(8, Math.round(baseSize * 0.45)),
      textWeight: 800,
      labelColor: "#e7eef8",

      // yt
      ytTitle: "",
      ytDesc: "",
      ytUrl: "",

      dimmed: false,

      // flags
      ytTitleManual: false
    };

    // connect to previous marker in same seq (highest num-1)
    const prev = p.markers
      .filter(x=>x.markerCatId===markerCatId && x.seqId===seq.seqId && (x.num||0)===num-1)
      .sort((a,b)=>(b.num||0)-(a.num||0))[0];

    p.markers.push(m);

    if(prev){
      p.edges.push({
        id: uid(),
        from: prev.id,
        to: m.id,
        ctrl: null
      });
    }

    selectMarker(m);
    saveLocal();
    draw();
  }

  function removeMarker(markerId){
    const p = curPage();
    const idx = p.markers.findIndex(m=>m.id===markerId);
    if(idx<0) return;
    p.markers.splice(idx,1);

    // remove edges connected
    p.edges = (p.edges||[]).filter(e=>e.from!==markerId && e.to!==markerId);

    if(selectedMarkerId === markerId){
      selectMarker(null);
    }
  }

  function clearAllMarkersOnPage(){
    const p = curPage();
    p.markers = [];
    p.edges = [];
    p.activeSeqByCat = {};
    p.seqCounter = 0;
    selectedMarkerId = null;
    selectMarker(null);
  }

  function toggleDimMarker(marker){
    marker.dimmed = !marker.dimmed;
  }

  function setMarkerCategory(marker, newCatId){
    const old = marker.markerCatId;
    marker.markerCatId = newCatId;
    const mc = getMarkerCat(newCatId);
    marker.fill = mc.color || marker.fill;
    marker.size = mc.baseSize || marker.size;
    marker.textSize = Math.max(8, Math.round(marker.size * (marker.textScale || 0.45)));
    // also assign sequence for that category
    const p = curPage();
    const seq = ensureSequenceForMarkerCat(p, newCatId);
    marker.seqId = seq.seqId;
    // keep number (but may collide; allowed; numbering is per seq flow)
  }

  /* ===== Pointer handling (pan/zoom, marker drag, edge drag, right click add) ===== */
  function getCanvasPoint(ev){
    const r = canvas.getBoundingClientRect();
    return { x: ev.clientX - r.left, y: ev.clientY - r.top };
  }

  canvas.addEventListener("contextmenu", (e)=> e.preventDefault());

  canvas.addEventListener("pointerdown", (e)=>{
    if(!ensureAuth()) return;
    pointerDown = true;
    pointerId = e.pointerId;
    canvas.setPointerCapture(pointerId);

    const pt = getCanvasPoint(e);
    startPt = {x:pt.x,y:pt.y};
    startView = { tx:view.tx, ty:view.ty, scale:view.scale };

    const m = findMarkerAtScreen(pt.x, pt.y);
    const edge = (!m) ? hitEdgeAtScreen(pt.x, pt.y) : null;

    draggingCanvas = false;
    draggingMarker = false;
    draggingEdge = false;
    dragEdgeId = null;

    // Right click -> add marker
    if(e.button === 2){
      const w = screenToWorld(pt);
      addMarkerAt(w, state.ui.currentMarkerCatId || "mcat_all");
      return;
    }

    // Left click
    if(m){
      // single click toggles dim
      // but if dragging, we'll move marker
      selectMarker(m);

      // prepare marker drag
      draggingMarker = true;
      canvas.classList.add("dragging");
      return;
    }

    if(edge){
      // drag edge to curve (set control point)
      draggingEdge = true;
      dragEdgeId = edge.id;
      canvas.classList.add("dragging");
      return;
    }

    // else pan canvas
    draggingCanvas = true;
    canvas.classList.add("dragging");
  });

  canvas.addEventListener("pointermove", (e)=>{
    if(!pointerDown || e.pointerId !== pointerId) return;
    const pt = getCanvasPoint(e);
    const dx = pt.x - startPt.x;
    const dy = pt.y - startPt.y;

    if(draggingCanvas){
      view.tx = startView.tx + dx;
      view.ty = startView.ty + dy;
      draw();
      return;
    }

    if(draggingMarker && selectedMarkerId){
      const p = curPage();
      const m = p.markers.find(x=>x.id===selectedMarkerId);
      if(m){
        const w = screenToWorld(pt);
        m.x = w.x;
        m.y = w.y;
        draw();
      }
      return;
    }

    if(draggingEdge && dragEdgeId){
      const p = curPage();
      const edge = p.edges.find(x=>x.id===dragEdgeId);
      if(edge){
        edge.ctrl = screenToWorld(pt);
        draw();
      }
      return;
    }
  });

  canvas.addEventListener("pointerup", (e)=>{
    if(e.pointerId !== pointerId) return;

    const pt = getCanvasPoint(e);
    const moved = Math.hypot(pt.x - startPt.x, pt.y - startPt.y) > 4;

    // marker click dim toggle only if not moved and left button
    if(e.button === 0 && !moved){
      const m = findMarkerAtScreen(pt.x, pt.y);
      if(m){
        // toggle dim
        toggleDimMarker(m);

        // double click to open edit
        const t = now();
        if(t - lastTapTime < 350){
          openMarkerEdit(m, $("#rightPanel"));
        }
        lastTapTime = t;

        saveLocal();
      }else{
        // click empty -> deselect
        selectMarker(null);
      }
    }

    // finish
    pointerDown = false;
    draggingCanvas = false;
    draggingMarker = false;
    draggingEdge = false;
    dragEdgeId = null;
    canvas.classList.remove("dragging");
    saveLocal();
    draw();
  });

  canvas.addEventListener("wheel", (e)=>{
    if(!ensureAuth()) return;
    e.preventDefault();
    const pt = getCanvasPoint(e);
    const wBefore = screenToWorld(pt);
    const delta = -Math.sign(e.deltaY);
    const factor = delta > 0 ? 1.08 : 0.92;
    const newScale = clamp(view.scale * factor, 0.05, 10);
    view.scale = newScale;
    const wAfter = screenToWorld(pt);

    // keep pointer position stable
    view.tx += (wAfter.x - wBefore.x) * view.scale;
    view.ty += (wAfter.y - wBefore.y) * view.scale;
    draw();
  }, {passive:false});

  /* ===== Buttons / Actions ===== */
  btnExport.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    downloadJson("state.json", state);
  });

  btnResetAll.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const ok = confirm("전체 초기화를 하시겠습니까? (모든 데이터가 초기화됩니다)");
    if(!ok) return;
    state = defaultState();
    saveLocal();
    clearAuth(); // optional: require login again
    renderAll();
    loadMapImageForCurrentPage(true);
  });

  btnAuth.addEventListener("click", ()=>{
    if(isAuthed()){
      // keep simple: allow logout
      const ok = confirm("로그아웃할까요?");
      if(ok){
        clearAuth();
        renderAuthButton();
      }
      return;
    }
    ensureAuth();
    renderAuthButton();
  });

  function renderAuthButton(){
    btnAuth.textContent = isAuthed() ? "관리자 인증됨" : "관리자 로그인";
  }

  btnAddPage.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    togglePageAddInline(pageAddInline.style.display==="none");
  });

  btnAddPageCancel.addEventListener("click", ()=> togglePageAddInline(false));

  btnAddPageConfirm.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const name = (newPageName.value || "").trim() || "새 페이지";
    const url  = (newPageUrl.value || "").trim();
    const map  = (newPageMap.value || "").trim();

    const cat = curTopCat();
    const page = {
      id: uid(),
      name,
      url,
      mapImageUrl: map,
      markers: [],
      edges: [],
      showLines: true,
      activeSeqByCat: {},
      seqCounter: 0
    };

    cat.pages.push(page);
    cat.selectedPageId = page.id;
    togglePageAddInline(false);
    saveLocal();
    renderAll();
    loadMapImageForCurrentPage(true);
  });

  btnToggleGoogle.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    state.features.googleLoginEnabled = !state.features.googleLoginEnabled;
    saveLocal();
    renderFeatureToggles();
  });

  btnTogglePayment.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    state.features.paymentEnabled = !state.features.paymentEnabled;
    saveLocal();
    renderFeatureToggles();
  });

  /* Right tools */
  btnHideLines.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    p.showLines = false;
    saveLocal();
    draw();
  });

  btnShowLines.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    p.showLines = true;
    saveLocal();
    draw();
  });

  btnClearMarkers.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const ok = confirm("초기화를 하시겠습니까? (현재 페이지의 모든 마커가 사라집니다)");
    if(!ok) return;
    clearAllMarkersOnPage();
    saveLocal();
    renderAll();
    draw();
  });

  btnToggleHideNumbers.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const mc = curMarkerCat();
    mc.hideNumbers = !mc.hideNumbers;
    saveLocal();
    renderAll();
    draw();
  });

  btnToggleMarkerEdit.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    state.ui.markerEditEnabled = !state.ui.markerEditEnabled;
    saveLocal();
    renderAll();
  });

  btnSaveYt.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    m.ytTitle = (ytTitle.value || "").trim();
    m.ytDesc  = (ytDesc.value || "").trim();
    m.ytUrl   = (ytUrl.value || "").trim();
    saveLocal();
    draw();
  });

  btnClearYt.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    ytTitle.value = "";
    ytDesc.value = "";
    ytUrl.value = "";
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    m.ytTitle = "";
    m.ytDesc = "";
    m.ytUrl = "";
    saveLocal();
    draw();
  });

  /* Logo flyout */
  logoBtn.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    logoUrlInput.value = state.logoUrl || "";
    showFlyoutNear(logoBtn, flyLogo, "bottom");
  });

  btnLogoApply.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    state.logoUrl = (logoUrlInput.value || "").trim();
    saveLocal();
    applyLogo();
    hideFlyout(flyLogo);
  });

  /* Marker category editor flyout */
  btnEditMarkerCats.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    // default selected cat in editor is current
    showFlyoutNear(btnEditMarkerCats, flyMarkerCats, "bottom");
    renderMarkerCatEditor();
  });

  btnAddMarkerCat.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    markerCatAddInline.style.display = (markerCatAddInline.style.display==="none") ? "block" : "none";
    if(markerCatAddInline.style.display!=="none"){
      newMarkerCatName.value = "";
      setTimeout(()=>newMarkerCatName.focus(), 0);
    }
  });
  btnAddMarkerCatCancel.addEventListener("click", ()=> markerCatAddInline.style.display="none");
  btnAddMarkerCatConfirm.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const name = (newMarkerCatName.value || "").trim() || "새 카테고리";
    addMarkerCat(name);
    markerCatAddInline.style.display="none";
    saveLocal();
    renderAll();
    renderMarkerCatEditor();
  });

  btnApplyColorToSelectedCat.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const col = parseColor(colorInput.value);
    if(!col){
      alert("색상 형식이 올바르지 않습니다. 예: #ffffff 또는 rgb(255,255,255)");
      return;
    }
    applyMarkerCatColor(state.ui.currentMarkerCatId, col);
    saveLocal();
    renderAll();
    renderMarkerCatEditor();
    draw();
  });

  /* Marker edit flyout actions */
  btnDeleteMarker.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    const ok = confirm("마커를 삭제할까요?");
    if(!ok) return;
    removeMarker(m.id);
    saveLocal();
    hideFlyout(flyMarkerEdit);
    renderAll();
    draw();
  });

  editName.addEventListener("input", ()=>{
    // mirror to yt title if user hasn't manually edited it in edit dialog yet
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    const name = (editName.value || "").toString();
    if(!m.ytTitleManual && (!editYtTitle.value || editYtTitle.value === m.ytTitle || editYtTitle.value === "")){
      editYtTitle.value = name;
    }
  });

  editYtTitle.addEventListener("input", ()=>{
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    m.ytTitleManual = true;
  });

  editSize.addEventListener("input", ()=>{
    const n = clamp(Number(editSize.value || 1), 1, 100);
    editSize.value = n;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;

    const ts = (typeof m.textScale==="number" && m.textScale>0) ? m.textScale : (m.textSize && m.size ? (m.textSize/m.size) : 0.45);
    m.size = n;
    m.textScale = ts;
    m.textSize = Math.max(8, Math.round(m.size * m.textScale));
    editTextSize.value = Math.round(m.textSize);
    draw();
  });

  editTextSize.addEventListener("input", ()=>{
    const n = clamp(Number(editTextSize.value || 8), 1, 200);
    editTextSize.value = n;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;

    const size = clamp(Number(editSize.value || m.size || 1), 1, 100);
    m.textSize = n;
    m.textScale = Math.max(0.1, n / size);
    draw();
  });

  btnNewSequence.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    setNewSequence(p, m.markerCatId);
    saveLocal();
  });

  btnContinueFromHere.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;
    continueSequenceFromMarker(p, m);
    saveLocal();
  });

  btnSaveMarker.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    const p = curPage();
    const m = p.markers.find(x=>x.id===selectedMarkerId);
    if(!m) return;

    m.name = (editName.value || "").trim();

    const catId = editCat.value || m.markerCatId;
    if(catId !== m.markerCatId){
      setMarkerCategory(m, catId);
    }

    m.ytTitle = (editYtTitle.value || "").trim();
    m.ytUrl = (editYtUrl.value || "").trim();

    const size = clamp(Number(editSize.value || m.size || 26), 1, 100);
    const textSize = clamp(Number(editTextSize.value || m.textSize || 12), 1, 200);
    m.size = size;
    m.textSize = textSize;
    m.textScale = Math.max(0.1, m.textSize / m.size);

    m.textWeight = Number(editWeight.value || 800);
    const tc = parseColor(editTextColor.value) || "#e7eef8";
    m.labelColor = tc;

    // keep category consistency: color + base size follow category 1 marker rule
    const mc = getMarkerCat(m.markerCatId);
    m.fill = mc.color || m.fill;

    // enforce category base size if required by category rule (always consistent)
    m.size = mc.baseSize || m.size;
    m.textSize = Math.max(8, Math.round(m.size * (m.textScale || 0.45)));

    saveLocal();
    hideFlyout(flyMarkerEdit);
    renderAll();
    draw();
  });

  // Enter key: save + close marker edit
  flyMarkerEdit.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      btnSaveMarker.click();
    }
  });

  /* ===== Palettes ===== */
  function renderPalette(el, onPick){
    el.innerHTML = "";
    QUICK.forEach(q=>{
      const s = document.createElement("div");
      s.className = "swatch";
      s.title = q.name + " " + q.c;
      s.style.background = q.c;
      s.addEventListener("click", ()=>{
        if(!ensureAuth()) return;
        onPick(q.c);
      });
      el.appendChild(s);
    });
  }

  renderPalette(quickPalette, (color)=>{
    // apply to selected marker category and selected marker if any
    const mcid = state.ui.currentMarkerCatId || "mcat_all";
    applyMarkerCatColor(mcid, color);
    saveLocal();
    renderAll();
    draw();
  });

  renderPalette(editPalette, (color)=>{
    colorInput.value = color;
    applyMarkerCatColor(state.ui.currentMarkerCatId, color);
    saveLocal();
    renderAll();
    renderMarkerCatEditor();
    draw();
  });

  renderPalette(editTextPalette, (color)=>{
    editTextColor.value = color;
  });

  /* ===== Marker edit toggle / double click ===== */
  btnToggleMarkerEdit.addEventListener("dblclick", (e)=>{
    // no extra behavior
    e.preventDefault();
  });

  // open marker edit via button
  btnToggleMarkerEdit.addEventListener("contextmenu", (e)=> e.preventDefault());

  // explicit "마커 편집" button in tools: if a marker selected, open editor
  btnToggleMarkerEdit.addEventListener("click", ()=>{
    if(!ensureAuth()) return;
    // already toggled in earlier listener — we need separate behavior? (requirement: button exists)
    // Keep: single click toggles edit mode ON/OFF. If ON and marker selected, open editor on next click/dblclick.
  });

  // Right panel "마커 편집" is toggle, but also requirement says "마커 편집 버튼(마우스 더블클릭 시 나오는 마커 편집 창 실행)"
  // Double click on marker already opens.
  // Additionally, when marker selected and edit mode is ON, single click on marker won't open editor (because it toggles dim). That's fine; double click opens.

  /* ===== Selected marker -> sync right panel youtube fields ===== */
  ["input","change"].forEach(evt=>{
    ytTitle.addEventListener(evt, ()=>{ /* kept live */ });
    ytDesc.addEventListener(evt, ()=>{ /* kept live */ });
    ytUrl.addEventListener(evt, ()=>{ /* kept live */ });
  });

  /* ===== Flyout background click close (optional) ===== */
  document.addEventListener("click", (e)=>{
    // don't close if clicking inside flyouts
    const inFly = e.target.closest?.(".flyout");
    const inLogoBtn = e.target.closest?.("#logoBtn");
    const inMarkerCatBtn = e.target.closest?.("#btnEditMarkerCats");
    if(inFly || inLogoBtn || inMarkerCatBtn) return;
  });

  /* ===== Init / render ===== */
  async function init(){
    // try local first, then remote, else default
    const local = loadFromLocal();
    if(local){
      state = local;
    }else{
      const remote = await loadFromRemote();
      state = remote || defaultState();
    }
    if(!state) state = defaultState();

    ensureAllStructures();

    // initial selected page defaults
    for(const cat of state.topCats){
      if(!cat.selectedPageId && cat.pages[0]) cat.selectedPageId = cat.pages[0].id;
      if(!cat.selectedPageId && cat.pages.length) cat.selectedPageId = cat.pages[0].id;
    }
    if(!state.ui.currentTopCatId) state.ui.currentTopCatId = state.topCats[0]?.id;
    if(!state.ui.currentMarkerCatId) state.ui.currentMarkerCatId = state.markerCats[0]?.id;

    // ensure '전체' cat exists at index 0
    const idxAll = state.markerCats.findIndex(x=>x.id==="mcat_all");
    if(idxAll<0){
      state.markerCats.unshift({
        id:"mcat_all", name:"전체", color:"#7cc4ff", baseSize:26, enabled:true, hideNumbers:false, deletable:false
      });
    }else{
      // keep it not deletable
      state.markerCats[idxAll].deletable = false;
    }

    // apply logo
    applyLogo();
    renderAuthButton();

    // canvas
    resizeCanvas();
    loadMapImageForCurrentPage(true);
    fitToImage();

    // render
    renderAll();

    // initial draw
    draw();
  }

  function renderAll(){
    ensureAllStructures();
    renderTopCats();
    renderPages();
    renderFeatureToggles();
    renderMarkerCatToggles();

    // update logo
    applyLogo();

    // update marker edit option list
    buildEditCatOptions(state.ui.currentMarkerCatId);

    // keep selection valid
    const p = curPage();
    if(selectedMarkerId && !(p.markers||[]).some(m=>m.id===selectedMarkerId)){
      selectMarker(null);
    }else if(selectedMarkerId){
      const m = p.markers.find(x=>x.id===selectedMarkerId);
      if(m) selectMarker(m);
    }

    // reflect current marker cat in badge
    const mc = curMarkerCat();
    // and refresh editor flyout if open
    if(flyMarkerCats.style.display !== "none"){
      renderMarkerCatEditor();
    }

    // if page changed, load image
    // (We compare by cached page id)
    ensurePageImageCurrent();
  }

  let lastPageId = null;
  function ensurePageImageCurrent(){
    const pid = curPage()?.id || null;
    if(pid !== lastPageId){
      lastPageId = pid;
      loadMapImageForCurrentPage(true);
      fitToImage();
      draw();
    }
  }

  /* ===== Extra: open marker edit from selection if flyout open ===== */
  rightPanelMarkerEditShortcut();
  function rightPanelMarkerEditShortcut(){
    // If user clicks the "선택한 마커" field and marker exists, open editor
    selectedMarkerName.addEventListener("click", ()=>{
      if(!ensureAuth()) return;
      const p = curPage();
      const m = p.markers.find(x=>x.id===selectedMarkerId);
      if(!m) return;
      openMarkerEdit(m, $("#rightPanel"));
    });
  }

  /* ===== Flyout close buttons ===== */
  document.addEventListener("click", (e)=>{
    const t = e.target;
    if(t && t.matches && t.matches('[data-close="flyLogo"]')) hideFlyout(flyLogo);
    if(t && t.matches && t.matches('[data-close="flyMarkerCats"]')) hideFlyout(flyMarkerCats);
    if(t && t.matches && t.matches('[data-close="flyMarkerEdit"]')) hideFlyout(flyMarkerEdit);
  });

  /* ===== Edit palette apply to selected cat ===== */
  renderPalette(editPalette, (color)=>{
    colorInput.value = color;
    applyMarkerCatColor(state.ui.currentMarkerCatId, color);
    saveLocal();
    renderAll();
    renderMarkerCatEditor();
    draw();
  });

  /* ===== Edge control drag: no extra handles; drag edge directly ===== */

  /* ===== Double click detection fallback (mouse) ===== */
  canvas.addEventListener("dblclick", (e)=>{
    if(!ensureAuth()) return;
    const pt = getCanvasPoint(e);
    const m = findMarkerAtScreen(pt.x, pt.y);
    if(m){
      selectMarker(m);
      openMarkerEdit(m, $("#rightPanel"));
    }
  });

  /* ===== Quick: focus safety for mobile ===== */
  canvas.addEventListener("touchstart", ()=>{}, {passive:true});

  /* ===== Start ===== */
  init();

})();
</script>
</body>
</html>
