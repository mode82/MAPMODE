<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAPMODE · ADMIN99</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;

      --stroke:#1f2a3a;
      --stroke2:#27344a;

      --text:#e7eef8;
      --muted:#9fb0c6;

      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      --topH:58px;
      --sideW:320px;
      --sideW2:360px;

      /* ✅ [ADD] 상단 슬롯 폭 */
      --topSlotW:170px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; overflow:hidden;
      background:
        radial-gradient(1200px 700px at 50% -10%, rgba(124,196,255,.18), transparent 55%),
        radial-gradient(900px 650px at 88% 10%, rgba(57,217,138,.12), transparent 55%),
        radial-gradient(900px 650px at 12% 10%, rgba(255,214,10,.08), transparent 55%),
        linear-gradient(180deg, #0a0f18 0%, var(--bg) 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, sans-serif;
      font-weight: 800;
      letter-spacing: .1px;
    }

    /* ========== TOPBAR ========== */
    .topbar{
      position:fixed; inset:0 0 auto 0; height:var(--topH);
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 14px; z-index:90;
      background: linear-gradient(180deg, rgba(9,14,23,.88), rgba(9,14,23,.58));
      backdrop-filter: blur(var(--blur));
      border-bottom:1px solid rgba(39,52,74,.65);
    }
    .top-left, .top-right{ display:flex; align-items:center; gap:10px; min-width:0; }

    .slot{
      height:38px; display:flex; align-items:center; padding:0 10px;
      border-radius:999px; background: rgba(14,22,38,.55);
      border:1px solid rgba(39,52,74,.65);
      box-shadow: var(--shadow2);
      gap:8px; white-space:nowrap;
    }
    .slot.fixed{ width:var(--topSlotW); justify-content:center; }
    .slot.logo{ justify-content:flex-start; border:none; background: transparent; box-shadow:none; padding:0; width:var(--topSlotW); }

    .logoBox{
      width:var(--topSlotW); height:38px; border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; background: transparent; border:none;
      cursor:pointer; user-select:none;
    }
    .logoBox img{ height:26px; width:auto; display:block; opacity:.98; }

    .brand{ display:flex; align-items:center; gap:10px; font-weight:900; letter-spacing:.5px; }
    .brand .word{ font-size:20px; line-height:1; display:flex; align-items:center; }
    .brand .word .o{
      display:inline-block; width:12px; height:12px; border-radius:999px; margin:0 2px;
      background:#fff; box-shadow: 0 0 0 2px rgba(255,255,255,.12);
      transform: translateY(1px);
    }

    .pill{
      height:34px; display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:0 12px; border-radius:999px;
      background: rgba(14,22,38,.55);
      border:1px solid rgba(39,52,74,.65);
      color:var(--text);
      box-shadow: var(--shadow2);
      cursor:pointer; user-select:none; text-decoration:none;
      font-weight:900;
    }
    .pill:hover{ border-color: rgba(124,196,255,.55); }
    .pill:active{ transform: translateY(1px); }
    .pill.small{ height:32px; padding:0 10px; font-size:13px; font-weight:900; }
    .pill.ghost{ background: rgba(14,22,38,.25); }
    .pill.danger{ border-color: rgba(255,93,93,.55); }
    .pill.ok{ border-color: rgba(57,217,138,.55); }

    /* ✅ 게임 슬롯(단일) */
    .gameSlot{
      width:100%; height:38px;
      display:flex; align-items:center; justify-content:center; gap:8px;
      border-radius:999px;
      background: rgba(14,22,38,.35);
      border:1px solid rgba(39,52,74,.65);
      box-shadow: var(--shadow2);
      cursor:pointer; user-select:none;
      font-weight:900; font-size:14px;
      padding:0 12px;
    }
    .gameSlot:hover{ border-color: rgba(124,196,255,.55); }
    .gameSlot.active{
      border-color: rgba(124,196,255,.55);
      background: rgba(124,196,255,.08);
      box-shadow: var(--shadow2);
    }
    .gameSlot.static{ cursor:default; opacity:.78; pointer-events:none; }

    /* ✅ 상단 4슬롯: 활성/비활성 체크 버튼 */
    .gameSlot.gameItem{ justify-content:space-between; padding:0 10px; gap:10px; min-width:0; }
    .gameSlot.gameItem .gNm{
      flex:1 1 auto; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:900;
    }
    /* ✅ FIX: 카테고리1 텍스트는 ... 금지(자동 폰트 맞춤) */
    #gSlot1 .gNm{ text-overflow:clip; }

    .gEnBtn{
      flex:0 0 auto; width:34px; height:34px; border-radius:999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.92);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      font-weight:900; font-size:14px;
      padding:0; user-select:none;
    }
    .gEnBtn.off{ opacity:.75; border-color: rgba(255,93,93,.45); }
    .gameSlot.gameItem.off{ opacity:.62; }

    /* ✅ 게임 드롭다운 */
    .gameDropWrap{
      position:fixed; left:14px; top:calc(var(--topH) + 8px);
      width:calc(var(--topSlotW) + 20px);
      z-index:120; display:none;
    }
    .gameDropWrap.show{ display:block; }
    .gameDrop{
      width:100%;
      background: linear-gradient(180deg, rgba(14,22,38,.96), rgba(10,15,24,.92));
      border:1px solid rgba(39,52,74,.75);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(var(--blur));
    }
    .gameDropHead{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(39,52,74,.55);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .gameDropHead .t{ font-weight:900; font-size:13px; color:rgba(231,238,248,.92); }
    .gameDropList{ padding:10px; display:flex; flex-direction:column; gap:8px; }
    .gRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 10px;
      border-radius:16px;
      border:1px solid rgba(39,52,74,.6);
      background: rgba(14,22,38,.35);
      cursor:pointer;
      min-width:0;
    }
    .gRow.active{
      outline:2px solid rgba(124,196,255,.25);
      border-color: rgba(124,196,255,.45);
      background: rgba(14,22,38,.55);
    }
    .gRow.off{ opacity:.65; }
    .gRow .nm{
      font-weight:900; font-size:14px;
      flex:1 1 auto; min-width:0;
      white-space:nowrap;
      overflow:visible;
      text-overflow:clip;
    }
    .gRow .acts{ display:flex; gap:8px; flex:0 0 auto; }
    .miniBtn{
      height:34px; padding:0 12px; border-radius:999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.92);
      cursor:pointer;
      font-weight:900; font-size:13px;
      display:flex; align-items:center; justify-content:center;
    }
    .miniBtn.icon{ width:34px; padding:0; }
    .miniBtn.url{ border-color: rgba(57,217,138,.55); }
    .miniBtn.edit{ border-color: rgba(124,196,255,.55); }
    .miniBtn.del{ border-color: rgba(255,93,93,.55); }
    .miniBtn.en{ border-color: rgba(255,214,10,.55); }

    .top-right{ flex-wrap:wrap; justify-content:flex-end; }
    .top-right .pill{ flex: 0 0 auto; }

    /* ========== LAYOUT ========== */
    .layout{
      position:fixed; inset:var(--topH) 0 0 0;
      display:grid;
      grid-template-columns: var(--sideW) 1fr var(--sideW2);
      height:calc(100% - var(--topH));
      min-height: 0;
    }
    .side{
      overflow:hidden;
      border-right:1px solid rgba(39,52,74,.55);
      background: rgba(8,12,20,.35);
      backdrop-filter: blur(var(--blur));
      min-height:0;
    }
    .side.right{ border-right:none; border-left:1px solid rgba(39,52,74,.55); }
    .sideInner{ height:100%; padding:12px; overflow:auto; }

    .card{
      background: rgba(14,22,38,.50);
      border:1px solid rgba(39,52,74,.6);
      border-radius: var(--r16);
      padding:12px;
      box-shadow: var(--shadow2);
    }
    .card + .card{ margin-top:12px; }
    .sectionTitle{
      font-size:12px; color: rgba(231,238,248,.9);
      margin:4px 0 10px 0;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .sectionTitle b{ font-weight:900; }
    .subtle{ color: rgba(159,176,198,.92); font-size:12px; line-height:1.45; font-weight:800; }

    /* ========== LEFT: Pages ========== */
    .btnAddPage{
      width:100%; height:52px;
      border-radius:18px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(14,22,38,.35);
      color: rgba(231,238,248,.95);
      font-weight:900;
      cursor:pointer;
      box-shadow: var(--shadow2);
    }
    .btnAddPage:hover{ border-color: rgba(124,196,255,.55); }
    .pageList{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .pageItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 10px;
      border-radius: var(--r16);
      border:1px solid rgba(39,52,74,.6);
      background: rgba(14,22,38,.35);
      cursor:pointer;
    }
    .pageItem.active{
      outline:2px solid rgba(57,217,138,.35);
      border-color: rgba(57,217,138,.55);
      background: rgba(14,22,38,.55);
    }
    .pageName{ font-weight:900; font-size:16px; }
    .pageActions{ display:flex; align-items:center; gap:8px; flex:0 0 auto; }

    /* ========== CENTER: Canvas ========== */
    .center{
      position:relative; overflow:hidden;
      background:
        radial-gradient(900px 700px at 50% 15%, rgba(124,196,255,.08), transparent 60%),
        radial-gradient(900px 700px at 50% 80%, rgba(57,217,138,.05), transparent 60%);
      min-height:0;
    }
    .canvasWrap{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; padding:16px; }
    canvas{ background: transparent; touch-action:none; }
    .hintToast{
      position:absolute; left:50%; transform: translateX(-50%);
      top:14px; padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.6);
      background: rgba(14,22,38,.55);
      color: rgba(231,238,248,.9);
      box-shadow: var(--shadow2);
      font-size:12px;
      display:none;
      z-index:40;
    }
    .hintToast.show{ display:block; }

    /* ========== RIGHT: Tools ========== */
    .chipRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .chip{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.6);
      background: rgba(10,15,24,.35);
      cursor:pointer;
      font-size:13px;
      user-select:none;
      font-weight:900;
    }
    .chip.on{ border-color: rgba(124,196,255,.6); background: rgba(124,196,255,.10); }
    .dotc{ width:10px; height:10px; border-radius:999px; box-shadow:0 0 0 2px rgba(255,255,255,.06); }
    .hr{ height:1px; background: rgba(39,52,74,.55); margin:12px 0; }
    .btnFull{ width:100%; height:52px; border-radius:18px; font-weight:900; font-size:15px; justify-content:center; }

    .palette{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:10px; }
    .sw{
      width:42px; height:42px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.65);
      box-shadow: var(--shadow2);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      position:relative; overflow:hidden;
      background: rgba(10,15,24,.35);
    }
    .sw::after{ content:""; position:absolute; inset:6px; border-radius:10px; background: var(--c); }
    .swLabel{ margin-top:6px; font-size:12px; text-align:center; color: rgba(231,238,248,.85); font-weight:900; }
    .swWrap{ display:flex; flex-direction:column; align-items:center; }
    .row2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
    .field{
      width:100%;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.95);
      outline:none;
      font-weight:900;
      font-size:14px;
    }
    textarea.field{ min-height:90px; resize:vertical; }
    .selectedBox .label{ font-size:14px; font-weight:900; margin-bottom:8px; }
    .selectedBox .sub{ font-size:12px; color: rgba(159,176,198,.92); font-weight:900; margin-top:10px; }

    /* ========== MODAL ========== */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:stretch; justify-content:stretch;
      z-index:200;
    }
    .modalBack.show{ display:flex; }
    .modal{
      margin:auto;
      width:min(1050px, calc(100vw - 28px));
      height:min(860px, calc(100vh - 28px));
      background: linear-gradient(180deg, rgba(14,22,38,.96), rgba(10,15,24,.92));
      border:1px solid rgba(39,52,74,.75);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHead{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid rgba(39,52,74,.55);
    }
    .modalHead .title{ font-size:18px; font-weight:900; }
    .modalBody{ padding:16px; overflow:auto; flex:1 1 auto; }
    .modalClose{
      height:40px; padding:0 14px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.92);
      cursor:pointer;
      font-weight:900;
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    .labelRow{ color: rgba(159,176,198,.92); font-size:13px; font-weight:900; margin:10px 0 8px; }
    .checkRow{ display:flex; align-items:center; gap:10px; justify-content:flex-end; }
    .checkRow input{ width:18px; height:18px; accent-color:#a86bff; }
    .colorChip{
      width:46px; height:46px;
      border-radius:16px;
      border:1px solid rgba(39,52,74,.65);
      box-shadow: var(--shadow2);
      background: rgba(10,15,24,.35);
      position:relative; overflow:hidden;
    }
    .colorChip::after{ content:""; position:absolute; inset:7px; border-radius:12px; background: var(--c); }

    .styleGrid{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; margin-top:14px; }
    .styleCard{
      border-radius:18px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      padding:14px;
      min-height:160px;
    }
    .styleCard h4{ margin:0 0 10px; font-size:18px; font-weight:900; }
    .rangeRow{ display:flex; align-items:center; gap:12px; }
    .rangeRow input[type="range"]{ width:100%; }
    .numBox{
      width:68px; text-align:center;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      padding:8px 10px;
      font-weight:900;
    }
    .fwSelect{ width:100%; }
    .quickTextColors{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .tSw{
      width:34px; height:34px; border-radius:12px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      box-shadow: var(--shadow2);
      cursor:pointer;
      position:relative; overflow:hidden;
    }
    .tSw::after{ content:""; position:absolute; inset:7px; border-radius:9px; background: var(--c); }

    .modalFoot{
      padding:14px 16px;
      border-top:1px solid rgba(39,52,74,.55);
      display:flex; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
    }
    .btnBig{
      height:46px; padding:0 16px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.95);
      font-weight:900;
      cursor:pointer;
    }
    .btnBig.danger{ border-color: rgba(255,93,93,.65); }
    .btnBig.ok{ border-color: rgba(57,217,138,.65); }

    /* 마커 폰트 */
    .markerFont{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 900;
      letter-spacing: 0;
    }

    /* ========== LOGIN OVERLAY ========== */
    .lock{
      position:fixed; inset:0;
      background: rgba(0,0,0,.65);
      backdrop-filter: blur(8px);
      display:none;
      align-items:center; justify-content:center;
      z-index:300;
    }
    .lock.show{ display:flex; }
    .lockBox{
      width:min(420px, calc(100vw - 28px));
      background: linear-gradient(180deg, rgba(14,22,38,.96), rgba(10,15,24,.92));
      border:1px solid rgba(39,52,74,.75);
      border-radius:22px;
      box-shadow: var(--shadow);
      padding:18px;
    }
    .lockBox h3{ margin:0 0 10px; font-size:18px; font-weight:900; }
    .lockBox p{ margin:0 0 14px; color:rgba(159,176,198,.92); font-size:13px; font-weight:900; }
    .lockRow{ display:flex; gap:10px; }
    .lockRow input{
      flex:1;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(39,52,74,.65);
      background: rgba(10,15,24,.35);
      color: rgba(231,238,248,.95);
      outline:none;
      font-weight:900;
      font-size:14px;
    }

    /* ========== POPUP (prompt/confirm 대체) ========== */
    .popLayer{ position:fixed; inset:0; z-index:260; display:none; }
    .popLayer.show{ display:block; }
    .pop{
      position:absolute;
      width:min(380px, calc(100vw - 28px));
      background: linear-gradient(180deg, rgba(14,22,38,.96), rgba(10,15,24,.92));
      border:1px solid rgba(39,52,74,.75);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(var(--blur));
    }
    .popHead{
      padding:12px 12px 10px;
      border-bottom:1px solid rgba(39,52,74,.55);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .popHead .title{ font-size:13px; font-weight:900; color:rgba(231,238,248,.92); }
    .popBody{ padding:12px; }
    .popBody .msg{
      color: rgba(159,176,198,.92);
      font-size:12px;
      line-height:1.45;
      font-weight:800;
      margin:0 0 10px;
    }
    .popFoot{
      padding:12px;
      border-top:1px solid rgba(39,52,74,.55);
      display:flex; justify-content:flex-end; gap:10px;
      flex-wrap:wrap;
    }
    .popFoot .btnBig{ height:40px; }

    /* ========== responsive ========== */
    @media (max-width: 1200px){
      body{ overflow:auto; }
      .layout{
        width: calc(var(--sideW) + 1000px + var(--sideW2));
        min-width: calc(var(--sideW) + 1000px + var(--sideW2));
      }
      .center{ min-width: 1000px; }
    }
    @media (max-width: 560px){
      :root{ --topSlotW:160px; }
      .slot.fixed{ width:var(--topSlotW); }
      .slot.logo{ width:var(--topSlotW); }
      .logoBox{ width:var(--topSlotW); }
      .gameSlot{ font-size:13px; }
      .gameDropWrap{ width:calc(var(--topSlotW) + 20px); }
    }
  </style>
</head>

<body>
  <!-- LOGIN LOCK -->
  <div class="lock" id="lock">
    <div class="lockBox">
      <h3>관리자 인증</h3>
      <p>비밀번호를 입력하면 <b>24시간</b> 인증이 유지됩니다.</p>
      <div class="lockRow">
        <input id="pw" type="password" placeholder="비밀번호" autocomplete="current-password" />
        <button class="pill ok" id="btnLogin">로그인</button>
      </div>
      <div class="subtle" id="lockMsg" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- ✅ popup layer -->
  <div class="popLayer" id="popLayer" aria-hidden="true">
    <div class="pop" id="pop" role="dialog" aria-modal="true">
      <div class="popHead">
        <div class="title" id="popTitle">입력</div>
        <button class="modalClose" id="popClose" type="button">닫기</button>
      </div>
      <div class="popBody" id="popBody">
        <p class="msg" id="popMsg" style="display:none;"></p>
        <input class="field" id="popInput" placeholder="" />
      </div>
      <div class="popFoot" id="popFoot">
        <button class="btnBig" id="popCancel" type="button">취소</button>
        <button class="btnBig ok" id="popOk" type="button">저장</button>
      </div>
    </div>
  </div>

  <!-- TOPBAR -->
  <div class="topbar" id="topbar">
    <div class="top-left">
      <!-- Logo -->
      <div class="slot fixed logo">
        <div class="logoBox" id="logoBox" title="로고 클릭 → URL 입력">
          <div class="brand"><div class="word">MAPM<span class="o"></span>DE</div></div>
        </div>
      </div>

      <!-- ✅ 상단 4 슬롯(카테고리 1/2/3/4) -->
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot gameItem active" id="gSlot1" title="카테고리1 / 클릭하여 관리">아이온2</div>
      </div>
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot gameItem" id="gSlot2" title="카테고리2 / 클릭하여 관리">추가</div>
      </div>
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot gameItem" id="gSlot3" title="카테고리3 / 클릭하여 관리">추가</div>
      </div>
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot gameItem" id="gSlot4" title="카테고리4 / 클릭하여 관리">추가</div>
      </div>

      <!-- Admin label -->
      <div class="slot fixed">
        <div style="font-weight:900; color:rgba(57,217,138,.95);">ADMIN</div>
      </div>

      <!-- 지도 업로드 / state 내보내기 / 전체 초기화 -->
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <label class="gameSlot" style="cursor:pointer;">
          지도 업로드
          <input id="fileMap" type="file" accept="image/*" style="display:none;" />
        </label>
      </div>
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot" id="btnExport">state 내보내기</div>
      </div>
      <div class="slot fixed" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="gameSlot" id="btnResetAll" style="border-color:rgba(255,93,93,.55);">전체 초기화</div>
      </div>
    </div>

    <div class="top-right">
      <span class="pill small ghost" title="현재 페이지">
        관리자 <span style="opacity:.7;">/</span> <span id="pathGameTop">아이온2</span>
      </span>
    </div>
  </div>

  <!-- ✅ 상단 슬롯 드롭다운 -->
  <div class="gameDropWrap" id="gameDropWrap">
    <div class="gameDrop" id="gameDrop">
      <div class="gameDropHead">
        <div class="t" id="gameDropTitle">목록</div>
        <button class="pill small ghost" id="btnAddGameDrop" type="button">+ 추가</button>
      </div>
      <div class="gameDropList" id="gameDropList"></div>
    </div>
  </div>

  <div class="layout">
    <!-- LEFT -->
    <aside class="side left">
      <div class="sideInner">
        <div class="card">
          <div class="sectionTitle">
            <span>페이지</span>
            <span class="subtle"><b id="pathGame">아이온2</b> / <b id="pathPage">전체지도</b></span>
          </div>
          <button class="btnAddPage" id="btnAddPage">+ 페이지 추가</button>
          <div class="subtle" style="margin-top:10px;">
            • 페이지 버튼 클릭 → 같은 게임 안에서 지도 페이지 이동<br/>
            • 폰/다른 기기에서도 지도 보이게 하려면: 관리자에서 URL 버튼으로 지도 이미지 URL 설정
          </div>
          <div class="pageList" id="pageList"></div>
        </div>
      </div>
    </aside>

    <!-- CENTER -->
    <main class="center">
      <div class="hintToast" id="toast"></div>
      <div class="canvasWrap">
        <canvas id="cv" width="1200" height="900"></canvas>
      </div>
    </main>

    <!-- RIGHT -->
    <aside class="side right">
      <div class="sideInner">
        <!-- 카테고리 -->
        <div class="card">
          <div class="sectionTitle">
            <span>카테고리</span>
            <span class="subtle">필터</span>
          </div>
          <div class="chipRow" id="catChips"></div>
          <div class="subtle" id="kpi" style="margin-top:10px;">표시 중 마커: 0 / 페이지 전체: 0</div>
          <button class="pill btnFull ghost" id="btnEditCats" style="margin-top:10px;">카테고리/색상 편집</button>
        </div>

        <!-- 관리자 툴 -->
        <div class="card">
          <div class="sectionTitle">
            <span>관리자 툴</span>
            <span class="subtle">• 색상 팔레트(카테고리 1번 기준 전파)<br/>• 선은 같은 페이지 마커(번호 순)로 자동 표시</span>
          </div>

          <div class="subtle" style="margin-top:8px;">빠른 색상 (원 색상 오버라이드)</div>
          <div class="palette" id="palette"></div>

          <div class="row2">
            <button class="pill btnFull ghost" id="btnApplyQuick" disabled>선택 마커에 적용</button>
            <button class="pill btnFull ghost" id="btnUseCatColor" disabled>선택 마커 색상(카테고리로)</button>
          </div>

          <div class="hr"></div>

          <div class="row2">
            <button class="pill btnFull danger" id="btnClearLines">선 숨김</button>
            <button class="pill btnFull ghost" id="btnRechain">선 다시 표시</button>
          </div>

          <div class="hr"></div>
          <button class="pill btnFull danger" id="btnResetMarkers" style="border-color:rgba(255,93,93,.65);">마커 초기화</button>

          <div class="hr"></div>

          <div class="selectedBox" style="margin-top:6px;">
            <div class="label">선택한 마커: <span id="selName">(이름 없음)</span></div>

            <div class="sub">유튜브 링크</div>
            <input class="field" id="selLink" placeholder="유튜브" />

            <div class="sub">유튜브 표시명</div>
            <input class="field" id="selYtTitle" placeholder="유튜브 표시명" />

            <div style="margin-top:10px;">
              <button class="pill btnFull ghost" id="btnOpenMarkerEdit" disabled>마커 편집 열기</button>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <!-- MARKER EDIT MODAL -->
  <div class="modalBack" id="mMarker">
    <div class="modal">
      <div class="modalHead">
        <div>
          <div class="title">마커 편집</div>
          <div class="subtle" style="margin-top:6px;">관리자 모드에서만 편집/삭제 가능합니다. (Enter = 저장)</div>
        </div>
        <button class="modalClose" id="btnCloseMarker">닫기</button>
      </div>

      <div class="modalBody">
        <div class="grid2">
          <div>
            <div class="labelRow">이름(마커 이름)</div>
            <input class="field" id="mfName" placeholder="예: 기텔 위치" />
          </div>
          <div>
            <div class="labelRow">카테고리</div>
            <select class="field" id="mfCat"></select>
          </div>
        </div>

        <div class="labelRow" style="margin-top:12px;">마커 원 색상</div>
        <div style="display:flex; align-items:center; gap:12px; justify-content:space-between;">
          <input class="field" id="mfColor" placeholder="개별 오버라이드 색상 (예: #ff0000)" />
          <div style="display:flex; align-items:center; gap:10px;">
            <div class="colorChip" id="mfColorChip" style="--c:#2b8cff;"></div>
            <div class="checkRow">
              <input type="checkbox" id="mfUseCatColor" />
              <label for="mfUseCatColor" class="subtle" style="cursor:pointer;">카테고리 색상 사용</label>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div>
            <div class="labelRow">유튜브 링크(URL)</div>
            <input class="field" id="mfYt" placeholder="https://www.youtube.com/..." />
          </div>
          <div>
            <div class="labelRow">유튜브 표시명(유저모드 제목)</div>
            <input class="field" id="mfYtTitle" placeholder="예: 기텔 1번위치" />
          </div>
        </div>

        <div class="labelRow" style="margin-top:12px;">메모 (관리자 등록)</div>
        <textarea class="field" id="mfMemo" placeholder="관리자 메모를 입력하세요. 유저 모드에서는 읽기 전용입니다."></textarea>

        <div class="hr"></div>

        <div class="labelRow">마커 스타일</div>
        <div class="styleGrid">
          <div class="styleCard">
            <h4>원 크기 <span class="subtle" style="float:right;">px</span></h4>
            <div class="rangeRow">
              <input type="range" id="mfR" min="2" max="40" step="1" />
              <div class="numBox" id="mfRVal">10</div>
            </div>
            <div class="subtle" style="margin-top:10px;">* 원 크기 변경 시 글씨 크기가 같은 비율로 자동 변경됩니다.</div>
          </div>

          <div class="styleCard">
            <h4>글씨 크기 <span class="subtle" style="float:right;">라벨</span></h4>
            <div class="rangeRow">
              <input type="range" id="mfFs" min="4" max="80" step="1" />
              <div class="numBox" id="mfFsVal">15</div>
            </div>
            <div class="subtle" style="margin-top:10px;">* 현재는 자동 동기화 우선</div>
          </div>

          <div class="styleCard">
            <h4>굵기/색상 <span class="subtle" style="float:right;">라벨</span></h4>
            <select class="field fwSelect" id="mfFw">
              <option value="900">900 (Black)</option>
              <option value="800">800 (ExtraBold)</option>
              <option value="700">700 (Bold)</option>
              <option value="600">600 (SemiBold)</option>
            </select>

            <div class="labelRow" style="margin-top:10px;">글씨 색상 (라벨)</div>
            <div style="display:flex; gap:10px; align-items:center;">
              <input class="field" style="flex:1;" id="mfLabelColor" placeholder="#e7eef8" />
              <button class="btnBig" id="mfLabelDefault" type="button">기본값</button>
            </div>

            <div class="labelRow" style="margin-top:10px;">빠른 글씨색</div>
            <div class="quickTextColors" id="textColors"></div>
          </div>
        </div>

        <div class="subtle" id="mfPos" style="margin-top:12px;">좌표(비율): -</div>
      </div>

      <div class="modalFoot">
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btnBig" id="btnNewChain">새로운 번호로 시작</button>
          <button class="btnBig" id="btnInsertAfter">해당 마커를 이어서 시작</button>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-left:auto;">
          <button class="btnBig danger" id="btnDeleteMarker">삭제</button>
          <button class="btnBig ok" id="btnSaveMarker">저장</button>
        </div>
      </div>
    </div>
  </div>

  <!-- CATEGORY EDIT MODAL -->
  <div class="modalBack" id="mCats">
    <div class="modal">
      <div class="modalHead">
        <div class="title">카테고리/색상 편집</div>
        <button class="modalClose" id="btnCloseCats">닫기</button>
      </div>

      <div class="modalBody">
        <div class="subtle">저장하면 현재 게임의 카테고리 목록이 완전히 교체됩니다.</div>
        <div class="hr"></div>

        <div class="sectionTitle" style="margin-top:0;">
          <span>카테고리 옵션</span>
          <span class="subtle">표시/필터</span>
        </div>

        <div class="chipRow" style="gap:10px;">
          <div class="chip" id="tgShowChainSameCat">
            <div class="dotc" style="background:#fff;"></div>
            <div>같은 카테고리 필터 시 선도 같이 표시/숨김</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="labelRow" style="margin-top:14px;">빠른 색상 (선택한 카테고리 행에 적용)</div>
        <div class="palette" id="catQuickPalette" style="margin-top:10px;"></div>
        <div class="subtle" style="margin-top:8px;">카테고리 행을 먼저 클릭해서 선택하세요.</div>

        <div class="hr"></div>

        <div class="row2">
          <button class="pill btnFull ghost" id="btnAddCat">+ 카테고리 추가</button>
          <button class="pill btnFull ghost" id="btnCatsDefault">기본값으로</button>
        </div>

        <div class="hr"></div>
        <div id="catRows"></div>
      </div>

      <div class="modalFoot" style="justify-content:flex-end;">
        <button class="btnBig ok" id="btnSaveCats">저장</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      /************************************************************
       * ADMIN99 저장 규칙
       ************************************************************/
      const LS_AUTH_KEY = "mapmode_admin_auth_v99";
      const LS_KEY = "mapmode_state_v99";
      const REMOTE_STATE_URL = new URL("./data/state.json", location.href).toString();
      const PASSWORD = "0000000001";
      const AUTH_MS = 24 * 60 * 60 * 1000;

      const defaultCats = [
        { id:"전체", name:"전체", color:"#7cc4ff", on:true },
        { id:"보스", name:"보스", color:"#ff5d5d", on:true },
        { id:"기텔", name:"기텔", color:"#ffd60a", on:true },
        { id:"큐브", name:"큐브", color:"#2b8cff", on:true },
      ];

      /* ===========================
         ✅ [ADD] 상단 카테고리(1~4) 독립 상태
         - slotGroups[0]은 기존 games/game과 호환(미러링)
         - slotGroups[1~3]은 완전 독립
         =========================== */
      function makeDefaultSlotGroup(name){
        return {
          items: name ? [buildGameRaw(name, true)] : [],
          active: name ? buildGameRaw(name, true) : ""
        };
      }

      const defaultState = {
        version:99,

        /* 기존 호환 필드 */
        game:"아이온2",
        games:["아이온2"],

        /* ✅ 독립 4슬롯 */
        slotGroups: [
          makeDefaultSlotGroup("아이온2"),
          makeDefaultSlotGroup(""),
          makeDefaultSlotGroup(""),
          makeDefaultSlotGroup("")
        ],

        logoUrl:"",
        pages: [
          { id:"p_all", name:"전체지도", url:"" },
          { id:"p_2", name:"2번마을", url:"" },
          { id:"p_3", name:"3번마을", url:"" },
          { id:"p_4", name:"4번마을", url:"" },
          { id:"p_5", name:"5번마을", url:"" },
          { id:"p_6", name:"6번마을", url:"" },
          { id:"p_7", name:"7번마을", url:"" },
        ],
        currentPageId:"p_all",
        categories: structuredClone(defaultCats),
        showLinesWithCatFilter:true,
        map:{ imgDataUrl:"", naturalW:1, naturalH:1, scale:0, tx:0, ty:0 },
        markers:[],

        /* ✅ [MOD#5] 곡선(컨트롤) 저장: chains 배열 사용 */
        chains:[]
      };

      const $ = (id)=>document.getElementById(id);
      const cv = $("cv");
      const ctx = cv.getContext("2d");
      const toastEl = $("toast");
      const lock = $("lock");
      const pw = $("pw");
      const btnLogin = $("btnLogin");
      const lockMsg = $("lockMsg");
      const pageList = $("pageList");
      const catChips = $("catChips");
      const palette = $("palette");
      const textColors = $("textColors");
      const mMarker = $("mMarker");
      const mCats = $("mCats");

      // slots
      const gSlot1 = $("gSlot1");
      const gSlot2 = $("gSlot2");
      const gSlot3 = $("gSlot3");
      const gSlot4 = $("gSlot4");

      // dropdown
      const gameDropWrap = $("gameDropWrap");
      const gameDropList = $("gameDropList");
      const btnAddGameDrop = $("btnAddGameDrop");
      const gameDropTitle = $("gameDropTitle");

      // popup
      const popLayer = $("popLayer");
      const pop = $("pop");
      const popTitle = $("popTitle");
      const popMsg = $("popMsg");
      const popInput = $("popInput");
      const popOk = $("popOk");
      const popCancel = $("popCancel");
      const popClose = $("popClose");
      const popFoot = $("popFoot");

      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
      const safeParse = (json, fallback) => { try{ return JSON.parse(json); }catch(e){ return fallback; } };
      const uid = () => Math.random().toString(36).slice(2,10);

      function toast(msg, ms=1200){
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        clearTimeout(toast._t);
        toast._t = setTimeout(()=>toastEl.classList.remove("show"), ms);
      }

      function isAuthed(){
        const t = Number(localStorage.getItem(LS_AUTH_KEY) || "0");
        return (Date.now() - t) < AUTH_MS;
      }
      function setAuthed(){ localStorage.setItem(LS_AUTH_KEY, String(Date.now())); }
      function requireAuth(){
        if(isAuthed()){ lock.classList.remove("show"); return; }
        lock.classList.add("show");
        pw.value = "";
        lockMsg.textContent = "";
        setTimeout(()=>pw.focus(), 0);
      }
      btnLogin.addEventListener("click", ()=>{
        if(pw.value === PASSWORD){
          setAuthed();
          lock.classList.remove("show");
          toast("인증 완료");
        }else{
          lockMsg.textContent = "비밀번호가 올바르지 않습니다.";
          toast("비밀번호 오류");
        }
      });
      pw.addEventListener("keydown", (e)=>{ if(e.key==="Enter") btnLogin.click(); });

      // ---------- popup helpers (prompt/confirm 대체) ----------
      let _popResolve = null;
      let _popMode = "input"; // input | confirm
      function popPlaceNear(anchorEl){
        const pad = 10;
        const r = anchorEl ? anchorEl.getBoundingClientRect() : {left: (window.innerWidth/2), top:(window.innerHeight/2), width:0, height:0, right:(window.innerWidth/2), bottom:(window.innerHeight/2)};
        const popW = Math.min(380, window.innerWidth - 28);
        pop.style.width = popW + "px";
        const estH = (_popMode==="confirm") ? 170 : 210;
        let x = r.left;
        let y = r.bottom + 10;
        if(y + estH > window.innerHeight - pad){
          y = Math.max(pad, r.top - estH - 10);
        }
        x = clamp(x, pad, window.innerWidth - popW - pad);
        pop.style.left = x + "px";
        pop.style.top = y + "px";
      }
      function openPopInput({anchor, title="입력", message="", placeholder="", value="", okText="저장", cancelText="취소"}){
        requireAuth();
        if(!isAuthed()) return Promise.resolve(null);
        _popMode = "input";
        popTitle.textContent = title;
        popMsg.style.display = message ? "block" : "none";
        popMsg.textContent = message || "";
        popInput.style.display = "block";
        popInput.placeholder = placeholder || "";
        popInput.value = value ?? "";
        popOk.textContent = okText;
        popCancel.textContent = cancelText;
        popOk.classList.remove("danger");
        popOk.classList.add("ok");
        popFoot.style.display = "flex";
        popLayer.classList.add("show");
        popLayer.setAttribute("aria-hidden","false");
        popPlaceNear(anchor);
        setTimeout(()=>popInput.focus(), 0);
        return new Promise((res)=>{ _popResolve = res; });
      }
      function openPopConfirm({anchor, title="확인", message="정말 진행할까요?", okText="확인", cancelText="취소", danger=false}){
        requireAuth();
        if(!isAuthed()) return Promise.resolve(false);
        _popMode = "confirm";
        popTitle.textContent = title;
        popMsg.style.display = "block";
        popMsg.textContent = message || "";
        popInput.style.display = "none";
        popOk.textContent = okText;
        popCancel.textContent = cancelText;
        popFoot.style.display = "flex";
        if(danger){
          popOk.classList.remove("ok");
          popOk.classList.add("danger");
        }else{
          popOk.classList.remove("danger");
          popOk.classList.add("ok");
        }
        popLayer.classList.add("show");
        popLayer.setAttribute("aria-hidden","false");
        popPlaceNear(anchor);
        return new Promise((res)=>{ _popResolve = (v)=>res(!!v); });
      }
      function popCommit(val){
        if(!_popResolve) return;
        const r = _popResolve;
        _popResolve = null;
        popLayer.classList.remove("show");
        popLayer.setAttribute("aria-hidden","true");
        r(val);
      }
      popClose.addEventListener("click", ()=>popCommit(null));
      popCancel.addEventListener("click", ()=>popCommit(null));
      popOk.addEventListener("click", ()=>{
        if(_popMode==="confirm"){ popCommit(true); return; }
        popCommit(popInput.value);
      });
      popLayer.addEventListener("mousedown", (e)=>{ if(e.target === popLayer) popCommit(null); });
      window.addEventListener("keydown", (e)=>{
        if(!popLayer.classList.contains("show")) return;
        if(e.key==="Escape"){ e.preventDefault(); popCommit(null); }
        if(e.key==="Enter"){
          if(_popMode==="confirm"){ e.preventDefault(); popCommit(true); }
          else{
            if(document.activeElement === popInput){
              e.preventDefault(); popCommit(popInput.value);
            }
          }
        }
      });

      // ---------- state ----------
      let S = structuredClone(defaultState);
      let mapImg = new Image();
      mapImg.crossOrigin = "anonymous";

      const currentChainByPage = Object.create(null);

      function parseGameRaw(raw){
        const s = String(raw ?? "");
        const m = s.match(/^(.*)\|([01])$/);
        if(m){ return { raw:s, name:m[1], enabled: m[2] === "1" }; }
        return { raw:s, name:s, enabled:true };
      }
      function buildGameRaw(name, enabled){
        const nm = String(name ?? "").trim();
        if(!nm) return "";
        return enabled ? nm : (nm + "|0");
      }

      function escapeHtml(s){
        return String(s ?? "")
          .replace(/&/g,"&amp;")
          .replace(/</g,"&lt;")
          .replace(/>/g,"&gt;")
          .replace(/"/g,"&quot;")
          .replace(/'/g,"&#39;");
      }

      function normalizeSlotGroups(st){
        // ✅ migrate old games/game into slotGroups[0] if needed
        const out = Array.isArray(st?.slotGroups) ? st.slotGroups : null;

        if(out && out.length === 4){
          // ensure shape
          for(let i=0;i<4;i++){
            if(!out[i] || typeof out[i] !== "object") out[i] = makeDefaultSlotGroup("");
            if(!Array.isArray(out[i].items)) out[i].items = [];
            if(typeof out[i].active !== "string") out[i].active = out[i].items[0] || "";
          }
          return out;
        }

        // fallback: create new based on old games/game
        const gList = Array.isArray(st?.games) && st.games.length ? st.games.slice() : ["아이온2"];
        const gActive = (typeof st?.game === "string" && st.game) ? st.game : gList[0];
        const sg0 = { items: gList.slice(), active: gActive };
        if(!sg0.items.length && sg0.active) sg0.items = [sg0.active];
        if(!sg0.active && sg0.items.length) sg0.active = sg0.items[0];

        return [ sg0, makeDefaultSlotGroup(""), makeDefaultSlotGroup(""), makeDefaultSlotGroup("") ];
      }

      function mirrorSlot1ToLegacy(){
        // slotGroups[0] <-> games/game 호환 유지
        const sg0 = S.slotGroups[0];
        S.games = sg0.items.slice();
        S.game = sg0.active || (sg0.items[0] || "아이온2");
      }
      function ensureSlot1FromLegacy(){
        const sg0 = S.slotGroups[0];
        if(!sg0.items.length && Array.isArray(S.games) && S.games.length){
          sg0.items = S.games.slice();
        }
        if(!sg0.active && S.game){
          sg0.active = S.game;
        }
        if(!sg0.active && sg0.items.length){
          sg0.active = sg0.items[0];
        }
        mirrorSlot1ToLegacy();
      }

      function mergeState(st){
        const merged = structuredClone(defaultState);
        if(st && typeof st === "object") Object.assign(merged, st);

        merged.pages = Array.isArray(st?.pages) && st.pages.length ? st.pages : structuredClone(defaultState.pages);
        merged.categories = Array.isArray(st?.categories) && st.categories.length ? st.categories : structuredClone(defaultCats);
        merged.markers = Array.isArray(st?.markers) ? st.markers : [];
        merged.chains = Array.isArray(st?.chains) ? st.chains : [];

        merged.map = Object.assign(structuredClone(defaultState.map), st?.map||{});

        // ✅ slotGroups normalize
        merged.slotGroups = normalizeSlotGroups(st);

        // legacy mirror ensure
        if(!Array.isArray(merged.games) || !merged.games.length) merged.games = ["아이온2"];
        if(typeof merged.game !== "string" || !merged.game) merged.game = merged.games[0];

        if(!merged.pages.find(p=>p.id===merged.currentPageId)) merged.currentPageId = merged.pages[0].id;

        // marker defaults
        for(const m of merged.markers){
          if(typeof m.order !== "number") m.order = (typeof m.chainIndex==="number" ? m.chainIndex : null);
          if(typeof m.dim !== "boolean") m.dim = false;
          if(m.order == null) m.order = 0;
          if(typeof m.chainId === "undefined") m.chainId = null;
          if(typeof m.memo !== "string") m.memo = "";
          if(typeof m.yt !== "string") m.yt = "";
          if(typeof m.ytTitle !== "string") m.ytTitle = "";
          if(typeof m.labelColor !== "string") m.labelColor = "#e7eef8";
          if(typeof m.fw !== "number") m.fw = 900;
          if(typeof m.r !== "number") m.r = 10;
          if(typeof m.fs !== "number") m.fs = 15;
          if(typeof m.useCatColor !== "boolean") m.useCatColor = true;
          if(typeof m.colorOverride !== "string") m.colorOverride = "";
        }
        return merged;
      }

      function saveLocal(){
        mirrorSlot1ToLegacy();
        localStorage.setItem(LS_KEY, JSON.stringify(S));
      }

      async function loadStateRemoteFirst(){
        try{
          const r = await fetch(REMOTE_STATE_URL, { cache:"no-store" });
          if(r.ok){
            const st = await r.json();
            localStorage.setItem(LS_KEY, JSON.stringify(st));
            return st;
          }
        }catch(e){}
        const raw = localStorage.getItem(LS_KEY);
        return raw ? safeParse(raw, structuredClone(defaultState)) : structuredClone(defaultState);
      }

      // ---------- logo ----------
      const logoBox = $("logoBox");
      function renderLogo(){
        logoBox.innerHTML = "";
        if(S.logoUrl){
          const img = document.createElement("img");
          img.src = S.logoUrl;
          img.alt = "logo";
          img.onerror = () => {
            logoBox.innerHTML = `<div class="brand"><div class="word">MAPM<span class="o"></span>DE</div></div>`;
          };
          logoBox.appendChild(img);
        }else{
          logoBox.innerHTML = `<div class="brand"><div class="word">MAPM<span class="o"></span>DE</div></div>`;
        }
      }
      logoBox.addEventListener("click", async ()=>{
        requireAuth();
        if(!isAuthed()) return;
        const cur = S.logoUrl || "";
        const next = await openPopInput({
          anchor: logoBox,
          title: "로고 URL 설정",
          message: "로고 이미지 URL을 입력하세요. 비우면 기본 로고로 돌아갑니다.",
          placeholder: "https://... (비우면 기본)",
          value: cur,
          okText: "저장",
          cancelText: "취소"
        });
        if(next === null) return;
        S.logoUrl = (next || "").trim();
        saveLocal();
        renderLogo();
        toast("로고 설정 저장");
      });

      // ✅ FIX: 카테고리1 폰트 자동 맞춤(한 줄/… 금지)
      function fitSlot1Text(){
        const slot = gSlot1;
        if(!slot) return;
        const nm = slot.querySelector(".gNm");
        if(!nm) return;
        const btn = slot.querySelector(".gEnBtn");
        const pad = 18;
        const avail = Math.max(10, slot.clientWidth - (btn ? btn.offsetWidth : 0) - pad);
        nm.style.whiteSpace = "nowrap";
        nm.style.overflow = "hidden";
        nm.style.textOverflow = "clip";
        const minFs = 10;
        const maxFs = 18;
        let lo = minFs, hi = maxFs, best = minFs;
        for(let i=0;i<12;i++){
          const mid = (lo + hi) / 2;
          nm.style.fontSize = mid + "px";
          if(nm.scrollWidth <= avail){ best = mid; lo = mid; }
          else hi = mid;
        }
        nm.style.fontSize = Math.floor(best) + "px";
      }

      // ---------- slots dropdown (카테고리 1/2/3/4 독립) ----------
      let _openSlotIndex = 0;
      let _gameDropAnchorEl = null;

      function slotGroup(i){
        if(!S.slotGroups) S.slotGroups = normalizeSlotGroups(S);
        if(!S.slotGroups[i]) S.slotGroups[i] = makeDefaultSlotGroup("");
        if(!Array.isArray(S.slotGroups[i].items)) S.slotGroups[i].items = [];
        if(typeof S.slotGroups[i].active !== "string") S.slotGroups[i].active = S.slotGroups[i].items[0] || "";
        return S.slotGroups[i];
      }

      function setSlotActive(i, raw){
        const sg = slotGroup(i);
        sg.active = raw || "";
        // ✅ slot1은 기존 game context와 동일하게 동작
        if(i === 0){
          S.game = sg.active || (sg.items[0] || "아이온2");
          $("pathGameTop").textContent = parseGameRaw(S.game).name || "아이온2";
          $("pathGame").textContent = parseGameRaw(S.game).name || "아이온2";
          saveLocal();
          renderSlotsTop();
          renderPages();
          renderCats();
          renderKpi();
          draw();
          toast("카테고리1 변경");
        }else{
          saveLocal();
          renderSlotsTop();
          toast(`카테고리${i+1} 변경`);
        }
      }

      function setSlotItemAtIndex(slotIdx, itemIdx, newRaw){
        const sg = slotGroup(slotIdx);
        if(itemIdx < 0 || itemIdx >= sg.items.length) return;
        const prev = sg.items[itemIdx];
        sg.items[itemIdx] = newRaw;
        if(sg.active === prev) sg.active = newRaw;
        // cleanup: if active becomes empty, set to first
        if(!sg.active && sg.items.length) sg.active = sg.items[0];
        if(slotIdx === 0) ensureSlot1FromLegacy(); // keep mirrored
      }

      function toggleSlotItemEnabled(slotIdx, raw){
        const sg = slotGroup(slotIdx);
        const idx = sg.items.indexOf(raw);
        if(idx < 0) return;
        const info = parseGameRaw(raw);
        const nextRaw = buildGameRaw(info.name, !info.enabled);
        setSlotItemAtIndex(slotIdx, idx, nextRaw);
        saveLocal();
        renderSlotsTop();
        renderSlotDropList();
        toast(!info.enabled ? "활성화" : "비활성화");
      }

      function renderSlotsTop(){
        // ensure legacy mirrored fields consistent
        ensureSlot1FromLegacy();

        const slots = [gSlot1,gSlot2,gSlot3,gSlot4];
        for(let i=0;i<4;i++){
          const el = slots[i];
          const sg = slotGroup(i);
          const activeRaw = sg.active || "";
          const info = activeRaw ? parseGameRaw(activeRaw) : {name:"추가", enabled:false, raw:""};
          const isActiveContext = (i===0 && activeRaw && activeRaw === S.game);

          if(activeRaw){
            el.classList.toggle("active", !!isActiveContext);
            el.classList.toggle("off", !info.enabled);
            el.innerHTML = `
              <span class="gNm" title="${escapeHtml(info.name)}">${escapeHtml(info.name)}</span>
              <button class="gEnBtn${info.enabled ? "" : " off"}" type="button" title="활성/비활성">${info.enabled ? "✓" : "–"}</button>
            `;
          }else{
            el.classList.remove("active");
            el.classList.add("off");
            el.innerHTML = `
              <span class="gNm" style="opacity:.7;">추가</span>
              <button class="gEnBtn off" type="button" title="비활성" disabled>–</button>
            `;
          }
        }

        $("pathGameTop").textContent = parseGameRaw(S.game).name || "아이온2";
        $("pathGame").textContent = parseGameRaw(S.game).name || "아이온2";
        fitSlot1Text();
      }

      function computeGameDropNeedWidth(){
        let maxNeed = 0;
        const rows = gameDropList.querySelectorAll(".gRow");
        for(const r of rows){
          const nm = r.querySelector(".nm");
          if(!nm) continue;
          const acts = r.querySelector(".acts");
          const need = (nm.scrollWidth || 0) + (acts ? acts.offsetWidth : 0) + 40;
          maxNeed = Math.max(maxNeed, need);
        }
        return maxNeed || 0;
      }
      function placeGameDropUnderSlot(anchor, desiredW){
        const anchorEl = anchor || gSlot1;
        const r = anchorEl.getBoundingClientRect();
        const baseW = Math.min((anchorEl.offsetWidth || r.width) + 20, window.innerWidth - 28);
        const w = Math.min(Math.max((desiredW || baseW), 220), window.innerWidth - 28);
        gameDropWrap.style.width = w + "px";
        const left = clamp(r.left, 14, window.innerWidth - w - 14);
        const top = r.bottom + 8;
        gameDropWrap.style.left = left + "px";
        gameDropWrap.style.top = top + "px";
      }

      function renderSlotDropList(){
        gameDropList.innerHTML = "";

        const sg = slotGroup(_openSlotIndex);
        const title = `카테고리${_openSlotIndex+1} 목록`;
        gameDropTitle.textContent = title;

        const active = sg.active || "";
        for(const raw of sg.items){
          const info = parseGameRaw(raw);
          const row = document.createElement("div");
          row.className = "gRow" + (raw===active ? " active" : "") + (!info.enabled ? " off" : "");
          row.innerHTML = `
            <div class="nm" title="${escapeHtml(info.name)}">${escapeHtml(info.name)}</div>
            <div class="acts">
              <button class="miniBtn icon edit" type="button" title="이름 편집">✎</button>
              <button class="miniBtn icon del" type="button" title="삭제">🗑</button>
            </div>
          `;

          row.addEventListener("click", (e)=>{
            const btn = e.target.closest("button");
            if(btn) return;
            setSlotActive(_openSlotIndex, raw);
            closeGameDrop();
          });

          const bEdit = row.querySelector(".edit");
          const bDel = row.querySelector(".del");

          bEdit.addEventListener("click", async (e)=>{
            e.stopPropagation();
            const nn = await openPopInput({
              anchor: bEdit,
              title: `카테고리${_openSlotIndex+1} 이름 편집`,
              message: "이름을 수정하세요.",
              placeholder: "예: 아이온2",
              value: info.name,
              okText: "저장",
              cancelText: "취소"
            });
            if(nn === null) return;
            const name = (nn||"").trim();
            if(!name) return;

            // ✅ 슬롯 내부 중복만 금지 (다른 카테고리와는 완전 분리)
            const exists = sg.items.some(x=>{
              if(x === raw) return false;
              return parseGameRaw(x).name === name;
            });
            if(exists){ toast("이미 존재"); return; }

            const idx = sg.items.indexOf(raw);
            if(idx>=0){
              const nextRaw = buildGameRaw(name, info.enabled);
              setSlotItemAtIndex(_openSlotIndex, idx, nextRaw);
              if(_openSlotIndex === 0) ensureSlot1FromLegacy();
            }
            saveLocal();
            renderSlotsTop();
            renderSlotDropList();
            toast("이름 수정");
          });

          bDel.addEventListener("click", async (e)=>{
            e.stopPropagation();
            // ✅ 슬롯 내부만 삭제 (다른 카테고리 영향 없음)
            if(sg.items.length <= 1){
              toast("최소 1개는 필요합니다");
              return;
            }
            const ok = await openPopConfirm({
              anchor: bDel,
              title: "삭제",
              message: `"${info.name}" 항목을 삭제할까요?`,
              okText: "삭제",
              cancelText: "취소",
              danger: true
            });
            if(!ok) return;

            sg.items = sg.items.filter(x=>x!==raw);
            if(sg.active === raw) sg.active = sg.items[0] || "";
            saveLocal();
            renderSlotsTop();
            renderSlotDropList();
            toast("삭제 완료");
          });

          gameDropList.appendChild(row);
        }
      }

      function openGameDrop(anchor, slotIdx){
        requireAuth();
        if(!isAuthed()) return;

        _openSlotIndex = slotIdx ?? 0;
        _gameDropAnchorEl = anchor || gSlot1;

        renderSlotDropList();
        placeGameDropUnderSlot(_gameDropAnchorEl);
        gameDropWrap.classList.add("show");

        requestAnimationFrame(()=>{
          const need = computeGameDropNeedWidth();
          if(need) placeGameDropUnderSlot(_gameDropAnchorEl, need);
        });
      }
      function closeGameDrop(){ gameDropWrap.classList.remove("show"); }
      function toggleGameDrop(anchor, slotIdx){
        if(gameDropWrap.classList.contains("show")) closeGameDrop();
        else openGameDrop(anchor, slotIdx);
      }

      function onTopSlotClickFactory(slotEl, slotIndex){
        slotEl.addEventListener("click", (e)=>{
          requireAuth();
          if(!isAuthed()) return;

          const btn = e.target.closest(".gEnBtn");
          const sg = slotGroup(slotIndex);
          const raw = sg.active || "";

          if(btn){
            e.stopPropagation();
            if(!raw) return;
            toggleSlotItemEnabled(slotIndex, raw);
            return;
          }
          toggleGameDrop(slotEl, slotIndex);
        });
      }
      onTopSlotClickFactory(gSlot1, 0);
      onTopSlotClickFactory(gSlot2, 1);
      onTopSlotClickFactory(gSlot3, 2);
      onTopSlotClickFactory(gSlot4, 3);

      window.addEventListener("resize", ()=>{
        if(gameDropWrap.classList.contains("show")){
          placeGameDropUnderSlot(_gameDropAnchorEl || gSlot1, computeGameDropNeedWidth() || undefined);
        }
        fitSlot1Text();
      });

      document.addEventListener("mousedown", (e)=>{
        if(!gameDropWrap.classList.contains("show")) return;
        if(e.target.closest("#gameDropWrap")) return;
        if(e.target.closest("#gSlot1") || e.target.closest("#gSlot2") || e.target.closest("#gSlot3") || e.target.closest("#gSlot4")) return;
        closeGameDrop();
      });
      window.addEventListener("keydown", (e)=>{
        if(e.key==="Escape" && gameDropWrap.classList.contains("show")) closeGameDrop();
      });

      btnAddGameDrop.addEventListener("click", async ()=>{
        requireAuth();
        if(!isAuthed()) return;

        const sg = slotGroup(_openSlotIndex);

        const nn = await openPopInput({
          anchor: btnAddGameDrop,
          title: `카테고리${_openSlotIndex+1} 추가`,
          message: "추가할 이름을 입력하세요.",
          placeholder: "예: 패스오브엑자일",
          value: "",
          okText: "추가",
          cancelText: "취소"
        });
        if(nn === null) return;

        const name = (nn||"").trim();
        if(!name) return;

        // ✅ 슬롯 내부에서만 중복 금지
        const exists = sg.items.some(x=>parseGameRaw(x).name === name);
        if(exists){ toast("이미 존재"); return; }

        const raw = buildGameRaw(name, true);
        sg.items.push(raw);
        sg.active = raw;

        saveLocal();
        renderSlotsTop();
        renderSlotDropList();
        toast("추가 완료");

        // ✅ slot1은 즉시 컨텍스트 변경
        if(_openSlotIndex === 0){
          setSlotActive(0, raw);
        }
      });

      // ---------- pages ----------
      function renderPages(){
        pageList.innerHTML = "";
        const cur = S.pages.find(p=>p.id===S.currentPageId) || S.pages[0];
        $("pathPage").textContent = cur ? cur.name : "전체지도";
        for(const p of S.pages){
          const item = document.createElement("div");
          item.className = "pageItem" + (p.id===S.currentPageId ? " active" : "");
          item.innerHTML = `
            <div class="pageName">${escapeHtml(p.name)}</div>
            <div class="pageActions">
              <button class="miniBtn url" type="button" title="지도 이미지 URL 설정">URL</button>
              <button class="miniBtn icon edit" type="button" title="이름 편집">✎</button>
              <button class="miniBtn icon del" type="button" title="삭제">🗑</button>
            </div>
          `;

          item.addEventListener("click", (e)=>{
            const btn = e.target.closest("button");
            if(btn) return;
            S.currentPageId = p.id;
            saveLocal();
            renderPages();
            renderKpi();
            loadMap();
            applyAllCatStylesOnPage(S.currentPageId);
            applyAllChainStylesOnPage(S.currentPageId);
            saveLocal();
            draw();
          });

          const bUrl = item.querySelector(".url");
          const bEdit = item.querySelector(".edit");
          const bDel = item.querySelector(".del");

          bUrl.addEventListener("click", async (e)=>{
            e.stopPropagation();
            requireAuth();
            if(!isAuthed()) return;
            const next = await openPopInput({
              anchor: bUrl,
              title: "페이지 지도 URL",
              message: "이 페이지 지도 이미지 URL을 입력하세요. (Raw/GitHub Pages URL 가능)",
              placeholder: "https://.../map.png",
              value: p.url || "",
              okText: "저장",
              cancelText: "취소"
            });
            if(next === null) return;
            p.url = (next || "").trim();
            saveLocal();
            toast("페이지 URL 저장");
            if(p.id === S.currentPageId) loadMap();
          });

          bEdit.addEventListener("click", async (e)=>{
            e.stopPropagation();
            requireAuth();
            if(!isAuthed()) return;
            const next = await openPopInput({
              anchor: bEdit,
              title: "페이지 이름 편집",
              message: "페이지 이름을 수정하세요.",
              placeholder: "예: 8번마을",
              value: p.name,
              okText: "저장",
              cancelText: "취소"
            });
            if(next === null) return;
            const name = (next||"").trim();
            if(!name) return;
            p.name = name;
            saveLocal();
            renderPages();
            toast("페이지 이름 수정");
          });

          bDel.addEventListener("click", async (e)=>{
            e.stopPropagation();
            requireAuth();
            if(!isAuthed()) return;
            if(S.pages.length <= 1){
              toast("최소 1개 페이지는 필요합니다");
              return;
            }
            const ok = await openPopConfirm({
              anchor: bDel,
              title: "페이지 삭제",
              message: `"${p.name}" 페이지를 삭제할까요?\n(해당 페이지 마커도 같이 삭제됩니다)`,
              okText: "삭제",
              cancelText: "취소",
              danger: true
            });
            if(!ok) return;
            const pid = p.id;
            S.markers = S.markers.filter(m=>m.pageId !== pid);
            S.pages = S.pages.filter(x=>x.id !== pid);
            if(S.currentPageId === pid) S.currentPageId = S.pages[0].id;
            // curves clean
            S.chains = (S.chains||[]).filter(x => x && x.pageId !== pid);
            saveLocal();
            renderPages();
            renderKpi();
            loadMap();
            draw();
            toast("페이지 삭제");
          });

          pageList.appendChild(item);
        }
      }

      $("btnAddPage").addEventListener("click", async ()=>{
        requireAuth();
        if(!isAuthed()) return;
        const name = await openPopInput({
          anchor: $("btnAddPage"),
          title: "페이지 추가",
          message: "추가할 페이지 이름을 입력하세요. (예: 8번마을)",
          placeholder: "예: 8번마을",
          value: "",
          okText: "추가",
          cancelText: "취소"
        });
        if(name === null) return;
        const n = (name||"").trim();
        if(!n) return;
        const p = { id:"p_"+uid(), name:n, url:"" };
        S.pages.push(p);
        S.currentPageId = p.id;
        saveLocal();
        renderPages();
        renderKpi();
        loadMap();
        draw();
        toast("페이지 추가");
      });

      // ---------- categories ----------
      function getCat(id){ return S.categories.find(c=>c.id===id); }

      function markerColor(m){
        if(!m) return "#7cc4ff";
        if(m.useCatColor){
          const c = getCat(m.cat);
          return (c && c.color) ? c.color : "#7cc4ff";
        }
        if(m.colorOverride && m.colorOverride.trim()) return m.colorOverride.trim();
        const c = getCat(m.cat);
        return (c && c.color) ? c.color : "#7cc4ff";
      }

      function renderCats(){
        catChips.innerHTML = "";
        for(const c of S.categories){
          const chip = document.createElement("div");
          chip.className = "chip" + (c.on ? " on" : "");
          chip.innerHTML = `<div class="dotc" style="background:${escapeHtml(c.color)};"></div><div>${escapeHtml(c.name)}</div>`;
          chip.addEventListener("click", ()=>{
            requireAuth();
            if(!isAuthed()) return;

            if(c.id === "전체"){
              // ✅ "전체"는 마스터 표시/숨김
              const nextOn = !c.on;
              c.on = nextOn;
              if(nextOn){
                for(const cc of S.categories){ if(cc.id!=="전체") cc.on = true; }
              }
            }else{
              c.on = !c.on;
              // ✅ 최소 1개 카테고리 ON 보장(전체 제외)
              const anyOn = S.categories.some(x=>x.id!=="전체" && x.on);
              if(!anyOn){
                c.on = true;
                toast("최소 1개 카테고리는 켜져야 합니다");
              }
            }
            saveLocal();
            renderCats();
            renderKpi();
            draw();
          });
          catChips.appendChild(chip);
        }
      }

      function setChipToggle(el, on){ el.classList.toggle("on", !!on); el.dataset.on = on ? "1" : "0"; }

      const tgShowLinesWithCatFilter = $("tgShowChainSameCat");
      tgShowLinesWithCatFilter.addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        S.showLinesWithCatFilter = !S.showLinesWithCatFilter;
        setChipToggle(tgShowLinesWithCatFilter, S.showLinesWithCatFilter);
        saveLocal();
        draw();
      });

      // ---------- map upload ----------
      $("fileMap").addEventListener("change", async (e)=>{
        requireAuth();
        if(!isAuthed()) return;
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        const dataUrl = await fileToDataURL(f);
        S.map.imgDataUrl = dataUrl;
        saveLocal();
        loadMap();
        toast("지도 업로드 완료");
        e.target.value = "";
      });

      function fileToDataURL(file){
        return new Promise((res, rej)=>{
          const fr = new FileReader();
          fr.onload = ()=>res(fr.result);
          fr.onerror = rej;
          fr.readAsDataURL(file);
        });
      }

      function loadMap(){
        const curPage = S.pages.find(p => p.id === S.currentPageId);
        const pageUrl = (curPage?.url || "").trim();
        if(pageUrl){
          mapImg = new Image();
          mapImg.crossOrigin = "anonymous";
          mapImg.onload = ()=>{
            S.map.naturalW = mapImg.naturalWidth || 1;
            S.map.naturalH = mapImg.naturalHeight || 1;
            fitToScreen();
            saveLocal();
            draw();
            renderKpi();
          };
          mapImg.onerror = ()=>{ toast("지도 URL 로드 실패"); draw(); };
          mapImg.src = pageUrl;
          return;
        }

        if(S.map.imgDataUrl){
          mapImg = new Image();
          mapImg.crossOrigin = "anonymous";
          mapImg.onload = ()=>{
            S.map.naturalW = mapImg.naturalWidth || 1;
            S.map.naturalH = mapImg.naturalHeight || 1;
            if(!S.map.scale || S.map.scale<=0) fitToScreen();
            draw();
          };
          mapImg.src = S.map.imgDataUrl;
          return;
        }

        mapImg = new Image();
        mapImg.onload = ()=>draw();
        mapImg.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" width="1400" height="1000">
            <defs>
              <radialGradient id="g" cx="50%" cy="40%" r="70%">
                <stop offset="0%" stop-color="#ffffff"/>
                <stop offset="100%" stop-color="#e8edf7"/>
              </radialGradient>
            </defs>
            <rect width="100%" height="100%" fill="url(#g)"/>
            <text x="50%" y="50%" text-anchor="middle" font-family="Arial" font-size="28" fill="#7a889e">페이지 URL 또는 지도 업로드가 필요</text>
          </svg>
        `);
      }

      // ---------- export ----------
      $("btnExport").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        const blob = new Blob([JSON.stringify(S, null, 2)], {type:"application/json"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "state.json";
        a.click();
        URL.revokeObjectURL(a.href);
        toast("state.json 다운로드");
      });

      $("btnResetAll").addEventListener("click", async ()=>{
        requireAuth();
        if(!isAuthed()) return;
        const ok = await openPopConfirm({
          anchor: $("btnResetAll"),
          title: "전체 초기화",
          message: "전체 초기화할까요?\n(페이지/마커/지도 포함)",
          okText: "초기화",
          cancelText: "취소",
          danger: true
        });
        if(!ok) return;
        S = structuredClone(defaultState);
        saveLocal();
        renderAll();
        loadMap();
        toast("전체 초기화 완료");
      });

      // ---------- canvas sizing ----------
      function resizeCanvas(){
        const wrap = cv.parentElement;
        const w = wrap.clientWidth - 32;
        const h = wrap.clientHeight - 32;
        cv.width = Math.max(900, Math.floor(w));
        cv.height = Math.max(650, Math.floor(h));
      }
      window.addEventListener("resize", ()=>{ resizeCanvas(); draw(); });

      function fitToScreen(){
        const pad = 40;
        const iw = S.map.naturalW || (mapImg.naturalWidth||1);
        const ih = S.map.naturalH || (mapImg.naturalHeight||1);
        const cw = cv.width, ch = cv.height;
        const scale = Math.min((cw - pad)/iw, (ch - pad)/ih);
        S.map.scale = clamp(scale, 0.05, 10);
        S.map.tx = (cw - iw*S.map.scale)/2;
        S.map.ty = (ch - ih*S.map.scale)/2;
      }

      // ---------- marker data ----------
      function renumberPage(pageId){
        const ms = (S.markers||[]).filter(m=>m.pageId===pageId);
        ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
        for(let i=0;i<ms.length;i++) ms[i].order = i+1;
      }

      /* ✅ [MOD#3] 카테고리 비활성화 동작 버그 수정:
         - "전체"가 OFF면 전부 숨김
         - 각 카테고리 OFF면 해당 카테고리의 모든 마커 숨김 */
      function getVisibleMarkers(){
        const curPage = S.currentPageId;
        const allCat = getCat("전체");
        if(allCat && allCat.on === false) return [];
        return (S.markers||[])
          .filter(m=>{
            if(m.pageId !== curPage) return false;
            const c = getCat(m.cat);
            if(!c) return false;
            if(c.on === false) return false;
            return true;
          })
          .sort((a,b)=>(a.order||0)-(b.order||0));
      }

      function renderKpi(){
        const curPage = S.currentPageId;
        const total = (S.markers||[]).filter(m=>m.pageId===curPage).length;
        const shown = getVisibleMarkers().length;
        $("kpi").textContent = `표시 중 마커: ${shown} / 페이지 전체: ${total}`;
      }

      // ---------- chain helpers (번호/선 분리) ----------
      function ensureMarkerChain(m){ if(!m.chainId) m.chainId = "c0"; return m.chainId; }
      function getPageMarkersSorted(pageId){
        return (S.markers||[]).filter(m=>m.pageId===pageId).slice()
          .sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
      }
      function getChainMarkersOnPage(pageId, chainId){
        return getPageMarkersSorted(pageId).filter(m=>ensureMarkerChain(m)===chainId);
      }
      function recomputeChainIndices(pageId){
        const ms = getPageMarkersSorted(pageId);
        const byChain = new Map();
        for(const m of ms){
          const cid = ensureMarkerChain(m);
          if(!byChain.has(cid)) byChain.set(cid, []);
          byChain.get(cid).push(m);
        }
        for(const [cid, arr] of byChain){
          for(let i=0;i<arr.length;i++) arr[i].chainIndex = i+1;
        }
      }
      function getActiveChainIdForPage(pageId){
        const v = currentChainByPage[pageId];
        if(v) return v;
        const ms = getPageMarkersSorted(pageId);
        const last = ms[ms.length-1];
        const cid = last ? ensureMarkerChain(last) : "c0";
        currentChainByPage[pageId] = cid;
        return cid;
      }
      function setActiveChainIdForPage(pageId, cid){ currentChainByPage[pageId] = cid; }

      // ---------- style propagation ----------
      function leaderOfCat(pageId, catId){
        const ms = (S.markers||[]).filter(m=>m.pageId===pageId && m.cat===catId);
        if(!ms.length) return null;
        ms.sort((a,b)=>(a.order||0)-(b.order||0));
        return ms[0];
      }
      function applyCatLeaderStyle(pageId, catId){
        const leader = leaderOfCat(pageId, catId);
        if(!leader) return;
        const ms = (S.markers||[]).filter(m=>m.pageId===pageId && m.cat===catId);
        for(const m of ms){
          if(m.id===leader.id) continue;
          m.r = leader.r;
          m.fs = leader.fs;
          m.fw = leader.fw;
          m.labelColor = leader.labelColor;
          m.useCatColor = leader.useCatColor;
          m.colorOverride = leader.colorOverride || "";
        }
      }
      function applyAllCatStylesOnPage(pageId){
        const cats = new Set((S.markers||[]).filter(m=>m.pageId===pageId).map(m=>m.cat));
        for(const catId of cats) applyCatLeaderStyle(pageId, catId);
      }

      function leaderOfChain(pageId, chainId){
        const ms = getChainMarkersOnPage(pageId, chainId).slice();
        if(!ms.length) return null;
        ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
        return ms[0];
      }
      function applyChainLeaderStyle(pageId, chainId){
        const ms = getChainMarkersOnPage(pageId, chainId).slice();
        if(ms.length < 2) return;
        ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
        const leader = ms[0];
        const leaderCol = markerColor(leader);
        for(let i=1;i<ms.length;i++){
          const m = ms[i];
          m.r = leader.r;
          m.fs = leader.fs;
          m.fw = leader.fw;
          m.labelColor = leader.labelColor;
          m.useCatColor = false;
          m.colorOverride = leaderCol;
        }
      }
      function applyAllChainStylesOnPage(pageId){
        const ms = getPageMarkersSorted(pageId);
        const chainIds = new Set();
        for(const m of ms) chainIds.add(ensureMarkerChain(m));
        for(const cid of chainIds) applyChainLeaderStyle(pageId, cid);
      }

      // ---------- auto label ----------
      function splitBaseAndNumber(name){
        const s = (name||"").trim();
        const mFront = s.match(/^(\s*)(\d+)(\s*)번(.*)$/);
        if(mFront){
          const num = parseInt(mFront[2], 10);
          if(Number.isFinite(num)) return { kind:"front_bun", pre:mFront[1]||"", num, mid:mFront[3]||"", rest:mFront[4]||"" };
        }
        const mTail = s.match(/^(.*?)(\d+)(\s*)$/);
        if(mTail){
          const num = parseInt(mTail[2], 10);
          if(Number.isFinite(num)) return { kind:"tail", base:(mTail[1]||""), num, tailSpace:(mTail[3]||"") };
        }
        return { kind:"none", raw:s };
      }
      function makeAutoNameFromLeader(leaderName, idx){
        const info = splitBaseAndNumber(leaderName);
        const leaderIdx = 1;
        const delta = Math.max(0, (idx||1) - leaderIdx);
        if(info.kind === "front_bun"){
          const nextNum = info.num + delta;
          return `${info.pre}${nextNum}${info.mid}번${info.rest}`;
        }
        if(info.kind === "tail"){
          const nextNum = info.num + delta;
          return `${info.base}${nextNum}${info.tailSpace}`;
        }
        return `${(leaderName||"").trim()}${idx}`;
      }
      function applyAutoNamesForChainOnPage(pageId, chainId){
        const ms = getChainMarkersOnPage(pageId, chainId);
        if(!ms.length) return;
        const leader = ms[0];
        const leaderName = (leader.name||"").trim();
        if(!leaderName) return;
        for(let i=1;i<ms.length;i++){
          const m = ms[i];
          if((m.name||"").trim()) continue;
          const idx = (m.chainIndex || (i+1));
          m.name = makeAutoNameFromLeader(leaderName, idx);
        }
      }

      // ---------- world/screen helpers ----------
      function worldFromNorm(nx, ny){
        const iw = S.map.naturalW || (mapImg.naturalWidth||1);
        const ih = S.map.naturalH || (mapImg.naturalHeight||1);
        return { x:nx*iw, y:ny*ih };
      }
      function screenFromWorld(wx, wy){
        return { sx: wx*S.map.scale + S.map.tx, sy: wy*S.map.scale + S.map.ty };
      }

      let circleHitboxes = [];
      let curveHitboxes = [];

      // ========== [MOD#5] curve storage helpers ==========
      function getChainCurveStore(pageId, chainId){
        if(!Array.isArray(S.chains)) S.chains = [];
        let obj = S.chains.find(x => x && x.pageId===pageId && x.chainId===chainId);
        if(!obj){
          obj = { pageId, chainId, segs:{} };
          S.chains.push(obj);
        }
        if(!obj.segs || typeof obj.segs !== "object") obj.segs = {};
        return obj;
      }
      function getSegKey(aId, bId){ return `${aId}|${bId}`; }
      function getCurveParams(pageId, chainId, aId, bId){
        const store = getChainCurveStore(pageId, chainId);
        const key = getSegKey(aId, bId);
        const v = store.segs[key];
        if(v && typeof v === "object"){
          const s = (typeof v.s === "number") ? v.s : 0.5;
          const o = (typeof v.o === "number") ? v.o : 0;
          return { s: clamp(s, 0.05, 0.95), o: clamp(o, -1.5, 1.5) };
        }
        return { s: 0.5, o: 0 };
      }
      function setCurveParams(pageId, chainId, aId, bId, params){
        const store = getChainCurveStore(pageId, chainId);
        const key = getSegKey(aId, bId);
        store.segs[key] = { s: params.s, o: params.o };
      }

      function getCurveControlPointWorld(A, B, params){
        const dx = B.x - A.x, dy = B.y - A.y;
        const len = Math.hypot(dx, dy);
        if(len < 1e-6) return { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
        const ux = dx/len, uy = dy/len;
        const px = -uy, py = ux;

        const s = params.s ?? 0.5;
        const o = params.o ?? 0.0;

        return {
          x: A.x + ux*(len*s) + px*(len*o),
          y: A.y + uy*(len*s) + py*(len*o)
        };
      }

      // ---------- [MOD#4] arrowhead: chevron ">" ----------
      function drawChevronArrowWorld(x1,y1,x2,y2, sizeWorld){
        const dx = x2-x1, dy = y2-y1;
        const len = Math.hypot(dx,dy);
        if(len < 1e-6) return;
        const ux = dx/len, uy = dy/len;
        const px = -uy, py = ux;

        const tipX = x2, tipY = y2;
        const backX = x2 - ux*sizeWorld;
        const backY = y2 - uy*sizeWorld;
        const wing = sizeWorld*0.60;

        ctx.save();
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(backX + px*wing, backY + py*wing);
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(backX - px*wing, backY - py*wing);
        ctx.stroke();
        ctx.restore();
      }

      // ---------- draw ----------
      function draw(){
        ctx.clearRect(0,0,cv.width,cv.height);
        circleHitboxes = [];
        curveHitboxes = [];

        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.22)";
        ctx.fillRect(0,0,cv.width,cv.height);
        ctx.restore();

        ctx.save();
        ctx.translate(S.map.tx, S.map.ty);
        ctx.scale(S.map.scale, S.map.scale);

        if(mapImg && mapImg.complete){
          const iw = S.map.naturalW || (mapImg.naturalWidth||1);
          const ih = S.map.naturalH || (mapImg.naturalHeight||1);
          ctx.drawImage(mapImg, 0,0, iw, ih);
        }

        const visible = getVisibleMarkers();

        recomputeChainIndices(S.currentPageId);

        // ===== [MOD#5] chain lines: quadratic curves per segment =====
        if(S.showLinesWithCatFilter){
          const byChain = new Map();
          for(const m of visible){
            const cid = ensureMarkerChain(m);
            if(!byChain.has(cid)) byChain.set(cid, []);
            byChain.get(cid).push(m);
          }

          for(const [cid, ms] of byChain){
            ms.sort((a,b)=>(a.order||0)-(b.order||0));
            if(ms.length < 2) continue;

            const baseR = ms.reduce((acc,m)=>acc + (m.r ?? 10), 0) / Math.max(1, ms.length);
            const lineW = clamp(baseR * 0.18, 0.9, 2.4);      // world
            const arrowSize = clamp(baseR * 0.95, 4.5, 18);   // world

            ctx.save();
            ctx.globalAlpha = 0.92;
            ctx.lineWidth = lineW;
            ctx.strokeStyle = "rgba(255,255,255,.78)";
            ctx.fillStyle = "rgba(255,255,255,.78)";

            for(let i=0;i<ms.length-1;i++){
              const aM = ms[i];
              const bM = ms[i+1];
              const A = worldFromNorm(aM.x, aM.y);
              const B = worldFromNorm(bM.x, bM.y);

              const params = getCurveParams(S.currentPageId, cid, aM.id, bM.id);
              const CP = getCurveControlPointWorld(A, B, params);

              // stroke curve
              ctx.beginPath();
              ctx.moveTo(A.x, A.y);
              ctx.quadraticCurveTo(CP.x, CP.y, B.x, B.y);
              ctx.stroke();

              // store hitbox samples (screen space)
              const pts = [];
              const steps = 14;
              for(let t=0;t<=steps;t++){
                const tt = t/steps;
                const x = (1-tt)*(1-tt)*A.x + 2*(1-tt)*tt*CP.x + tt*tt*B.x;
                const y = (1-tt)*(1-tt)*A.y + 2*(1-tt)*tt*CP.y + tt*tt*B.y;
                const sp = screenFromWorld(x, y);
                pts.push({ sx: sp.sx, sy: sp.sy });
              }
              curveHitboxes.push({ aId:aM.id, bId:bM.id, chainId:cid, pageId:S.currentPageId, pts });

              // arrowhead: chevron, tangent-based trimming
              const ar = (aM.r ?? 10);
              const br = (bM.r ?? 10);
              const halfStroke = (lineW * 0.5);

              // tangent at start: CP - A
              let sdx = CP.x - A.x, sdy = CP.y - A.y;
              let slen = Math.hypot(sdx,sdy);
              if(slen < 1e-6){ sdx = B.x - A.x; sdy = B.y - A.y; slen = Math.hypot(sdx,sdy); }
              const sux = sdx / (slen||1), suy = sdy / (slen||1);

              // tangent at end: B - CP
              let edx = B.x - CP.x, edy = B.y - CP.y;
              let elen = Math.hypot(edx,edy);
              if(elen < 1e-6){ edx = B.x - A.x; edy = B.y - A.y; elen = Math.hypot(edx,edy); }
              const eux = edx / (elen||1), euy = edy / (elen||1);

              const startX = A.x + sux*(ar + halfStroke);
              const startY = A.y + suy*(ar + halfStroke);
              const endX   = B.x - eux*(br + halfStroke);
              const endY   = B.y - euy*(br + halfStroke);

              if(Math.hypot(endX-startX, endY-startY) >= 10){
                drawChevronArrowWorld(startX, startY, endX, endY, arrowSize);
              }
            }

            ctx.restore();
          }
        }

        // markers
        for(const m of visible){
          const p = worldFromNorm(m.x, m.y);
          const r = (m.r ?? 10);
          const col = markerColor(m);

          ctx.save();
          ctx.globalAlpha = m.dim ? 0.30 : 1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r, 0, Math.PI*2);
          ctx.fillStyle = col;
          ctx.fill();
          ctx.lineWidth = 2 / S.map.scale;
          ctx.strokeStyle = "rgba(0,0,0,.35)";
          ctx.stroke();
          ctx.restore();

          const num = (typeof m.chainIndex === "number" && m.chainIndex > 0) ? String(m.chainIndex) : "";
          if(num){
            const digits = num.length;
            const ratio = (digits===1) ? 1.20 : (digits===2 ? 1.00 : 0.86);
            const numFs = Math.max(1, Math.round(r * ratio));
            ctx.save();
            ctx.globalAlpha = 0.98;
            ctx.fillStyle = "rgba(0,0,0,.75)";
            ctx.font = `${m.fw ?? 900} ${numFs}px ui-sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(num, p.x, p.y);
            ctx.restore();
          }

          if(m.name){
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.fillStyle = m.labelColor || "#e7eef8";
            ctx.font = `${m.fw ?? 900} ${m.fs ?? 15}px ui-sans-serif`;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            const off = r + 8;
            ctx.fillText(m.name, p.x + off, p.y);
            ctx.restore();
          }

          const sp = screenFromWorld(p.x, p.y);
          circleHitboxes.push({ id:m.id, sx:sp.sx, sy:sp.sy, rPx: r*S.map.scale });
        }

        ctx.restore();
      }

      function pickCircleAt(sx, sy){
        let best=null, bestD=Infinity;
        for(const c of circleHitboxes){
          const d = Math.hypot(c.sx - sx, c.sy - sy);
          if(d <= c.rPx*1.25 && d < bestD){ best = c; bestD = d; }
        }
        return best;
      }

      // ✅ [MOD#5] pick curve segment at pointer (screen space)
      function distPointToSeg(px,py, ax,ay, bx,by){
        const vx = bx-ax, vy = by-ay;
        const wx = px-ax, wy = py-ay;
        const vv = vx*vx + vy*vy;
        if(vv < 1e-6) return Math.hypot(px-ax, py-ay);
        let t = (wx*vx + wy*vy) / vv;
        t = clamp(t, 0, 1);
        const cx = ax + vx*t;
        const cy = ay + vy*t;
        return Math.hypot(px-cx, py-cy);
      }
      function pickCurveAt(sx, sy){
        let best=null, bestD=Infinity;
        const thr = 10; // px
        for(const seg of curveHitboxes){
          const pts = seg.pts;
          for(let i=0;i<pts.length-1;i++){
            const d = distPointToSeg(sx,sy, pts[i].sx,pts[i].sy, pts[i+1].sx,pts[i+1].sy);
            if(d < bestD){
              bestD = d;
              best = seg;
            }
          }
        }
        if(best && bestD <= thr) return best;
        return null;
      }

      // ---------- pan/zoom + marker drag + curve drag ----------
      let isPanning=false, lastX=0,lastY=0;
      let draggingMarkerId = null;
      let dragStartSX=0, dragStartSY=0;
      let dragMoved = false;
      let dragPointerId = null;

      // ✅ [MOD#5] curve drag state
      let draggingCurve = null; // {aId,bId,chainId,pageId}
      let curveDirty = false;

      function screenToWorld(sx, sy){
        const wx = (sx - S.map.tx) / S.map.scale;
        const wy = (sy - S.map.ty) / S.map.scale;
        return { wx, wy };
      }
      function worldToNorm(wx, wy){
        const iw = S.map.naturalW || (mapImg.naturalWidth||1);
        const ih = S.map.naturalH || (mapImg.naturalHeight||1);
        return { nx: clamp(wx / iw, 0, 1), ny: clamp(wy / ih, 0, 1) };
      }

      cv.addEventListener("pointerdown", (e)=>{
        requireAuth();
        if(!isAuthed()) return;

        cv.setPointerCapture(e.pointerId);
        dragPointerId = e.pointerId;

        const rect = cv.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        lastX=e.clientX; lastY=e.clientY;

        // ✅ [MOD#5] 선(곡선) 히트 체크 → 곡선 편집
        const seg = pickCurveAt(sx, sy);
        if(seg){
          draggingCurve = { aId: seg.aId, bId: seg.bId, chainId: seg.chainId, pageId: seg.pageId };
          curveDirty = false;
          isPanning = false;
          draggingMarkerId = null;
          dragMoved = false;
          dragStartSX = sx; dragStartSY = sy;
          return;
        }

        const hit = pickCircleAt(sx, sy);
        if(hit){
          draggingMarkerId = hit.id;
          dragStartSX = sx;
          dragStartSY = sy;
          dragMoved = false;
          isPanning = false;
          return;
        }
        draggingMarkerId = null;
        isPanning = true;
      });

      cv.addEventListener("pointermove", (e)=>{
        if(dragPointerId !== e.pointerId) return;

        const rect = cv.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        // ✅ [MOD#5] curve drag
        if(draggingCurve){
          const dist = Math.hypot(sx - dragStartSX, sy - dragStartSY);
          if(dist > 2) curveDirty = true;

          const aM = S.markers.find(x=>x.id===draggingCurve.aId);
          const bM = S.markers.find(x=>x.id===draggingCurve.bId);
          if(!aM || !bM) return;

          const A = worldFromNorm(aM.x, aM.y);
          const B = worldFromNorm(bM.x, bM.y);

          const dx = B.x - A.x, dy = B.y - A.y;
          const len = Math.hypot(dx, dy);
          if(len < 1e-6) return;

          const ux = dx/len, uy = dy/len;
          const px = -uy, py = ux;

          const { wx, wy } = screenToWorld(sx, sy);
          const vx = wx - A.x, vy = wy - A.y;
          const along = (vx*ux + vy*uy) / len;
          const perp  = (vx*px + vy*py) / len;

          const sVal = clamp(along, 0.05, 0.95);
          const oVal = clamp(perp, -1.2, 1.2);

          setCurveParams(draggingCurve.pageId, draggingCurve.chainId, draggingCurve.aId, draggingCurve.bId, { s:sVal, o:oVal });

          draw();
          return;
        }

        if(draggingMarkerId){
          const dist = Math.hypot(sx - dragStartSX, sy - dragStartSY);
          if(dist > 3) dragMoved = true;

          const m = S.markers.find(x=>x.id===draggingMarkerId);
          if(!m) return;
          const { wx, wy } = screenToWorld(sx, sy);
          const { nx, ny } = worldToNorm(wx, wy);
          m.x = nx; m.y = ny;

          draw();
          return;
        }

        if(!isPanning) return;
        const dx=e.clientX-lastX, dy=e.clientY-lastY;
        lastX=e.clientX; lastY=e.clientY;
        S.map.tx += dx; S.map.ty += dy;
        draw();
      });

      cv.addEventListener("pointerup", ()=>{
        // curve end
        if(draggingCurve){
          if(curveDirty){
            saveLocal();
            toast("곡선 저장");
          }
          draggingCurve = null;
          dragPointerId = null;
          curveDirty = false;
          draw();
          return;
        }

        if(draggingMarkerId){
          const m = S.markers.find(x=>x.id===draggingMarkerId);
          if(m){
            if(!dragMoved){
              m.dim = !m.dim;
              selectedMarker = m;
              syncSelectedPanel();
              toast(m.dim ? "불투명화" : "불투명 해제");
            }else{
              toast("마커 이동 완료");
            }
            saveLocal();
          }
          draggingMarkerId = null;
          dragPointerId = null;
          dragMoved = false;
          draw();
          return;
        }

        isPanning=false;
        dragPointerId = null;
      });

      cv.addEventListener("pointercancel", ()=>{
        draggingCurve = null;
        draggingMarkerId = null;
        isPanning=false;
        dragPointerId = null;
        curveDirty = false;
      });

      cv.addEventListener("wheel", (e)=>{
        e.preventDefault();
        const rect = cv.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const old = S.map.scale || 1;
        const zoom = Math.exp(-e.deltaY * 0.0012);
        const next = clamp(old * zoom, 0.05, 10);
        const wx = (mx - S.map.tx) / old;
        const wy = (my - S.map.ty) / old;
        S.map.scale = next;
        S.map.tx = mx - wx * next;
        S.map.ty = my - wy * next;
        draw();
      }, {passive:false});

      // ---------- marker create / select ----------
      let selectedMarker = null;
      let insertAfterMarkerId = null;

      function nextOrderForPage(pageId){
        const ms = (S.markers||[]).filter(m=>m.pageId===pageId);
        const max = ms.reduce((acc,m)=>Math.max(acc, (m.order||0)), 0);
        return max + 1;
      }

      function newMarkerAt(normX, normY){
        const pageId = S.currentPageId;
        const m = {
          id:"m_"+uid(),
          pageId:pageId,
          x:normX, y:normY,
          name:"",
          cat: (S.categories.find(c=>c.on && c.id!=="전체")?.id) || "기텔",
          colorOverride:"",
          useCatColor:true,
          yt:"",
          ytTitle:"",
          memo:"",
          r:10, fs:15, fw:900,
          labelColor:"#e7eef8",
          order: nextOrderForPage(pageId),
          dim:false,
          chainId:null,
          chainIndex:null,
        };

        if(insertAfterMarkerId){
          const base = S.markers.find(x=>x.id===insertAfterMarkerId);
          if(base && base.pageId===m.pageId){
            m.chainId = ensureMarkerChain(base);
            const insertAt = (base.order||0) + 1;
            for(const mm of S.markers){
              if(mm.pageId===m.pageId && (mm.order||0) >= insertAt){
                mm.order = (mm.order||0) + 1;
              }
            }
            m.order = insertAt;
            renumberPage(m.pageId);
          }
        }else{
          m.chainId = getActiveChainIdForPage(pageId);
        }
        ensureMarkerChain(m);

        S.markers.push(m);

        const leader = leaderOfCat(m.pageId, m.cat);
        if(leader && leader.id !== m.id){
          m.r = leader.r;
          m.fs = leader.fs;
          m.fw = leader.fw;
          m.labelColor = leader.labelColor;
          m.useCatColor = leader.useCatColor;
          m.colorOverride = leader.colorOverride || "";
        }

        renumberPage(pageId);
        recomputeChainIndices(pageId);

        applyAutoNamesForChainOnPage(pageId, ensureMarkerChain(m));
        applyAllCatStylesOnPage(pageId);
        applyAllChainStylesOnPage(pageId);

        saveLocal();
        selectMarker(m.id);
        renderKpi();
        draw();
      }

      function selectMarker(id){
        selectedMarker = S.markers.find(m=>m.id===id) || null;
        syncSelectedPanel();
      }

      function syncSelectedPanel(){
        $("selName").textContent = selectedMarker ? (selectedMarker.name || "(이름 없음)") : "(이름 없음)";
        $("selLink").value = selectedMarker ? (selectedMarker.yt || "") : "";
        $("selYtTitle").value = selectedMarker ? (selectedMarker.ytTitle || "") : "";
        $("btnOpenMarkerEdit").disabled = !selectedMarker;
        $("btnApplyQuick").disabled = !selectedMarker;
        $("btnUseCatColor").disabled = !selectedMarker;
      }

      function syncSelectedPanelLive(){
        if(!selectedMarker) return;
        $("selName").textContent = (selectedMarker.name || "(이름 없음)");
        $("selLink").value = selectedMarker.yt || "";
        $("selYtTitle").value = selectedMarker.ytTitle || "";
      }

      cv.addEventListener("click", (e)=>{
        requireAuth();
        if(!isAuthed()) return;
        if(dragMoved) return;
        const rect = cv.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        const hit = pickCircleAt(sx, sy);
        if(hit){
          selectMarker(hit.id);
          return;
        }
        selectedMarker = null;
        insertAfterMarkerId = null;
        syncSelectedPanel();
      });

      // right-click add marker
      cv.addEventListener("contextmenu", (e)=>{
        e.preventDefault();
        requireAuth();
        if(!isAuthed()) return;

        const rect = cv.getBoundingClientRect();
        const sx = e.clientX - rect.left;
        const sy = e.clientY - rect.top;

        const { wx, wy } = screenToWorld(sx, sy);
        const iw = S.map.naturalW || (mapImg.naturalWidth||1);
        const ih = S.map.naturalH || (mapImg.naturalHeight||1);
        const nx = clamp(wx / iw, 0, 1);
        const ny = clamp(wy / ih, 0, 1);

        newMarkerAt(nx, ny);
        toast("마커 추가");
      });

      $("selLink").addEventListener("input", ()=>{
        if(!selectedMarker) return;
        selectedMarker.yt = $("selLink").value.trim();
        saveLocal();
      });
      $("selYtTitle").addEventListener("input", ()=>{
        if(!selectedMarker) return;
        selectedMarker.ytTitle = $("selYtTitle").value;
        saveLocal();
      });
      $("btnOpenMarkerEdit").addEventListener("click", ()=>{
        if(!selectedMarker) return;
        openMarkerModal(selectedMarker.id);
      });

      // ---------- quick palette ----------
      const QUICK = [
        {name:"빨", c:"#ff3b30"},
        {name:"주", c:"#ff9500"},
        {name:"노", c:"#ffd60a"},
        {name:"초", c:"#34c759"},
        {name:"파", c:"#0a84ff"},
        {name:"흰", c:"#ffffff"},
        {name:"검", c:"#0b0b0f"},
      ];
      let pickedQuick = null;

      function renderPalette(){
        palette.innerHTML = "";
        for(const q of QUICK){
          const wrap = document.createElement("div");
          wrap.className = "swWrap";
          wrap.innerHTML = `<div class="sw" style="--c:${q.c}" title="${q.name}"></div><div class="swLabel">${q.name}</div>`;
          wrap.querySelector(".sw").addEventListener("click", ()=>{
            pickedQuick = q.c;
            toast("색상 선택");
          });
          palette.appendChild(wrap);
        }
      }

      $("btnApplyQuick").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        if(!selectedMarker){ toast("마커를 선택하세요"); return; }
        if(!pickedQuick){ toast("빠른 색상을 먼저 선택하세요"); return; }

        const cid = ensureMarkerChain(selectedMarker);
        const leader = leaderOfChain(S.currentPageId, cid);
        const target = leader || selectedMarker;
        target.colorOverride = pickedQuick;
        target.useCatColor = false;

        applyAllCatStylesOnPage(S.currentPageId);
        applyAllChainStylesOnPage(S.currentPageId);
        saveLocal();
        draw();
        toast("색상 적용");
      });

      $("btnUseCatColor").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        if(!selectedMarker){ toast("마커를 선택하세요"); return; }

        const cid = ensureMarkerChain(selectedMarker);
        const leader = leaderOfChain(S.currentPageId, cid);
        const target = leader || selectedMarker;
        target.colorOverride = "";
        target.useCatColor = true;

        applyAllCatStylesOnPage(S.currentPageId);
        applyAllChainStylesOnPage(S.currentPageId);
        saveLocal();
        draw();
        toast("카테고리 색상 적용");
      });

      $("btnClearLines").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        S.showLinesWithCatFilter = false;
        setChipToggle($("tgShowChainSameCat"), false);
        saveLocal();
        draw();
        toast("선 숨김");
      });

      $("btnRechain").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        renumberPage(S.currentPageId);
        recomputeChainIndices(S.currentPageId);
        S.showLinesWithCatFilter = true;
        setChipToggle($("tgShowChainSameCat"), true);
        applyAllCatStylesOnPage(S.currentPageId);
        applyAllChainStylesOnPage(S.currentPageId);
        saveLocal();
        draw();
        toast("선 표시");
      });

      $("btnResetMarkers").addEventListener("click", async ()=>{
        requireAuth();
        if(!isAuthed()) return;
        const ok = await openPopConfirm({
          anchor: $("btnResetMarkers"),
          title: "마커 초기화",
          message: "현재 페이지의 마커를 모두 삭제할까요?",
          okText: "삭제",
          cancelText: "취소",
          danger: true
        });
        if(!ok) return;
        const pid = S.currentPageId;
        S.markers = S.markers.filter(m=>m.pageId!==pid);
        S.chains = (S.chains||[]).filter(x => x && x.pageId !== pid);

        selectedMarker = null;
        insertAfterMarkerId = null;
        saveLocal();
        syncSelectedPanel();
        renderKpi();
        draw();
        toast("마커 초기화");
      });

      // ---------- marker modal ----------
      let editingId = null;
      function getEditing(){ return editingId ? (S.markers.find(x=>x.id===editingId) || null) : null; }

      function openMarkerModal(markerId){
        requireAuth();
        if(!isAuthed()) return;

        const m = S.markers.find(x=>x.id===markerId);
        if(!m) return;
        editingId = markerId;

        const sel = $("mfCat");
        sel.innerHTML = "";
        for(const c of S.categories){
          if(c.id==="전체") continue;
          const o = document.createElement("option");
          o.value = c.id;
          o.textContent = c.name;
          sel.appendChild(o);
        }

        $("mfName").value = m.name || "";
        $("mfCat").value = m.cat || "기텔";
        $("mfColor").value = m.colorOverride || "";
        $("mfUseCatColor").checked = !!m.useCatColor;
        $("mfYt").value = m.yt || "";
        $("mfYtTitle").value = m.ytTitle || "";
        $("mfMemo").value = m.memo || "";
        $("mfR").value = m.r ?? 10;
        $("mfFs").value = m.fs ?? 15;
        $("mfFw").value = String(m.fw ?? 900);
        $("mfLabelColor").value = m.labelColor || "#e7eef8";

        $("mfRVal").textContent = $("mfR").value;
        $("mfFsVal").textContent = $("mfFs").value;
        $("mfPos").textContent = `좌표(비율): ${m.x.toFixed(6)}, ${m.y.toFixed(6)}`;

        ytTouched = false;
        memoTouched = false;

        updateColorChip();
        mMarker.classList.add("show");
        setTimeout(()=>$("mfName").focus(), 0);
      }
      function closeMarkerModal(){
        mMarker.classList.remove("show");
        editingId = null;
      }
      $("btnCloseMarker").addEventListener("click", closeMarkerModal);
      $("btnSaveMarker").addEventListener("click", saveMarkerModal);
      $("btnDeleteMarker").addEventListener("click", deleteMarkerModal);

      mMarker.addEventListener("keydown", (e)=>{
        if(e.key==="Enter"){
          if(e.target && e.target.tagName==="TEXTAREA") return;
          e.preventDefault();
          saveMarkerModal();
        }
        if(e.key==="Escape"){ closeMarkerModal(); }
      });

      function updateColorChip(){
        const m = getEditing();
        if(!m) return;
        const chip = $("mfColorChip");
        const col = $("mfUseCatColor").checked ? (getCat($("mfCat").value)?.color || "#7cc4ff") : ($("mfColor").value || markerColor(m));
        chip.style.setProperty("--c", col);
      }
      $("mfColor").addEventListener("input", updateColorChip);
      $("mfUseCatColor").addEventListener("change", updateColorChip);
      $("mfCat").addEventListener("change", updateColorChip);

      let ytTouched = false, memoTouched = false;
      $("mfYtTitle").addEventListener("input", ()=>{ ytTouched = true; syncSelectedPanelLive(); });
      $("mfMemo").addEventListener("input", ()=>{ memoTouched = true; syncSelectedPanelLive(); });
      $("mfName").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.name = $("mfName").value;
        $("selName").textContent = m.name || "(이름 없음)";
      });

      $("mfYt").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.yt = $("mfYt").value.trim();
      });
      $("mfYtTitle").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.ytTitle = $("mfYtTitle").value;
      });
      $("mfMemo").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.memo = $("mfMemo").value;
      });

      $("mfR").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        const r = Number($("mfR").value);
        m.r = clamp(r, 2, 40);
        // 원 크기에 비례해서 글씨크기 기본 동기화
        const fs = Math.round(m.r * 1.5);
        m.fs = clamp(fs, 4, 80);
        $("mfRVal").textContent = String(m.r);
        $("mfFs").value = String(m.fs);
        $("mfFsVal").textContent = String(m.fs);
        draw();
      });
      $("mfFs").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.fs = clamp(Number($("mfFs").value), 4, 80);
        $("mfFsVal").textContent = String(m.fs);
        draw();
      });
      $("mfFw").addEventListener("change", ()=>{
        const m = getEditing();
        if(!m) return;
        m.fw = Number($("mfFw").value) || 900;
        draw();
      });
      $("mfLabelColor").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.labelColor = ($("mfLabelColor").value || "").trim() || "#e7eef8";
        draw();
      });
      $("mfLabelDefault").addEventListener("click", ()=>{
        const m = getEditing();
        if(!m) return;
        $("mfLabelColor").value = "#e7eef8";
        m.labelColor = "#e7eef8";
        draw();
      });

      const QUICK_TEXT = [
        "#e7eef8", "#ffffff", "#000000",
        "#ffd60a", "#ff5d5d", "#39d98a", "#7cc4ff",
        "#a86bff", "#ff9500"
      ];
      function renderTextColors(){
        textColors.innerHTML = "";
        for(const c of QUICK_TEXT){
          const el = document.createElement("div");
          el.className = "tSw";
          el.style.setProperty("--c", c);
          el.title = c;
          el.addEventListener("click", ()=>{
            const m = getEditing();
            if(!m) return;
            $("mfLabelColor").value = c;
            m.labelColor = c;
            draw();
            toast("글씨색 적용");
          });
          textColors.appendChild(el);
        }
      }

      $("mfUseCatColor").addEventListener("change", ()=>{
        const m = getEditing();
        if(!m) return;
        m.useCatColor = !!$("mfUseCatColor").checked;
        updateColorChip();
        draw();
      });
      $("mfCat").addEventListener("change", ()=>{
        const m = getEditing();
        if(!m) return;
        m.cat = $("mfCat").value;
        updateColorChip();
        draw();
      });
      $("mfColor").addEventListener("input", ()=>{
        const m = getEditing();
        if(!m) return;
        m.colorOverride = $("mfColor").value.trim();
        updateColorChip();
        draw();
      });

      $("btnNewChain").addEventListener("click", ()=>{
        const m = getEditing();
        if(!m) return;
        // 새로운 체인 생성 후, 이 마커를 새 체인의 1번으로
        const newId = "c" + uid();
        m.chainId = newId;
        setActiveChainIdForPage(m.pageId, newId);

        renumberPage(m.pageId);
        recomputeChainIndices(m.pageId);

        // 곡선은 체인/세그먼트 키 기반이므로 새 체인에는 기본값으로 시작
        applyAllCatStylesOnPage(m.pageId);
        applyAllChainStylesOnPage(m.pageId);
        saveLocal();
        draw();
        toast("새 번호 시작");
      });

      $("btnInsertAfter").addEventListener("click", ()=>{
        const m = getEditing();
        if(!m) return;
        insertAfterMarkerId = m.id;
        closeMarkerModal();
        toast("이 마커 뒤로 추가 모드");
      });

      function saveMarkerModal(){
        const m = getEditing();
        if(!m) return;

        m.name = ($("mfName").value || "");
        m.cat = $("mfCat").value || m.cat;
        m.useCatColor = !!$("mfUseCatColor").checked;
        m.colorOverride = ($("mfColor").value || "").trim();
        m.yt = ($("mfYt").value || "").trim();
        m.ytTitle = ($("mfYtTitle").value || "");
        m.memo = ($("mfMemo").value || "");

        m.r = clamp(Number($("mfR").value) || m.r || 10, 2, 40);
        m.fs = clamp(Number($("mfFs").value) || m.fs || 15, 4, 80);
        m.fw = Number($("mfFw").value) || m.fw || 900;
        m.labelColor = ($("mfLabelColor").value || "").trim() || "#e7eef8";

        // 스타일 전파 규칙 유지
        renumberPage(m.pageId);
        recomputeChainIndices(m.pageId);

        applyAutoNamesForChainOnPage(m.pageId, ensureMarkerChain(m));
        applyAllCatStylesOnPage(m.pageId);
        applyAllChainStylesOnPage(m.pageId);

        selectedMarker = m;
        syncSelectedPanel();
        saveLocal();
        renderKpi();
        draw();
        toast("저장 완료");
        closeMarkerModal();
      }

      async function deleteMarkerModal(){
        const m = getEditing();
        if(!m) return;
        const ok = await openPopConfirm({
          anchor: $("btnDeleteMarker"),
          title: "삭제",
          message: `이 마커를 삭제할까요?`,
          okText: "삭제",
          cancelText: "취소",
          danger: true
        });
        if(!ok) return;

        const pid = m.pageId;
        // curves: 세그먼트 키가 마커ID를 포함하므로 해당 ID가 들어간 세그먼트 제거
        for(const ch of (S.chains||[])){
          if(!ch || ch.pageId !== pid || !ch.segs) continue;
          for(const k of Object.keys(ch.segs)){
            if(k.includes(m.id+"|") || k.includes("|"+m.id)) delete ch.segs[k];
          }
        }

        S.markers = (S.markers||[]).filter(x=>x.id!==m.id);
        renumberPage(pid);
        recomputeChainIndices(pid);

        selectedMarker = null;
        insertAfterMarkerId = null;
        saveLocal();
        syncSelectedPanel();
        renderKpi();
        draw();
        toast("삭제 완료");
        closeMarkerModal();
      }

      // ---------- category modal ----------
      const catRows = $("catRows");
      const catQuickPalette = $("catQuickPalette");
      let catEditing = [];
      let selectedCatRowIndex = -1;

      function openCatsModal(){
        requireAuth();
        if(!isAuthed()) return;
        catEditing = structuredClone(S.categories || structuredClone(defaultCats));
        selectedCatRowIndex = -1;
        renderCatModal();
        setChipToggle(tgShowLinesWithCatFilter, !!S.showLinesWithCatFilter);
        mCats.classList.add("show");
      }
      function closeCatsModal(){
        mCats.classList.remove("show");
      }

      $("btnEditCats").addEventListener("click", openCatsModal);
      $("btnCloseCats").addEventListener("click", closeCatsModal);

      function renderCatQuickPalette(){
        catQuickPalette.innerHTML = "";
        for(const q of QUICK){
          const wrap = document.createElement("div");
          wrap.className = "swWrap";
          wrap.innerHTML = `<div class="sw" style="--c:${q.c}" title="${q.name}"></div><div class="swLabel">${q.name}</div>`;
          wrap.querySelector(".sw").addEventListener("click", ()=>{
            if(selectedCatRowIndex < 0){ toast("카테고리 행 선택"); return; }
            const row = catEditing[selectedCatRowIndex];
            if(!row || row.id==="전체") return;
            row.color = q.c;
            renderCatRows();
            toast("색상 적용");
          });
          catQuickPalette.appendChild(wrap);
        }
      }

      function renderCatRows(){
        catRows.innerHTML = "";
        catEditing.forEach((c, idx)=>{
          const isAll = c.id==="전체";
          const row = document.createElement("div");
          row.className = "card";
          row.style.marginTop = "10px";
          row.style.borderColor = (idx===selectedCatRowIndex) ? "rgba(124,196,255,.55)" : "rgba(39,52,74,.6)";
          row.innerHTML = `
            <div class="sectionTitle" style="margin:0 0 10px 0;">
              <span>${isAll ? "전체(마스터)" : `카테고리 ${idx}`}</span>
              <span class="subtle">${isAll ? "삭제 불가" : "클릭하여 선택"}</span>
            </div>

            <div class="grid2">
              <div>
                <div class="labelRow">이름</div>
                <input class="field" data-k="name" value="${escapeHtml(c.name)}" ${isAll ? "disabled" : ""}/>
              </div>
              <div>
                <div class="labelRow">색상</div>
                <input class="field" data-k="color" value="${escapeHtml(c.color)}" ${isAll ? "disabled" : ""}/>
              </div>
            </div>

            <div class="labelRow" style="margin-top:10px;">표시</div>
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
              <div style="display:flex; align-items:center; gap:10px;">
                <div class="colorChip" style="--c:${escapeHtml(c.color)};"></div>
                <div class="subtle">${isAll ? "전체 OFF 시 전부 숨김" : "OFF 시 해당 카테고리 마커 숨김"}</div>
              </div>
              <div class="checkRow">
                <input type="checkbox" data-k="on" ${c.on ? "checked" : ""}/>
                <label class="subtle" style="cursor:pointer;">ON</label>
              </div>
            </div>

            ${isAll ? "" : `
              <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:12px;">
                <button class="btnBig danger" data-act="del">삭제</button>
              </div>
            `}
          `;

          row.addEventListener("click", ()=>{
            if(isAll) return;
            selectedCatRowIndex = idx;
            renderCatRows();
          });

          row.querySelectorAll("input.field").forEach(inp=>{
            inp.addEventListener("input", ()=>{
              const key = inp.getAttribute("data-k");
              if(!key) return;
              if(isAll) return;
              c[key] = inp.value;
              // id는 name 기반으로 다시 만들지 않고, 기존 id 유지(안정)
              // 단, 기본 동작상 name을 id로 쓰는 케이스가 있으므로, id도 같이 맞춤(전체 제외)
              if(key==="name"){
                const nm = (c.name||"").trim();
                if(nm) c.id = nm;
              }
              renderCatRows();
            });
          });

          const chk = row.querySelector('input[type="checkbox"][data-k="on"]');
          if(chk){
            chk.addEventListener("change", ()=>{
              c.on = !!chk.checked;
              // 전체 제외 최소1 보장 로직은 저장 시 한 번 더 체크
              renderCatRows();
            });
          }

          const delBtn = row.querySelector('[data-act="del"]');
          if(delBtn){
            delBtn.addEventListener("click", async (e)=>{
              e.stopPropagation();
              const ok = await openPopConfirm({
                anchor: delBtn,
                title: "카테고리 삭제",
                message: `"${c.name}" 카테고리를 삭제할까요?\n(해당 카테고리 마커는 숨김 처리될 수 있습니다)`,
                okText: "삭제",
                cancelText: "취소",
                danger: true
              });
              if(!ok) return;
              catEditing = catEditing.filter((x,i)=>i!==idx);
              selectedCatRowIndex = -1;
              renderCatRows();
              toast("삭제 완료");
            });
          }

          catRows.appendChild(row);
        });
      }

      function renderCatModal(){
        renderCatQuickPalette();
        renderCatRows();
      }

      $("btnAddCat").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        catEditing.push({ id:`새카테고리${catEditing.length}`, name:`새카테고리${catEditing.length}`, color:"#7cc4ff", on:true });
        selectedCatRowIndex = catEditing.length - 1;
        renderCatRows();
        toast("카테고리 추가");
      });

      $("btnCatsDefault").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;
        catEditing = structuredClone(defaultCats);
        selectedCatRowIndex = -1;
        renderCatRows();
        toast("기본값 복원");
      });

      $("btnSaveCats").addEventListener("click", ()=>{
        requireAuth();
        if(!isAuthed()) return;

        // normalize: 전체는 항상 존재/맨 앞
        const all = catEditing.find(c=>c.id==="전체") || structuredClone(defaultCats[0]);
        let rest = catEditing.filter(c=>c.id!=="전체");

        // sanitize: 공백 제거 + 중복 방지 (id 기준)
        const seen = new Set();
        rest = rest.filter(c=>{
          c.name = (c.name||"").trim();
          c.id = (c.id||c.name||"").trim();
          c.color = (c.color||"#7cc4ff").trim();
          if(!c.name || !c.id) return false;
          if(seen.has(c.id)) return false;
          seen.add(c.id);
          if(typeof c.on !== "boolean") c.on = true;
          return true;
        });

        // 최소 1개(전체 제외) ON 보장
        const anyOn = rest.some(c=>c.on);
        if(!anyOn && rest.length){
          rest[0].on = true;
        }

        all.on = (typeof all.on==="boolean") ? all.on : true;
        all.color = (all.color||"#7cc4ff").trim();
        all.name = "전체";
        all.id = "전체";

        S.categories = [all, ...rest];

        // marker cat 존재 보정: 없는 카테고리는 첫 카테고리(전체 제외)로 이동
        const fallbackCat = (S.categories.find(c=>c.id!=="전체")?.id) || "기텔";
        for(const m of (S.markers||[])){
          if(!S.categories.some(c=>c.id===m.cat)){
            m.cat = fallbackCat;
          }
        }

        saveLocal();
        renderCats();
        applyAllCatStylesOnPage(S.currentPageId);
        applyAllChainStylesOnPage(S.currentPageId);
        renderKpi();
        draw();
        closeCatsModal();
        toast("카테고리 저장");
      });

      // ---------- init ----------
      function renderAll(){
        renderLogo();
        renderSlotsTop();
        renderPages();
        renderCats();
        renderPalette();
        renderTextColors();
        setChipToggle(tgShowLinesWithCatFilter, !!S.showLinesWithCatFilter);
        syncSelectedPanel();
      }

      (async function init(){
        resizeCanvas();
        const st = await loadStateRemoteFirst();
        S = mergeState(st);
        ensureSlot1FromLegacy();
        saveLocal();
        renderAll();
        loadMap();
        renderKpi();
        draw();
        // 첫 진입 시 인증 필요 (기존 동작 유지)
        requireAuth();
      })();
    })();
  </script>
</body>
</html>
