<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE · ADMIN99</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --bg2:#050812;
      --panel:#0b1220cc;
      --panel2:#0b1220f0;
      --card:#0e1626cc;

      --stroke:#1f2a3a;
      --stroke2:#27344a;

      --text:#e7eef8;
      --muted:#9fb0c6;

      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r12:12px;
      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 10px 26px rgba(0,0,0,.42);
      --blur: 14px;

      --topH: 62px;
      --leftW: 250px;
      --rightW: 310px;

      --btnH: 40px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      font-family: var(--font);
      background: radial-gradient(1200px 700px at 20% 10%, #0c1733 0%, var(--bg) 45%, var(--bg2) 100%);
      color:var(--text);
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    /* Layout */
    .app{
      position:fixed; inset:0;
      display:grid;
      grid-template-rows: var(--topH) 1fr;
      grid-template-columns: var(--leftW) 1fr var(--rightW);
      grid-template-areas:
        "top top top"
        "left main right";
    }

    .topbar{
      grid-area: top;
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 12px;
      background: linear-gradient(180deg, #0b1220ee, #0b1220cc);
      border-bottom: 1px solid var(--stroke);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      box-shadow: 0 12px 32px rgba(0,0,0,.25);
      z-index: 50;
    }

    .sidebar{
      background: linear-gradient(180deg, #0b1220cc, #0b1220aa);
      border-right: 1px solid var(--stroke);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:hidden;
    }
    .sidebar.right{
      border-right:none;
      border-left: 1px solid var(--stroke);
    }

    .leftbar{ grid-area:left; }
    .rightbar{ grid-area:right; }
    .main{ grid-area:main; position:relative; overflow:hidden; background: transparent; }

    .canvasWrap{
      position:absolute; inset:0;
      overflow:hidden;
      background: radial-gradient(800px 420px at 60% 15%, rgba(124,196,255,.10) 0%, rgba(0,0,0,0) 55%),
                  radial-gradient(900px 500px at 35% 85%, rgba(57,217,138,.08) 0%, rgba(0,0,0,0) 60%);
    }
    canvas{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    /* Common UI */
    .logoBtn{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: linear-gradient(180deg, #0f1a2fcc, #0b1220cc);
      box-shadow: var(--shadow2);
      cursor:pointer;
      user-select:none;
      min-width: 170px;
    }
    .logoImg{
      width:34px; height:34px;
      border-radius: 10px;
      border: 1px solid var(--stroke2);
      background:#0a0f18;
      object-fit: contain;
    }
    .logoText{ display:flex; flex-direction:column; gap:2px; }
    .logoText .t1{ font-weight:800; letter-spacing:.2px; font-size:14px; }
    .logoText .t2{ font-size:12px; color:var(--muted); }

    .pill{
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke2);
      background: #0b1220cc;
      color: var(--muted);
      font-size: 12px;
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    .btn{
      height: var(--btnH);
      padding: 0 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: linear-gradient(180deg, #0f1a2f, #0b1220);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
    }
    .btn:hover{ filter: brightness(1.06); }
    .btn:active{ transform: translateY(1px); filter: brightness(0.98); }
    .btn.small{
      height: 34px;
      padding: 0 10px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 12px;
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }
    .btn.ghost{
      background: rgba(15,26,47,.35);
      box-shadow:none;
    }
    .btn.danger{
      border-color: rgba(255,93,93,.55);
      color: #ffd7d7;
      background: linear-gradient(180deg, rgba(255,93,93,.20), rgba(15,26,47,.55));
    }
    .btn.ok{
      border-color: rgba(57,217,138,.55);
      color:#d9ffe8;
      background: linear-gradient(180deg, rgba(57,217,138,.18), rgba(15,26,47,.55));
    }

    .spacer{ flex: 1; }

    /* Top categories (4 slots) */
    .slots{
      display:flex;
      gap:10px;
      align-items:stretch;
      flex-wrap:nowrap;
      overflow:auto hidden;
      padding-bottom: 2px;
      scrollbar-width: thin;
    }
    .slots::-webkit-scrollbar{ height: 8px; }
    .slots::-webkit-scrollbar-thumb{ background: rgba(39,52,74,.75); border-radius: 999px; }

    .slot{
      min-width: 240px;
      max-width: 340px;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px 10px;
      border-radius: 16px;
      border: 1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(11,18,32,.60));
      box-shadow: var(--shadow2);
    }
    .slotTop{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .slotTitle{
      flex:1;
      display:flex;
      gap:8px;
      align-items:center;
      min-width:0;
    }
    .slotTitle input{
      width:100%;
      min-width:0;
      height: 34px;
      border-radius: 12px;
      border:1px solid var(--stroke2);
      background: rgba(7,11,18,.55);
      color:var(--text);
      padding:0 10px;
      font-weight:800;
      outline:none;
    }
    .slotTitle input::placeholder{ color: rgba(159,176,198,.55); font-weight:700; }
    .slotBody{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .sublist{
      display:flex;
      flex-direction:column;
      gap:6px;
      max-height: 120px;
      overflow:auto;
      padding-right: 2px;
      scrollbar-width: thin;
    }
    .sublist::-webkit-scrollbar{ width: 8px; }
    .sublist::-webkit-scrollbar-thumb{ background: rgba(39,52,74,.75); border-radius: 999px; }

    .subitem{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .subitem button{ flex:0 0 auto; }
    .subitem .subbtn{
      width: 100%;
      justify-content: flex-start;
      font-weight:800;
      border-radius: 12px;
      background: rgba(15,26,47,.45);
      box-shadow:none;
      height: 34px;
      border: 1px solid var(--stroke2);
      padding: 0 10px;
      cursor:pointer;
      color: var(--text);
      min-width:0;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
    }
    .subitem .subbtn.active{
      border-color: rgba(124,196,255,.55);
      box-shadow: 0 0 0 2px rgba(124,196,255,.12) inset;
    }

    /* Sidebars content */
    .sideInner{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px;
      overflow:hidden;
    }

    .section{
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(14,22,38,.62), rgba(11,18,32,.50));
      border-radius: 16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.24);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .sectionHeader{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--stroke);
      background: rgba(11,18,32,.65);
    }
    .sectionHeader .title{
      font-weight:900;
      font-size: 13px;
      letter-spacing: .2px;
      color: var(--text);
    }
    .sectionHeader .meta{
      font-size: 12px;
      color: var(--muted);
      margin-left:auto;
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      max-width: 55%;
    }

    .sectionBody{
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      overflow:auto;
      scrollbar-width: thin;
    }
    .sectionBody::-webkit-scrollbar{ width: 10px; }
    .sectionBody::-webkit-scrollbar-thumb{ background: rgba(39,52,74,.7); border-radius: 999px; border: 2px solid rgba(0,0,0,0); background-clip: padding-box; }

    .row{ display:flex; gap:8px; align-items:center; }
    .row.wrap{ flex-wrap:wrap; }
    .row .grow{ flex:1; }

    .input{
      width:100%;
      height: 38px;
      border-radius: 12px;
      border:1px solid var(--stroke2);
      background: rgba(7,11,18,.55);
      color:var(--text);
      padding: 0 10px;
      outline:none;
      font-weight: 700;
    }
    .input::placeholder{ color: rgba(159,176,198,.58); font-weight: 700; }

    .label{
      font-size:12px;
      color: var(--muted);
      font-weight: 800;
      letter-spacing: .2px;
    }
    .tiny{
      font-size:11px;
      color: rgba(159,176,198,.85);
      line-height: 1.35;
    }
    .divider{
      height:1px;
      background: var(--stroke);
      margin: 2px 0;
    }

    /* Pages list */
    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .card{
      border:1px solid var(--stroke2);
      border-radius: 14px;
      padding: 10px;
      background: rgba(7,11,18,.38);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .cardTop{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tag{
      font-size: 11px;
      padding: 5px 9px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(11,18,32,.55);
      color: var(--muted);
      font-weight: 900;
      letter-spacing:.2px;
      white-space:nowrap;
    }
    .pageBtn{
      width:100%;
      height: 38px;
      border-radius: 12px;
      border: 1px solid var(--stroke2);
      background: rgba(15,26,47,.45);
      color: var(--text);
      font-weight: 900;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 0 10px;
      gap:10px;
      box-shadow:none;
    }
    .pageBtn.active{
      border-color: rgba(124,196,255,.55);
      box-shadow: 0 0 0 2px rgba(124,196,255,.12) inset;
    }
    .pageBtn .name{
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pageBtn .hint{
      font-size: 11px;
      color: rgba(159,176,198,.82);
      font-weight: 800;
      white-space:nowrap;
    }

    /* Marker categories */
    .catPills{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .catBtn{
      height: 34px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(15,26,47,.45);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight: 900;
      color: var(--text);
      user-select:none;
    }
    .dot{
      width: 12px; height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 6px 14px rgba(0,0,0,.25);
      background: #ffffff;
    }
    .catBtn.off{
      opacity: .55;
      filter: grayscale(0.2);
    }
    .catBtn.active{
      border-color: rgba(124,196,255,.55);
      box-shadow: 0 0 0 2px rgba(124,196,255,.12) inset;
    }

    .colorGrid{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:8px;
    }
    .colorSwatch{
      width: 100%;
      height: 30px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background:#fff;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    /* Modals */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 200;
    }
    .overlay.show{ display:flex; }

    .modal{
      width:min(980px, 100%);
      max-height: min(92vh, 880px);
      overflow:hidden;
      border-radius: 18px;
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(14,22,38,.90), rgba(11,18,32,.82));
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      padding: 12px 14px;
      border-bottom:1px solid var(--stroke);
      display:flex;
      align-items:center;
      gap:10px;
      background: rgba(11,18,32,.75);
    }
    .modalHeader .title{
      font-size: 14px;
      font-weight: 1000;
      letter-spacing: .2px;
    }
    .modalHeader .sub{
      margin-left:auto;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
      max-width: 55%;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
    }
    .modalBody{
      padding: 12px 14px;
      overflow:auto;
      min-height:0;
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 12px;
    }
    .modalFooter{
      padding: 12px 14px;
      border-top:1px solid var(--stroke);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      background: rgba(11,18,32,.75);
    }
    .modal .panel{
      border:1px solid var(--stroke2);
      background: rgba(7,11,18,.36);
      border-radius: 16px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    .grid4{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; }
    .help{
      font-size:12px;
      color: rgba(159,176,198,.9);
      line-height: 1.45;
      font-weight: 700;
    }

    /* Login */
    .login{
      width:min(520px, 100%);
      border-radius: 18px;
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(14,22,38,.92), rgba(11,18,32,.84));
      box-shadow: var(--shadow);
      padding: 16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .login h2{
      margin:0;
      font-size: 16px;
      letter-spacing: .2px;
    }
    .login .desc{
      margin:0;
      color: var(--muted);
      font-weight: 700;
      font-size: 12px;
      line-height: 1.45;
    }

    /* Responsive */
    @media (max-width: 1060px){
      :root{ --leftW: 230px; --rightW: 290px; }
      .slot{ min-width: 220px; }
    }
    @media (max-width: 920px){
      :root{ --leftW: 220px; --rightW: 270px; }
      .logoBtn{ min-width: 150px; }
    }
    @media (max-width: 820px){
      :root{ --topH: 64px; --leftW: 210px; --rightW: 250px; }
      .modalBody{ grid-template-columns: 1fr; }
    }
    @media (max-width: 720px){
      :root{ --leftW: 0px; --rightW: 0px; --topH: 66px; }
      .leftbar, .rightbar{ display:none; }
      .app{
        grid-template-columns: 1fr;
        grid-template-areas:
          "top"
          "main";
      }
      .topbar{
        flex-wrap:wrap;
        height:auto;
        padding: 10px 10px 12px;
      }
      .slots{ width:100%; }
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: 16px;
      z-index: 300;
      background: rgba(11,18,32,.82);
      border: 1px solid var(--stroke2);
      border-radius: 999px;
      padding: 10px 14px;
      display:none;
      align-items:center;
      gap:10px;
      box-shadow: var(--shadow2);
      color: var(--text);
      font-weight: 900;
      font-size: 12px;
      max-width: min(92vw, 980px);
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
    }
    .toast.show{ display:flex; }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke2);
      background: rgba(7,11,18,.55);
      color: rgba(231,238,248,.92);
      font-weight: 900;
    }
  </style>
</head>

<body>
  <div class="app" id="app">
    <!-- TOP -->
    <div class="topbar">
      <div class="logoBtn" id="logoBtn" title="로고 클릭 → 로고 이미지 URL 등록">
        <img id="logoImg" class="logoImg" alt="logo" />
        <div class="logoText">
          <div class="t1">MAPMODE · ADMIN99</div>
          <div class="t2">로고 URL 설정</div>
        </div>
      </div>

      <div class="slots" id="slots"></div>

      <div class="spacer"></div>

      <button class="btn small" id="btnExport">state.json 내보내기</button>
      <button class="btn small danger" id="btnResetAll">전체 초기화</button>

      <div class="pill" title="관리자 인증(24시간 유지)">
        <span>관리자</span>
        <span class="kbd" id="authState">LOCK</span>
      </div>
      <button class="btn small ok" id="btnLogin">관리자 로그인</button>
    </div>

    <!-- LEFT -->
    <div class="sidebar leftbar">
      <div class="sideInner">
        <div class="section" style="min-height: 0;">
          <div class="sectionHeader">
            <div class="title">페이지</div>
            <div class="meta" id="breadcrumb">-</div>
          </div>

          <div class="sectionBody">
            <div class="row">
              <input class="input" id="pageName" placeholder="페이지 이름 (예: 페이지1)" />
            </div>
            <div class="row">
              <input class="input" id="pageUrl" placeholder="지도 이미지 URL (예: /assets/aion2/maps/map1.png)" />
            </div>
            <div class="row">
              <button class="btn small ok grow" id="btnAddPage">페이지 추가</button>
            </div>
            <div class="divider"></div>

            <div class="list" id="pageList"></div>

            <div class="divider"></div>
            <div class="help">
              • 페이지 버튼을 누르면 해당 지도 이미지가 로드됩니다.<br/>
              • URL은 GitHub Pages 경로(예: <span class="kbd">/assets/aion2/maps/</span> ...)를 권장합니다.
            </div>
          </div>
        </div>

        <div class="section" style="flex:1; min-height: 0;">
          <div class="sectionHeader">
            <div class="title">유튜브 링크</div>
            <div class="meta">선택 마커 기준</div>
          </div>
          <div class="sectionBody">
            <div class="label">유튜브 링크</div>
            <input class="input" id="ytTitle" placeholder="유튜브 표시명" />
            <input class="input" id="ytDesc" placeholder="유튜브 설명(텍스트)" />
            <input class="input" id="ytUrl" placeholder="유튜브 링크 URL" />
            <div class="row">
              <button class="btn small ok grow" id="btnApplyYT">선택 마커에 적용</button>
            </div>
            <div class="divider"></div>
            <div class="help">
              • 유저 페이지(index.html)에서는 이 정보가 클릭 가능한 링크로 표시됩니다.<br/>
              • 선택한 마커가 없으면 적용되지 않습니다.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- MAIN -->
    <div class="main">
      <div class="canvasWrap">
        <canvas id="c"></canvas>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="sidebar rightbar">
      <div class="sideInner">
        <div class="section" style="min-height: 0;">
          <div class="sectionHeader">
            <div class="title">마커 카테고리</div>
            <div class="meta">전체/그룹 토글</div>
          </div>
          <div class="sectionBody">
            <div class="row wrap">
              <button class="btn small" id="btnToggleAllMarkers">전체</button>
              <button class="btn small ghost" id="btnOpenCatEditor">카테고리/색상 편집</button>
            </div>
            <div class="catPills" id="catPills"></div>
            <div class="divider"></div>
            <div class="help">
              • 카테고리별 마커는 항상 함께 활성/비활성 됩니다.<br/>
              • 카테고리 색/기본 크기는 “카테고리 1번 마커” 기준으로 동기화됩니다.
            </div>
          </div>
        </div>

        <div class="section" style="min-height: 0;">
          <div class="sectionHeader">
            <div class="title">관리자 툴</div>
            <div class="meta" id="selectedMarkerName">선택 마커: -</div>
          </div>
          <div class="sectionBody">
            <div class="label">빠른 색상표</div>
            <div class="colorGrid" id="quickColors"></div>

            <div class="divider"></div>

            <div class="row wrap">
              <button class="btn small" id="btnShowAllLines">모든 선 표시</button>
              <button class="btn small" id="btnHideAllLines">모든 선 제거</button>
            </div>

            <div class="row wrap">
              <button class="btn small danger" id="btnResetMarkers">마커 초기화</button>
              <button class="btn small" id="btnHideNumbers">마커 숫자 가리기</button>
              <button class="btn small ghost" id="btnOpenMarkerEditor">마커 편집</button>
            </div>

            <div class="divider"></div>

            <div class="help">
              • <span class="kbd">좌클릭 드래그</span>: 지도 이동 / 마커 이동<br/>
              • <span class="kbd">우클릭</span>: 마커 추가(번호 순서대로 선 연결 + 화살표)<br/>
              • <span class="kbd">더블클릭</span>: 마커 편집창 오픈<br/>
              • <span class="kbd">휠</span>: 확대/축소
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- LOGIN OVERLAY -->
  <div class="overlay" id="loginOverlay">
    <div class="login">
      <h2>관리자 로그인</h2>
      <p class="desc">
        비밀번호 입력 후 로그인하면 <b>24시간</b> 동안 인증이 유지됩니다.<br/>
        비밀번호: <span class="kbd">0000000001</span>
      </p>
      <input class="input" id="loginPw" type="password" placeholder="비밀번호 입력" autocomplete="current-password" />
      <div class="row">
        <button class="btn ok grow" id="btnDoLogin">로그인</button>
        <button class="btn ghost" id="btnCancelLogin">닫기</button>
      </div>
      <div class="help" style="margin-top:6px;">
        • 인증정보는 브라우저 LocalStorage에 저장됩니다.<br/>
        • GitHub Pages에서 운영 시, public 상태 파일(state.json)은 누구나 조회 가능합니다.
      </div>
    </div>
  </div>

  <!-- MARKER EDITOR MODAL -->
  <div class="overlay" id="markerOverlay">
    <div class="modal">
      <div class="modalHeader">
        <div class="title">마커 편집</div>
        <div class="sub" id="markerModalSub">-</div>
        <button class="btn small ghost" id="btnCloseMarkerModal">닫기</button>
      </div>

      <div class="modalBody">
        <div class="panel">
          <div class="label">기본</div>
          <div class="grid2">
            <div>
              <div class="label">마커 이름</div>
              <input class="input" id="mName" placeholder="예: 마커1" />
            </div>
            <div>
              <div class="label">카테고리</div>
              <select class="input" id="mCat"></select>
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">유튜브 표시명 (index에서 표시)</div>
              <input class="input" id="mYtTitle" placeholder="기본: 마커 이름과 동일" />
            </div>
            <div>
              <div class="label">유튜브 링크 URL</div>
              <input class="input" id="mYtUrl" placeholder="https://..." />
            </div>
          </div>

          <div>
            <div class="label">유튜브 설명</div>
            <input class="input" id="mYtDesc" placeholder="설명 텍스트" />
          </div>

          <div class="divider"></div>

          <div class="label">크기/텍스트</div>
          <div class="grid3">
            <div>
              <div class="label">마커 원 크기(px 1~100)</div>
              <input class="input" id="mSize" type="number" min="1" max="100" />
            </div>
            <div>
              <div class="label">마커 텍스트 크기(px)</div>
              <input class="input" id="mTextSize" type="number" min="1" max="200" />
            </div>
            <div>
              <div class="label">텍스트 굵기</div>
              <select class="input" id="mWeight">
                <option value="400">400</option>
                <option value="600">600</option>
                <option value="700">700</option>
                <option value="800">800</option>
                <option value="900">900</option>
              </select>
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">글씨 색(HEX)</div>
              <input class="input" id="mTextColor" placeholder="#ffffff" />
            </div>
            <div>
              <div class="label">빠른 색상표</div>
              <div class="colorGrid" id="mQuickColors" style="grid-template-columns: repeat(7, 1fr);"></div>
            </div>
          </div>

          <div class="help">
            • 마커 이름을 입력하면 “유튜브 표시명”이 비어있는 경우 자동으로 동일하게 채웁니다.<br/>
            • 마커 원 크기를 변경하면 텍스트 크기도 같은 비율로 함께 조정됩니다.
          </div>
        </div>

        <div class="panel">
          <div class="label">체인/번호 시작</div>
          <div class="help">
            • 우클릭으로 마커가 이어질 때 번호는 <b>1,2,3...</b>로 순서대로 생성됩니다.<br/>
            • 아래 버튼으로 “새로운 번호로 시작” 또는 “해당 마커 이어서 시작”을 설정합니다.
          </div>

          <div class="row wrap">
            <button class="btn small" id="btnStartNewChain">새로운 번호로 시작</button>
            <button class="btn small ok" id="btnContinueFromHere">해당 마커를 이어서 시작</button>
          </div>

          <div class="divider"></div>

          <div class="label">곡선 편집(드래그)</div>
          <div class="help">
            • 마커-마커 선(곡선)을 마우스로 드래그하면 곡선이 됩니다.<br/>
            • 선 위(가까운 지점)를 드래그하면 제어점이 이동하여 곡선이 조정됩니다.<br/>
            • 화살표는 곡선의 방향(후순위 번호 방향)에 맞춰 자동 정렬됩니다.
          </div>

          <div class="divider"></div>

          <div class="label">주의</div>
          <div class="help">
            • 카테고리별 마커 스타일(색/크기)은 “카테고리의 1번 마커” 기준으로 동기화됩니다.<br/>
            • 카테고리 색을 바꾸면 같은 카테고리의 이어지는 마커도 모두 동일하게 반영됩니다.
          </div>
        </div>
      </div>

      <div class="modalFooter">
        <button class="btn ghost" id="btnDeleteMarker">마커 삭제</button>
        <button class="btn ok" id="btnSaveMarker">저장</button>
      </div>
    </div>
  </div>

  <!-- CATEGORY EDITOR MODAL -->
  <div class="overlay" id="catOverlay">
    <div class="modal" style="width:min(880px, 100%);">
      <div class="modalHeader">
        <div class="title">카테고리/색상 편집</div>
        <div class="sub" id="catModalSub">-</div>
        <button class="btn small ghost" id="btnCloseCatModal">닫기</button>
      </div>

      <div class="modalBody">
        <div class="panel">
          <div class="label">카테고리 목록</div>
          <div class="row">
            <input class="input" id="newCatName" placeholder="새 카테고리 이름" />
            <button class="btn small ok" id="btnAddCat">추가</button>
          </div>
          <div class="divider"></div>
          <div class="list" id="catList"></div>
        </div>

        <div class="panel">
          <div class="label">빠른 색상표</div>
          <div class="colorGrid" id="catQuickColors" style="grid-template-columns: repeat(7, 1fr);"></div>

          <div class="divider"></div>

          <div class="label">직접 색상 지정(HEX)</div>
          <input class="input" id="catHex" placeholder="#ffffff" />
          <div class="row">
            <button class="btn small ok grow" id="btnApplyCatColor">선택 카테고리에 적용</button>
          </div>

          <div class="divider"></div>

          <div class="help">
            • 카테고리 색을 바꾸면 해당 카테고리의 마커 원 색이 모두 동일하게 적용됩니다.<br/>
            • “카테고리의 1번 마커”가 존재하면 그 마커의 크기/텍스트 스타일이 기준이 됩니다.
          </div>
        </div>
      </div>

      <div class="modalFooter">
        <button class="btn ghost" id="btnCloseCatModal2">닫기</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    /*****************************************************************
     * ✅ ABSOLUTE FIXED SETTINGS (ADMIN99)
     *****************************************************************/
    const LS_AUTH_KEY = "mapmode_admin_auth_v99";
    const LS_KEY = "mapmode_state_v99";
    const PASSWORD = "0000000001";
    const AUTH_MS = 24 * 60 * 60 * 1000; // 24h
    const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

    /*****************************************************************
     * Utilities
     *****************************************************************/
    const $ = (sel, el=document) => el.querySelector(sel);
    const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const now = () => Date.now();
    const deepClone = (o) => JSON.parse(JSON.stringify(o));

    function safeParseJSON(txt){
      try{ return JSON.parse(txt); }catch(e){ return null; }
    }
    function uid(){
      return Math.random().toString(16).slice(2) + "-" + Math.random().toString(16).slice(2);
    }
    function normalizeHex(hex){
      if(!hex) return null;
      let h = (hex+"").trim();
      if(!h) return null;
      if(h[0] !== "#") h = "#"+h;
      if(/^#[0-9a-fA-F]{3}$/.test(h)){
        const r=h[1], g=h[2], b=h[3];
        h = "#"+r+r+g+g+b+b;
      }
      if(!/^#[0-9a-fA-F]{6}$/.test(h)) return null;
      return h.toLowerCase();
    }
    function hexToRgba(hex, a=1){
      const h = normalizeHex(hex) || "#ffffff";
      const r=parseInt(h.slice(1,3),16);
      const g=parseInt(h.slice(3,5),16);
      const b=parseInt(h.slice(5,7),16);
      return `rgba(${r},${g},${b},${a})`;
    }

    const QUICK_COLORS = [
      "#ff5d5d", "#ff9f43", "#ffd60a", "#39d98a", "#4c9aff", "#ffffff", "#000000"
    ];

    function toast(msg){
      const t = $("#toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toast._tm);
      toast._tm = setTimeout(()=>t.classList.remove("show"), 2200);
    }

    /*****************************************************************
     * State Model (admin)
     *****************************************************************/
    const DEFAULT_STATE = {
      version: 99,
      savedAt: 0,
      logoUrl: "/assets/logo/MAPMODELOGO2.png",
      ui: {
        activeSlot: 0,
        activeGameId: null,
        activePageId: null,
        allMarkersVisible: true,
        linesVisible: true,
        selectedCatId: null,
        hideNumbersByCat: {}, // catId -> boolean
      },
      slots: [
        { id: uid(), name: "카테고리1", games: [] },
        { id: uid(), name: "카테고리2", games: [] },
        { id: uid(), name: "카테고리3", games: [] },
        { id: uid(), name: "카테고리4", games: [] },
      ],
      games: {
        // gameId: { id, name, slotIndex, pages[], markerCats[], markersByPage{} }
      }
    };

    function ensureGame(state, slotIndex, gameName){
      const slot = state.slots[slotIndex];
      if(!slot) return null;

      let gameId = slot.games.find(g => g && g.id && g.name === gameName)?.id;
      if(gameId && state.games[gameId]) return state.games[gameId];

      const g = {
        id: uid(),
        name: gameName || `게임${slot.games.length+1}`,
        slotIndex,
        pages: [],
        markerCats: [
          { id: uid(), name: "기본", color: "#7cc4ff", enabled: true }
        ],
        markersByPage: {
          // pageId: [markers]
        },
        chain: {
          // per page: { anchorMarkerId, nextNum, chainIdSeed }
          perPage: {}
        }
      };
      state.games[g.id] = g;
      slot.games.push({ id: g.id, name: g.name });
      return g;
    }

    function ensurePage(game, name, url){
      const p = { id: uid(), name: name || `페이지${game.pages.length+1}`, url: url || "" };
      game.pages.push(p);
      if(!game.markersByPage[p.id]) game.markersByPage[p.id] = [];
      if(!game.chain.perPage[p.id]){
        game.chain.perPage[p.id] = {
          anchorMarkerId: null, // marker to continue from
          nextNum: 1,
          chainIdSeed: uid()
        };
      }
      return p;
    }

    function getActiveGame(){
      const gid = state.ui.activeGameId;
      return gid && state.games[gid] ? state.games[gid] : null;
    }
    function getActivePage(game){
      if(!game) return null;
      const pid = state.ui.activePageId;
      return game.pages.find(p=>p.id===pid) || null;
    }

    function getMarkers(game, pageId){
      if(!game || !pageId) return [];
      if(!game.markersByPage[pageId]) game.markersByPage[pageId] = [];
      return game.markersByPage[pageId];
    }

    function getCat(game, catId){
      return game?.markerCats?.find(c=>c.id===catId) || null;
    }

    /*****************************************************************
     * Auth (24h)
     *****************************************************************/
    function isAuthed(){
      const raw = localStorage.getItem(LS_AUTH_KEY);
      const o = safeParseJSON(raw);
      if(!o || !o.ts) return false;
      return (now() - o.ts) <= AUTH_MS;
    }
    function setAuthed(){
      localStorage.setItem(LS_AUTH_KEY, JSON.stringify({ ts: now(), v: 99 }));
    }
    function clearAuth(){
      localStorage.removeItem(LS_AUTH_KEY);
    }

    /*****************************************************************
     * Persistence: local + remote load
     *****************************************************************/
    let state = deepClone(DEFAULT_STATE);

    function loadLocal(){
      const raw = localStorage.getItem(LS_KEY);
      const o = safeParseJSON(raw);
      if(!o || typeof o !== "object") return false;
      state = mergeState(deepClone(DEFAULT_STATE), o);
      return true;
    }

    function saveLocal(){
      state.savedAt = now();
      try{
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      }catch(e){
        console.warn(e);
      }
    }

    function mergeState(base, incoming){
      // Shallow-safe merge keeping base schema
      // For simplicity: prefer incoming fields when valid
      const out = base;

      if(incoming && typeof incoming === "object"){
        if(typeof incoming.version === "number") out.version = incoming.version;
        if(typeof incoming.savedAt === "number") out.savedAt = incoming.savedAt;
        if(typeof incoming.logoUrl === "string") out.logoUrl = incoming.logoUrl;

        if(incoming.ui && typeof incoming.ui === "object"){
          out.ui = { ...out.ui, ...incoming.ui };
          out.ui.hideNumbersByCat = incoming.ui.hideNumbersByCat && typeof incoming.ui.hideNumbersByCat === "object"
            ? { ...out.ui.hideNumbersByCat, ...incoming.ui.hideNumbersByCat }
            : out.ui.hideNumbersByCat;
        }

        if(Array.isArray(incoming.slots)){
          out.slots = incoming.slots.map((s, i)=>({
            id: (s && s.id) ? s.id : out.slots[i]?.id || uid(),
            name: (s && typeof s.name === "string") ? s.name : out.slots[i]?.name || `카테고리${i+1}`,
            games: Array.isArray(s?.games) ? s.games.filter(Boolean).map(g=>({ id: g.id||uid(), name: g.name||"게임" })) : []
          }));
          // ensure 4 slots
          while(out.slots.length < 4){
            out.slots.push({ id: uid(), name: `카테고리${out.slots.length+1}`, games: [] });
          }
          out.slots = out.slots.slice(0,4);
        }

        if(incoming.games && typeof incoming.games === "object"){
          out.games = {};
          for(const [gid, g] of Object.entries(incoming.games)){
            if(!g || typeof g !== "object") continue;
            out.games[gid] = {
              id: g.id || gid,
              name: typeof g.name === "string" ? g.name : "게임",
              slotIndex: Number.isFinite(g.slotIndex) ? g.slotIndex : 0,
              pages: Array.isArray(g.pages) ? g.pages.map(p=>({ id: p.id||uid(), name: p.name||"페이지", url: p.url||"" })) : [],
              markerCats: Array.isArray(g.markerCats) ? g.markerCats.map(c=>({
                id: c.id||uid(), name: c.name||"카테고리", color: normalizeHex(c.color)||"#7cc4ff", enabled: c.enabled !== false
              })) : [{ id: uid(), name: "기본", color:"#7cc4ff", enabled:true }],
              markersByPage: (g.markersByPage && typeof g.markersByPage === "object") ? g.markersByPage : {},
              chain: (g.chain && typeof g.chain === "object") ? g.chain : { perPage: {} }
            };

            // normalize markers
            const mbp = out.games[gid].markersByPage;
            for(const [pid, arr] of Object.entries(mbp)){
              if(!Array.isArray(arr)) mbp[pid] = [];
              mbp[pid] = (mbp[pid]||[]).filter(Boolean).map(m=>{
                const mm = {
                  id: m.id || uid(),
                  x: Number.isFinite(m.x) ? m.x : 0,
                  y: Number.isFinite(m.y) ? m.y : 0,
                  catId: m.catId || out.games[gid].markerCats[0]?.id,
                  num: Number.isFinite(m.num) ? m.num : 1,
                  chainId: m.chainId || "chain",
                  name: typeof m.name === "string" ? m.name : "",
                  ytTitle: typeof m.ytTitle === "string" ? m.ytTitle : "",
                  ytDesc: typeof m.ytDesc === "string" ? m.ytDesc : "",
                  ytUrl: typeof m.ytUrl === "string" ? m.ytUrl : "",
                  size: clamp(Number(m.size||24), 1, 100),
                  textSize: clamp(Number(m.textSize||12), 1, 200),
                  weight: String(m.weight||"800"),
                  textColor: normalizeHex(m.textColor)||"#ffffff",
                  visible: m.visible !== false,
                  dim: m.dim === true,
                  // curve control for connection from previous marker (within same chain)
                  ctrl: m.ctrl && Number.isFinite(m.ctrl.x) && Number.isFinite(m.ctrl.y) ? { x:m.ctrl.x, y:m.ctrl.y } : null,
                };
                return mm;
              });
            }

            // chain perPage normalize
            if(!out.games[gid].chain || typeof out.games[gid].chain !== "object") out.games[gid].chain = { perPage:{} };
            if(!out.games[gid].chain.perPage || typeof out.games[gid].chain.perPage !== "object") out.games[gid].chain.perPage = {};
            for(const p of out.games[gid].pages){
              if(!mbp[p.id]) mbp[p.id] = [];
              if(!out.games[gid].chain.perPage[p.id]){
                out.games[gid].chain.perPage[p.id] = { anchorMarkerId:null, nextNum:1, chainIdSeed: uid() };
              }else{
                const cp = out.games[gid].chain.perPage[p.id];
                cp.nextNum = Number.isFinite(cp.nextNum) ? cp.nextNum : 1;
                cp.chainIdSeed = cp.chainIdSeed || uid();
                cp.anchorMarkerId = cp.anchorMarkerId || null;
              }
            }
          }
        }
      }
      return out;
    }

    async function loadRemoteMerge(){
      try{
        const res = await fetch(REMOTE_STATE_URL.toString(), { cache:"no-store" });
        if(!res.ok) return false;
        const txt = await res.text();
        const o = safeParseJSON(txt);
        if(!o || typeof o !== "object") return false;

        // Remote is treated as baseline "shared"; merge remote -> current local, but preserve auth/local UI keys
        const localUI = deepClone(state.ui);
        const merged = mergeState(deepClone(DEFAULT_STATE), o);
        merged.ui = { ...merged.ui, ...localUI };
        state = merged;
        return true;
      }catch(e){
        console.warn(e);
        return false;
      }
    }

    function exportStateJson(){
      state.savedAt = now();
      const blob = new Blob([JSON.stringify(state, null, 2)], { type:"application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "state.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
      toast("state.json 내보내기 완료");
    }

    function resetAll(){
      if(!confirm("전체 초기화 하시겠습니까? (모든 게임/페이지/마커가 삭제됩니다)")) return;
      state = deepClone(DEFAULT_STATE);
      saveLocal();
      refreshAllUI();
      fitToImage();
      toast("전체 초기화 완료");
    }

    /*****************************************************************
     * UI References
     *****************************************************************/
    const elSlots = $("#slots");
    const elAuthState = $("#authState");
    const elLoginOverlay = $("#loginOverlay");
    const elLoginPw = $("#loginPw");
    const elBtnLogin = $("#btnLogin");
    const elBtnDoLogin = $("#btnDoLogin");
    const elBtnCancelLogin = $("#btnCancelLogin");

    const elLogoBtn = $("#logoBtn");
    const elLogoImg = $("#logoImg");

    const elBreadcrumb = $("#breadcrumb");

    const elPageName = $("#pageName");
    const elPageUrl = $("#pageUrl");
    const elBtnAddPage = $("#btnAddPage");
    const elPageList = $("#pageList");

    const elCatPills = $("#catPills");
    const elBtnToggleAllMarkers = $("#btnToggleAllMarkers");
    const elBtnOpenCatEditor = $("#btnOpenCatEditor");

    const elQuickColors = $("#quickColors");
    const elBtnShowAllLines = $("#btnShowAllLines");
    const elBtnHideAllLines = $("#btnHideAllLines");
    const elBtnResetMarkers = $("#btnResetMarkers");
    const elBtnHideNumbers = $("#btnHideNumbers");
    const elBtnOpenMarkerEditor = $("#btnOpenMarkerEditor");
    const elSelectedMarkerName = $("#selectedMarkerName");

    const elBtnExport = $("#btnExport");
    const elBtnResetAll = $("#btnResetAll");

    // Left youtube fields
    const elYtTitle = $("#ytTitle");
    const elYtDesc = $("#ytDesc");
    const elYtUrl = $("#ytUrl");
    const elBtnApplyYT = $("#btnApplyYT");

    // Marker modal
    const elMarkerOverlay = $("#markerOverlay");
    const elMarkerModalSub = $("#markerModalSub");
    const elBtnCloseMarkerModal = $("#btnCloseMarkerModal");
    const elMName = $("#mName");
    const elMCat = $("#mCat");
    const elMYtTitle = $("#mYtTitle");
    const elMYtDesc = $("#mYtDesc");
    const elMYtUrl = $("#mYtUrl");
    const elMSize = $("#mSize");
    const elMTextSize = $("#mTextSize");
    const elMWeight = $("#mWeight");
    const elMTextColor = $("#mTextColor");
    const elMQuickColors = $("#mQuickColors");
    const elBtnStartNewChain = $("#btnStartNewChain");
    const elBtnContinueFromHere = $("#btnContinueFromHere");
    const elBtnDeleteMarker = $("#btnDeleteMarker");
    const elBtnSaveMarker = $("#btnSaveMarker");

    // Category modal
    const elCatOverlay = $("#catOverlay");
    const elCatModalSub = $("#catModalSub");
    const elBtnCloseCatModal = $("#btnCloseCatModal");
    const elBtnCloseCatModal2 = $("#btnCloseCatModal2");
    const elNewCatName = $("#newCatName");
    const elBtnAddCat = $("#btnAddCat");
    const elCatList = $("#catList");
    const elCatQuickColors = $("#catQuickColors");
    const elCatHex = $("#catHex");
    const elBtnApplyCatColor = $("#btnApplyCatColor");

    /*****************************************************************
     * Canvas + Viewport
     *****************************************************************/
    const canvas = $("#c");
    const ctx = canvas.getContext("2d");

    const view = {
      dpr: 1,
      w: 0,
      h: 0,
      panX: 0,
      panY: 0,
      zoom: 1,
      minZoom: 0.08,
      maxZoom: 6,
    };

    const bg = {
      img: new Image(),
      loaded: false,
      w: 0,
      h: 0,
      url: ""
    };

    let raf = 0;

    function resize(){
      view.dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      view.w = canvas.clientWidth;
      view.h = canvas.clientHeight;
      canvas.width = Math.floor(view.w * view.dpr);
      canvas.height = Math.floor(view.h * view.dpr);
      ctx.setTransform(view.dpr,0,0,view.dpr,0,0);
      requestRender();
    }

    function requestRender(){
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(render);
    }

    function worldToScreen(wx, wy){
      return {
        x: (wx * view.zoom) + view.panX,
        y: (wy * view.zoom) + view.panY
      };
    }
    function screenToWorld(sx, sy){
      return {
        x: (sx - view.panX) / view.zoom,
        y: (sy - view.panY) / view.zoom
      };
    }

    function fitToImage(){
      if(!bg.loaded) return;
      const margin = 40;
      const zw = (view.w - margin*2) / bg.w;
      const zh = (view.h - margin*2) / bg.h;
      view.zoom = clamp(Math.min(zw, zh), view.minZoom, view.maxZoom);
      view.panX = (view.w - bg.w * view.zoom) / 2;
      view.panY = (view.h - bg.h * view.zoom) / 2;
      requestRender();
    }

    function loadBackground(url){
      if(!url) return;
      bg.url = url;
      bg.loaded = false;
      bg.img.onload = () => {
        bg.loaded = true;
        bg.w = bg.img.naturalWidth || 1;
        bg.h = bg.img.naturalHeight || 1;
        fitToImage();
        toast("지도 이미지 로드 완료");
      };
      bg.img.onerror = () => {
        bg.loaded = false;
        toast("지도 이미지 로드 실패: URL 확인");
        requestRender();
      };
      bg.img.src = url;
    }

    /*****************************************************************
     * Interaction: Pan/Zoom + Markers + Curves
     *****************************************************************/
    const interaction = {
      isDown: false,
      downBtn: 0,
      downX: 0,
      downY: 0,
      lastX: 0,
      lastY: 0,
      dragging: null, // {type:"pan"|"marker"|"curve", id, ...}
      hoverMarkerId: null,
      selectedMarkerId: null,
      activeCurve: null, // {prevId, currId} for editing
    };

    function activeContext(){
      const game = getActiveGame();
      const page = getActivePage(game);
      return { game, page, markers: (game && page) ? getMarkers(game, page.id) : [] };
    }

    function markerRadius(m){
      return clamp(m.size || 24, 1, 100);
    }

    function findMarkerAtScreen(sx, sy){
      const { game, page, markers } = activeContext();
      if(!game || !page) return null;

      // consider visibility by category + overall toggle
      for(let i=markers.length-1; i>=0; i--){
        const m = markers[i];
        if(!m.visible) continue;
        if(!state.ui.allMarkersVisible) continue;
        const cat = getCat(game, m.catId);
        if(cat && cat.enabled === false) continue;

        const p = worldToScreen(m.x, m.y);
        const r = markerRadius(m) * view.zoom;
        const dx = sx - p.x, dy = sy - p.y;
        if(dx*dx + dy*dy <= (r*r)) return m;
      }
      return null;
    }

    // curve hit-test: find nearest segment between consecutive markers (within same chain)
    function findCurveNearScreen(sx, sy){
      const { game, page, markers } = activeContext();
      if(!game || !page) return null;
      if(!state.ui.linesVisible) return null;

      // build chains order by chainId then num ascending
      const visibleMarkers = markers.filter(m=>{
        if(!m.visible) return false;
        if(!state.ui.allMarkersVisible) return false;
        const cat = getCat(game, m.catId);
        if(cat && cat.enabled === false) return false;
        return true;
      });

      // group by chainId
      const byChain = new Map();
      for(const m of visibleMarkers){
        if(!byChain.has(m.chainId)) byChain.set(m.chainId, []);
        byChain.get(m.chainId).push(m);
      }

      const maxDist = 12; // px
      let best = null;
      let bestD = Infinity;

      for(const [chainId, arr] of byChain.entries()){
        arr.sort((a,b)=>a.num-b.num);
        for(let i=1;i<arr.length;i++){
          const prev = arr[i-1], cur = arr[i];
          const A = worldToScreen(prev.x, prev.y);
          const B = worldToScreen(cur.x, cur.y);

          // quadratic with control point if exists on current marker (cur.ctrl)
          const ctrlW = cur.ctrl ? cur.ctrl : { x:(prev.x+cur.x)/2, y:(prev.y+cur.y)/2 };
          const C = worldToScreen(ctrlW.x, ctrlW.y);

          // sample approximate distance
          const steps = 18;
          let minLocal = Infinity;
          for(let t=0;t<=steps;t++){
            const u=t/steps;
            const q = quadPoint(A,C,B,u);
            const dx=sx-q.x, dy=sy-q.y;
            const d=Math.hypot(dx,dy);
            if(d<minLocal) minLocal=d;
          }
          if(minLocal < bestD && minLocal <= maxDist){
            bestD = minLocal;
            best = { prevId: prev.id, currId: cur.id };
          }
        }
      }
      return best;
    }

    function quadPoint(A,C,B,t){
      const mt = 1-t;
      return {
        x: mt*mt*A.x + 2*mt*t*C.x + t*t*B.x,
        y: mt*mt*A.y + 2*mt*t*C.y + t*t*B.y
      };
    }
    function quadTangent(A,C,B,t){
      // derivative of quadratic bezier
      return {
        x: 2*(1-t)*(C.x-A.x) + 2*t*(B.x-C.x),
        y: 2*(1-t)*(C.y-A.y) + 2*t*(B.y-C.y),
      };
    }

    function onPointerDown(e){
      if(!isAuthed()){
        openLogin();
        return;
      }
      canvas.setPointerCapture(e.pointerId);
      interaction.isDown = true;
      interaction.downBtn = e.button;
      interaction.downX = interaction.lastX = e.clientX;
      interaction.downY = interaction.lastY = e.clientY;

      const hitMarker = findMarkerAtScreen(e.clientX, e.clientY);

      if(e.button === 0){
        if(hitMarker){
          // start dragging marker OR toggle dim on click (decide on up if no move)
          interaction.dragging = { type:"marker", id: hitMarker.id, startX: hitMarker.x, startY: hitMarker.y, moved:false };
          interaction.selectedMarkerId = hitMarker.id;
          syncSelectedMarkerUI();
          requestRender();
        }else{
          // maybe curve drag? (allow left-drag on curve to edit)
          const curve = findCurveNearScreen(e.clientX, e.clientY);
          if(curve){
            interaction.dragging = { type:"curve", prevId: curve.prevId, currId: curve.currId, moved:true };
            interaction.activeCurve = curve;
            requestRender();
          }else{
            interaction.dragging = { type:"pan" };
          }
        }
      }
    }

    function onPointerMove(e){
      const dx = e.clientX - interaction.lastX;
      const dy = e.clientY - interaction.lastY;
      interaction.lastX = e.clientX;
      interaction.lastY = e.clientY;

      // hover marker
      const hm = findMarkerAtScreen(e.clientX, e.clientY);
      interaction.hoverMarkerId = hm ? hm.id : null;

      if(!interaction.isDown || !interaction.dragging){
        requestRender();
        return;
      }

      if(interaction.dragging.type === "pan"){
        view.panX += dx;
        view.panY += dy;
        requestRender();
      }else if(interaction.dragging.type === "marker"){
        const { game, page, markers } = activeContext();
        if(!game || !page) return;
        const m = markers.find(mm=>mm.id===interaction.dragging.id);
        if(!m) return;

        const w0 = screenToWorld(interaction.downX, interaction.downY);
        const w1 = screenToWorld(e.clientX, e.clientY);

        const movedX = (w1.x - w0.x);
        const movedY = (w1.y - w0.y);
        if(Math.hypot(movedX*view.zoom, movedY*view.zoom) > 2) interaction.dragging.moved = true;

        m.x = interaction.dragging.startX + movedX;
        m.y = interaction.dragging.startY + movedY;

        // if marker is anchor for chain continuation, keep it
        saveLocal();
        requestRender();
      }else if(interaction.dragging.type === "curve"){
        const { game, page, markers } = activeContext();
        if(!game || !page) return;

        const prev = markers.find(mm=>mm.id===interaction.dragging.prevId);
        const cur = markers.find(mm=>mm.id===interaction.dragging.currId);
        if(!prev || !cur) return;

        const w = screenToWorld(e.clientX, e.clientY);
        // store ctrl on current marker
        cur.ctrl = { x: w.x, y: w.y };
        saveLocal();
        requestRender();
      }else{
        requestRender();
      }
    }

    function onPointerUp(e){
      if(!interaction.isDown) return;
      interaction.isDown = false;

      const drag = interaction.dragging;
      interaction.dragging = null;

      if(drag && drag.type === "marker"){
        const { game, page, markers } = activeContext();
        if(game && page){
          const m = markers.find(mm=>mm.id===drag.id);
          if(m){
            if(!drag.moved){
              // toggle dim for this marker only
              m.dim = !m.dim;
              interaction.selectedMarkerId = m.id;
              syncSelectedMarkerUI();
              saveLocal();
              requestRender();
            }else{
              // moved
              saveLocal();
            }
          }
        }
      }

      requestRender();
    }

    function onDblClick(e){
      if(!isAuthed()){
        openLogin();
        return;
      }
      const hit = findMarkerAtScreen(e.clientX, e.clientY);
      if(hit){
        interaction.selectedMarkerId = hit.id;
        syncSelectedMarkerUI();
        openMarkerEditor(hit.id);
      }
    }

    function onContextMenu(e){
      e.preventDefault();
      if(!isAuthed()){
        openLogin();
        return;
      }

      const { game, page, markers } = activeContext();
      if(!game || !page){
        toast("게임/페이지를 먼저 선택하세요");
        return;
      }

      const w = screenToWorld(e.clientX, e.clientY);

      // determine chain info for this page
      const chainInfo = game.chain.perPage[page.id] || (game.chain.perPage[page.id] = { anchorMarkerId:null, nextNum:1, chainIdSeed: uid() });

      let chainId = chainInfo.chainIdSeed;
      let nextNum = chainInfo.nextNum;

      // if continuing from marker, keep chainId and nextNum based on that marker
      if(chainInfo.anchorMarkerId){
        const anchor = markers.find(m=>m.id===chainInfo.anchorMarkerId);
        if(anchor){
          chainId = anchor.chainId;
          // nextNum is max num within that chain + 1
          const maxN = markers.filter(m=>m.chainId===chainId).reduce((a,m)=>Math.max(a, m.num||0), 0);
          nextNum = maxN + 1;
        }else{
          chainInfo.anchorMarkerId = null;
        }
      }

      // active category
      let catId = state.ui.selectedCatId;
      if(!catId || !game.markerCats.find(c=>c.id===catId)){
        catId = game.markerCats[0]?.id;
      }
      const cat = getCat(game, catId) || game.markerCats[0];

      // category style base (1번 마커 기준)
      const base = getCategoryBaseStyle(game, page.id, catId);

      const m = {
        id: uid(),
        x: w.x,
        y: w.y,
        catId: catId,
        num: nextNum,
        chainId: chainId,
        name: `마커${nextNum}`,
        ytTitle: `마커${nextNum}`,
        ytDesc: "",
        ytUrl: "",
        size: base.size,
        textSize: base.textSize,
        weight: base.weight,
        textColor: base.textColor,
        visible: true,
        dim: false,
        ctrl: null,
      };

      // ensure category enabled
      if(cat) cat.enabled = true;

      markers.push(m);

      // update chain nextNum
      chainInfo.nextNum = nextNum + 1;

      // sync category style rules (apply base color to marker fill)
      // (color is in category itself)
      saveLocal();
      interaction.selectedMarkerId = m.id;
      syncSelectedMarkerUI();
      requestRender();
    }

    function onWheel(e){
      e.preventDefault();
      const delta = -e.deltaY;
      const zoomFactor = Math.exp(delta * 0.0012);

      const mx = e.clientX, my = e.clientY;
      const before = screenToWorld(mx, my);

      const newZoom = clamp(view.zoom * zoomFactor, view.minZoom, view.maxZoom);
      view.zoom = newZoom;

      const after = screenToWorld(mx, my);
      view.panX += (after.x - before.x) * view.zoom;
      view.panY += (after.y - before.y) * view.zoom;

      requestRender();
    }

    /*****************************************************************
     * Category style sync (per requirement)
     *****************************************************************/
    function getCategoryBaseStyle(game, pageId, catId){
      // Base style is category's first marker (num==1) within that category (same page)
      const markers = getMarkers(game, pageId);
      const first = markers
        .filter(m=>m.catId===catId)
        .sort((a,b)=>a.num-b.num)[0];

      if(first){
        return {
          size: clamp(first.size||24, 1, 100),
          textSize: clamp(first.textSize||12, 1, 200),
          weight: String(first.weight||"800"),
          textColor: normalizeHex(first.textColor)||"#ffffff",
        };
      }
      // fallback
      return { size: 24, textSize: 12, weight: "800", textColor:"#ffffff" };
    }

    function applyCategoryBaseToAll(game, pageId, catId){
      const markers = getMarkers(game, pageId);
      const base = getCategoryBaseStyle(game, pageId, catId);
      for(const m of markers){
        if(m.catId !== catId) continue;
        m.size = base.size;
        m.textSize = base.textSize;
        m.weight = base.weight;
        m.textColor = base.textColor;
      }
    }

    /*****************************************************************
     * Rendering
     *****************************************************************/
    function render(){
      ctx.clearRect(0,0,view.w,view.h);

      // background grid
      ctx.save();
      ctx.globalAlpha = 0.20;
      ctx.strokeStyle = "rgba(39,52,74,0.8)";
      const step = 80;
      for(let x=0;x<view.w;x+=step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,view.h); ctx.stroke();
      }
      for(let y=0;y<view.h;y+=step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(view.w,y); ctx.stroke();
      }
      ctx.restore();

      // map image
      ctx.save();
      ctx.translate(view.panX, view.panY);
      ctx.scale(view.zoom, view.zoom);
      if(bg.loaded){
        ctx.globalAlpha = 1;
        ctx.drawImage(bg.img, 0, 0, bg.w, bg.h);
      }else{
        // placeholder
        ctx.fillStyle = "rgba(11,18,32,0.7)";
        ctx.fillRect(0,0, Math.max(1200, view.w/view.zoom), Math.max(800, view.h/view.zoom));
        ctx.fillStyle = "rgba(159,176,198,0.9)";
        ctx.font = "800 14px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
        ctx.fillText("지도 이미지가 없습니다. 좌측 메뉴에서 페이지 URL을 등록하세요.", 18, 28);
      }
      ctx.restore();

      const { game, page, markers } = activeContext();
      if(!game || !page) {
        // instruction overlay
        ctx.save();
        ctx.fillStyle = "rgba(231,238,248,0.92)";
        ctx.font = "900 14px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
        ctx.fillText("상단 카테고리에서 게임을 추가/선택하고, 좌측에서 페이지를 추가하세요.", 18, 24);
        ctx.restore();
        return;
      }

      // Draw connections (lines + arrows)
      if(state.ui.linesVisible){
        drawConnections(game, page, markers);
      }

      // Draw markers
      drawMarkers(game, page, markers);
    }

    function drawConnections(game, page, markers){
      // build visible markers by chain
      const visibleMarkers = markers.filter(m=>{
        if(!m.visible) return false;
        if(!state.ui.allMarkersVisible) return false;
        const cat = getCat(game, m.catId);
        if(cat && cat.enabled === false) return false;
        return true;
      });

      const byChain = new Map();
      for(const m of visibleMarkers){
        if(!byChain.has(m.chainId)) byChain.set(m.chainId, []);
        byChain.get(m.chainId).push(m);
      }

      ctx.save();
      ctx.lineWidth = Math.max(1.5, 2.2 * Math.sqrt(view.zoom));
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      for(const [chainId, arr] of byChain.entries()){
        arr.sort((a,b)=>a.num-b.num);
        for(let i=1;i<arr.length;i++){
          const prev = arr[i-1], cur = arr[i];

          // color follows category color of current marker (can choose prev or cur)
          const cat = getCat(game, cur.catId) || getCat(game, prev.catId);
          const col = cat ? cat.color : "#7cc4ff";
          ctx.strokeStyle = hexToRgba(col, 0.92);

          const A = worldToScreen(prev.x, prev.y);
          const B = worldToScreen(cur.x, cur.y);
          const ctrlW = cur.ctrl ? cur.ctrl : { x:(prev.x+cur.x)/2, y:(prev.y+cur.y)/2 };
          const C = worldToScreen(ctrlW.x, ctrlW.y);

          // draw quadratic
          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.quadraticCurveTo(C.x, C.y, B.x, B.y);
          ctx.stroke();

          // arrow near end (toward B)
          drawArrowOnQuadratic(A, C, B, col);

          // show control point subtle if editing this curve or marker selected
          if(interaction.activeCurve && interaction.activeCurve.currId === cur.id){
            ctx.save();
            ctx.fillStyle = "rgba(255,255,255,0.85)";
            ctx.strokeStyle = "rgba(0,0,0,0.55)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(C.x, C.y, 6, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      ctx.restore();
    }

    function drawArrowOnQuadratic(A, C, B, hex){
      // sample t near end
      const t = 0.86;
      const p = quadPoint(A,C,B,t);
      const tan = quadTangent(A,C,B,t);
      const ang = Math.atan2(tan.y, tan.x);

      const size = clamp(10 * Math.sqrt(view.zoom), 8, 18);
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.fillStyle = hexToRgba(hex, 0.95);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-size, size*0.55);
      ctx.lineTo(-size, -size*0.55);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawMarkers(game, page, markers){
      // sort by num (draw lower first)
      const ordered = [...markers].sort((a,b)=>a.num-b.num);

      for(const m of ordered){
        if(!m.visible) continue;
        if(!state.ui.allMarkersVisible) continue;
        const cat = getCat(game, m.catId);
        if(cat && cat.enabled === false) continue;

        const p = worldToScreen(m.x, m.y);
        const r = markerRadius(m) * view.zoom;

        const catColor = cat ? cat.color : "#7cc4ff";
        const fill = hexToRgba(catColor, m.dim ? 0.30 : 0.92);
        const stroke = "rgba(0,0,0,0.55)";

        // circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI*2);
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = Math.max(1.2, 2.0 * Math.sqrt(view.zoom));
        ctx.strokeStyle = stroke;
        ctx.stroke();

        // number
        const hideNum = !!state.ui.hideNumbersByCat[m.catId];
        if(!hideNum){
          ctx.fillStyle = normalizeHex(m.textColor) || "#ffffff";
          const fs = clamp((m.textSize||12) * view.zoom, 8, 44);
          ctx.font = `${m.weight||"800"} ${fs}px ${getComputedStyle(document.documentElement).getPropertyValue("--font")}`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(String(m.num||""), p.x, p.y);
        }

        // marker name text near marker (always render; scales with zoom by requirement)
        const name = (m.name||"").trim();
        if(name){
          const fs2 = clamp((m.textSize||12) * view.zoom, 8, 56);
          ctx.font = `${m.weight||"800"} ${fs2}px ${getComputedStyle(document.documentElement).getPropertyValue("--font")}`;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";

          const pad = 10 * Math.sqrt(view.zoom);
          const tx = p.x + r + pad;
          const ty = p.y;

          // backdrop
          const textW = ctx.measureText(name).width;
          const bh = fs2 * 1.6;
          ctx.fillStyle = "rgba(0,0,0,0.38)";
          roundRect(ctx, tx-8, ty-bh/2, textW+16, bh, 10);
          ctx.fill();

          ctx.fillStyle = normalizeHex(m.textColor) || "#ffffff";
          ctx.fillText(name, tx, ty);
        }

        // hover ring
        if(interaction.hoverMarkerId === m.id || interaction.selectedMarkerId === m.id){
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 3, 0, Math.PI*2);
          ctx.strokeStyle = "rgba(124,196,255,0.85)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    function roundRect(ctx,x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    /*****************************************************************
     * UI: Slots / Games
     *****************************************************************/
    function refreshSlotsUI(){
      elSlots.innerHTML = "";

      state.slots.forEach((slot, slotIndex) => {
        const wrap = document.createElement("div");
        wrap.className = "slot";

        const top = document.createElement("div");
        top.className = "slotTop";

        const title = document.createElement("div");
        title.className = "slotTitle";
        const input = document.createElement("input");
        input.value = slot.name || `카테고리${slotIndex+1}`;
        input.placeholder = `카테고리${slotIndex+1}`;
        input.addEventListener("change", ()=>{
          slot.name = input.value.trim() || `카테고리${slotIndex+1}`;
          saveLocal();
        });
        title.appendChild(input);

        const btnAdd = document.createElement("button");
        btnAdd.className = "btn small ok";
        btnAdd.textContent = "추가";
        btnAdd.title = "게임 추가";
        btnAdd.addEventListener("click", ()=>{
          const name = prompt(`${slot.name}에 추가할 게임 이름을 입력하세요`, `게임${slot.games.length+1}`);
          if(!name) return;
          const g = ensureGame(state, slotIndex, name.trim());
          // select game
          state.ui.activeSlot = slotIndex;
          state.ui.activeGameId = g.id;
          if(!g.pages.length){
            const p = ensurePage(g, "페이지1", "");
            state.ui.activePageId = p.id;
          }else{
            state.ui.activePageId = g.pages[0].id;
          }
          saveLocal();
          refreshAllUI();
          toast("게임 추가 완료");
        });

        const btnDel = document.createElement("button");
        btnDel.className = "btn small danger";
        btnDel.textContent = "삭제";
        btnDel.title = "이 카테고리의 모든 게임 삭제";
        btnDel.addEventListener("click", ()=>{
          if(!confirm(`${slot.name} 안의 게임을 모두 삭제할까요?`)) return;
          // remove games
          for(const g of slot.games){
            if(g?.id && state.games[g.id]) delete state.games[g.id];
          }
          slot.games = [];
          // reset active if it was in this slot
          if(state.ui.activeSlot === slotIndex){
            state.ui.activeGameId = null;
            state.ui.activePageId = null;
          }
          saveLocal();
          refreshAllUI();
          toast("카테고리 내 게임 삭제 완료");
        });

        top.appendChild(title);
        top.appendChild(btnAdd);
        top.appendChild(btnDel);

        const body = document.createElement("div");
        body.className = "slotBody";

        const sublist = document.createElement("div");
        sublist.className = "sublist";

        slot.games.forEach((gref, gi) => {
          const row = document.createElement("div");
          row.className = "subitem";

          const btn = document.createElement("button");
          btn.className = "subbtn";
          btn.textContent = gref.name || `게임${gi+1}`;
          const isActive = (state.ui.activeGameId === gref.id);
          if(isActive) btn.classList.add("active");
          btn.addEventListener("click", ()=>{
            if(!state.games[gref.id]) return;
            state.ui.activeSlot = slotIndex;
            state.ui.activeGameId = gref.id;
            const game = state.games[gref.id];
            if(game.pages.length){
              state.ui.activePageId = game.pages[0].id;
            }else{
              const p = ensurePage(game, "페이지1", "");
              state.ui.activePageId = p.id;
            }
            saveLocal();
            refreshAllUI();
            toast(`선택: ${game.name}`);
          });

          const btnRename = document.createElement("button");
          btnRename.className = "btn small ghost";
          btnRename.textContent = "이름";
          btnRename.addEventListener("click", ()=>{
            const game = state.games[gref.id];
            if(!game) return;
            const name = prompt("게임 이름 변경", game.name);
            if(!name) return;
            game.name = name.trim();
            gref.name = game.name;
            saveLocal();
            refreshAllUI();
          });

          const btnRemove = document.createElement("button");
          btnRemove.className = "btn small danger";
          btnRemove.textContent = "삭제";
          btnRemove.addEventListener("click", ()=>{
            const game = state.games[gref.id];
            if(!game) return;
            if(!confirm(`게임 삭제: ${game.name}\n(페이지/마커 포함 전체 삭제)`)) return;
            delete state.games[gref.id];
            slot.games = slot.games.filter(x=>x.id!==gref.id);
            if(state.ui.activeGameId === gref.id){
              state.ui.activeGameId = null;
              state.ui.activePageId = null;
            }
            saveLocal();
            refreshAllUI();
          });

          row.appendChild(btn);
          row.appendChild(btnRename);
          row.appendChild(btnRemove);
          sublist.appendChild(row);
        });

        body.appendChild(sublist);

        wrap.appendChild(top);
        wrap.appendChild(body);
        elSlots.appendChild(wrap);
      });
    }

    /*****************************************************************
     * UI: Pages
     *****************************************************************/
    function refreshPagesUI(){
      const game = getActiveGame();
      if(!game){
        elBreadcrumb.textContent = "-";
        elPageList.innerHTML = "";
        return;
      }

      const page = getActivePage(game);
      const slotName = state.slots[game.slotIndex]?.name || `카테고리${game.slotIndex+1}`;
      elBreadcrumb.textContent = `${slotName}/${game.name}${page ? "/"+page.name : ""}`;

      elPageList.innerHTML = "";
      game.pages.forEach((p, idx) => {
        const card = document.createElement("div");
        card.className = "card";

        const top = document.createElement("div");
        top.className = "cardTop";

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = `PAGE ${idx+1}`;

        const btnRename = document.createElement("button");
        btnRename.className = "btn small ghost";
        btnRename.textContent = "이름";
        btnRename.addEventListener("click", ()=>{
          const name = prompt("페이지 이름 변경", p.name);
          if(!name) return;
          p.name = name.trim();
          saveLocal();
          refreshPagesUI();
        });

        const btnUrl = document.createElement("button");
        btnUrl.className = "btn small ghost";
        btnUrl.textContent = "URL";
        btnUrl.addEventListener("click", ()=>{
          const url = prompt("지도 이미지 URL 변경", p.url || "");
          if(url === null) return;
          p.url = url.trim();
          saveLocal();
          refreshPagesUI();
          if(state.ui.activePageId === p.id){
            loadBackground(resolveMapUrl(p.url));
          }
        });

        const btnDel = document.createElement("button");
        btnDel.className = "btn small danger";
        btnDel.textContent = "삭제";
        btnDel.addEventListener("click", ()=>{
          if(!confirm(`페이지 삭제: ${p.name}\n(해당 페이지의 마커/선도 삭제)`)) return;
          // delete page markers
          delete game.markersByPage[p.id];
          delete game.chain.perPage[p.id];
          game.pages = game.pages.filter(x=>x.id!==p.id);
          if(state.ui.activePageId === p.id){
            state.ui.activePageId = game.pages[0]?.id || null;
          }
          saveLocal();
          refreshAllUI();
        });

        top.appendChild(tag);
        top.appendChild(btnRename);
        top.appendChild(btnUrl);
        top.appendChild(btnDel);

        const btn = document.createElement("div");
        btn.className = "pageBtn" + (state.ui.activePageId === p.id ? " active" : "");
        btn.addEventListener("click", ()=>{
          state.ui.activePageId = p.id;
          saveLocal();
          refreshAllUI();
          loadBackground(resolveMapUrl(p.url));
        });

        const nm = document.createElement("div");
        nm.className = "name";
        nm.textContent = p.name || `페이지${idx+1}`;

        const hint = document.createElement("div");
        hint.className = "hint";
        hint.textContent = p.url ? "URL✓" : "URL—";

        btn.appendChild(nm);
        btn.appendChild(hint);

        card.appendChild(top);
        card.appendChild(btn);
        elPageList.appendChild(card);
      });
    }

    function resolveMapUrl(url){
      if(!url) return "";
      const u = url.trim();
      if(!u) return "";
      // allow relative paths and absolute
      if(/^https?:\/\//i.test(u)) return u;
      // if begins with '/', make it absolute from origin
      if(u.startsWith("/")) return new URL(u, location.origin).toString();
      // else relative to current folder (aion2/)
      return new URL(u, location.href).toString();
    }

    function addPage(){
      const game = getActiveGame();
      if(!game){
        toast("먼저 게임을 선택하세요");
        return;
      }
      const name = (elPageName.value||"").trim() || `페이지${game.pages.length+1}`;
      const url = (elPageUrl.value||"").trim();

      const p = ensurePage(game, name, url);
      state.ui.activePageId = p.id;

      elPageName.value = "";
      elPageUrl.value = "";

      saveLocal();
      refreshAllUI();
      loadBackground(resolveMapUrl(p.url));
      toast("페이지 추가 완료");
    }

    /*****************************************************************
     * UI: Marker Categories
     *****************************************************************/
    function refreshCategoriesUI(){
      const game = getActiveGame();
      const page = game ? getActivePage(game) : null;
      if(!game || !page){
        elCatPills.innerHTML = "";
        return;
      }

      // ensure selectedCat exists
      if(!state.ui.selectedCatId || !game.markerCats.find(c=>c.id===state.ui.selectedCatId)){
        state.ui.selectedCatId = game.markerCats[0]?.id || null;
      }

      elCatPills.innerHTML = "";
      game.markerCats.forEach((c) => {
        const b = document.createElement("button");
        b.className = "catBtn";
        if(c.enabled === false) b.classList.add("off");
        if(state.ui.selectedCatId === c.id) b.classList.add("active");

        const d = document.createElement("span");
        d.className = "dot";
        d.style.background = c.color || "#7cc4ff";

        const t = document.createElement("span");
        t.textContent = c.name;

        b.appendChild(d);
        b.appendChild(t);

        b.addEventListener("click", (ev)=>{
          // click selects category (left-click)
          state.ui.selectedCatId = c.id;
          saveLocal();
          refreshCategoriesUI();
        });

        b.addEventListener("dblclick", (ev)=>{
          // double toggles enable
          c.enabled = !(c.enabled !== false);
          saveLocal();
          refreshCategoriesUI();
          requestRender();
        });

        // right click toggles enable too
        b.addEventListener("contextmenu", (ev)=>{
          ev.preventDefault();
          c.enabled = !(c.enabled !== false);
          saveLocal();
          refreshCategoriesUI();
          requestRender();
        });

        elCatPills.appendChild(b);
      });
    }

    function toggleAllMarkers(){
      state.ui.allMarkersVisible = !state.ui.allMarkersVisible;
      saveLocal();
      requestRender();
      toast(state.ui.allMarkersVisible ? "전체 마커 표시" : "전체 마커 숨김");
    }

    function showAllLines(){
      state.ui.linesVisible = true;
      saveLocal();
      requestRender();
      toast("모든 선 표시");
    }
    function hideAllLines(){
      state.ui.linesVisible = false;
      saveLocal();
      requestRender();
      toast("모든 선 제거");
    }

    function resetMarkers(){
      const game = getActiveGame();
      const page = game ? getActivePage(game) : null;
      if(!game || !page) return;
      if(!confirm(`마커 초기화: ${game.name}/${page.name}\n(해당 페이지의 마커/선 삭제)`)) return;

      game.markersByPage[page.id] = [];
      game.chain.perPage[page.id] = { anchorMarkerId:null, nextNum:1, chainIdSeed: uid() };

      interaction.selectedMarkerId = null;
      interaction.activeCurve = null;
      saveLocal();
      syncSelectedMarkerUI();
      requestRender();
      toast("마커 초기화 완료");
    }

    function toggleHideNumbers(){
      const game = getActiveGame();
      if(!game) return;
      const catId = state.ui.selectedCatId || game.markerCats[0]?.id;
      if(!catId) return;
      state.ui.hideNumbersByCat[catId] = !state.ui.hideNumbersByCat[catId];
      saveLocal();
      requestRender();
      toast(state.ui.hideNumbersByCat[catId] ? "해당 카테고리 숫자 숨김" : "해당 카테고리 숫자 표시");
    }

    /*****************************************************************
     * Selected marker + left youtube apply
     *****************************************************************/
    function getSelectedMarker(){
      const { game, page, markers } = activeContext();
      if(!game || !page) return null;
      const id = interaction.selectedMarkerId;
      if(!id) return null;
      return markers.find(m=>m.id===id) || null;
    }

    function syncSelectedMarkerUI(){
      const m = getSelectedMarker();
      if(m){
        elSelectedMarkerName.textContent = `선택 마커: ${m.name || ("#"+m.num)}`;
        elYtTitle.value = m.ytTitle || "";
        elYtDesc.value = m.ytDesc || "";
        elYtUrl.value = m.ytUrl || "";
      }else{
        elSelectedMarkerName.textContent = "선택 마커: -";
        elYtTitle.value = "";
        elYtDesc.value = "";
        elYtUrl.value = "";
      }
    }

    function applyYTToSelected(){
      const m = getSelectedMarker();
      if(!m){
        toast("선택 마커가 없습니다");
        return;
      }
      m.ytTitle = (elYtTitle.value||"").trim();
      m.ytDesc  = (elYtDesc.value||"").trim();
      m.ytUrl   = (elYtUrl.value||"").trim();
      saveLocal();
      toast("유튜브 정보 적용 완료");
      requestRender();
    }

    /*****************************************************************
     * Marker Editor
     *****************************************************************/
    let markerModalId = null;
    let markerModalPrevSize = null;

    function openMarkerEditor(markerId){
      const m = getSelectedMarker();
      const { game, page } = activeContext();
      if(!m || !game || !page){
        toast("편집할 마커를 선택하세요");
        return;
      }
      markerModalId = markerId || m.id;

      // populate
      elMarkerModalSub.textContent = `${game.name}/${page.name} · #${m.num} (${getCat(game,m.catId)?.name || "카테고리"})`;
      elMName.value = m.name || "";
      buildMarkerCatSelect(game, m.catId);

      elMYtTitle.value = m.ytTitle || "";
      elMYtDesc.value = m.ytDesc || "";
      elMYtUrl.value = m.ytUrl || "";

      elMSize.value = clamp(Number(m.size||24), 1, 100);
      elMTextSize.value = clamp(Number(m.textSize||12), 1, 200);
      elMWeight.value = String(m.weight||"800");
      elMTextColor.value = normalizeHex(m.textColor)||"#ffffff";

      markerModalPrevSize = Number(elMSize.value);

      buildQuickColors(elMQuickColors, (hex)=>{
        elMTextColor.value = hex;
      });

      elMarkerOverlay.classList.add("show");
    }

    function closeMarkerEditor(){
      markerModalId = null;
      markerModalPrevSize = null;
      elMarkerOverlay.classList.remove("show");
    }

    function buildMarkerCatSelect(game, selectedId){
      elMCat.innerHTML = "";
      game.markerCats.forEach(c=>{
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = c.name;
        if(c.id === selectedId) opt.selected = true;
        elMCat.appendChild(opt);
      });
    }

    function saveMarkerFromModal(){
      const { game, page, markers } = activeContext();
      if(!game || !page) return;
      const m = markers.find(mm=>mm.id===markerModalId);
      if(!m) return;

      const oldSize = clamp(Number(m.size||24), 1, 100);
      const newSize = clamp(Number(elMSize.value||24), 1, 100);
      const scale = (oldSize > 0) ? (newSize / oldSize) : 1;

      const newName = (elMName.value||"").trim();
      const prevYtTitle = (m.ytTitle||"").trim();

      m.name = newName;

      // if user hasn't customized ytTitle or it was same as previous name pattern,
      // and modal ytTitle is empty, auto sync
      const modalYtTitle = (elMYtTitle.value||"").trim();
      if(!modalYtTitle){
        // auto set ytTitle = name
        m.ytTitle = newName;
      }else{
        m.ytTitle = modalYtTitle;
      }
      m.ytDesc = (elMYtDesc.value||"").trim();
      m.ytUrl  = (elMYtUrl.value||"").trim();

      const newCatId = elMCat.value;
      m.catId = newCatId;

      m.size = newSize;

      // text size scaled with marker size (requirement)
      const modalTextSize = clamp(Number(elMTextSize.value||12), 1, 200);
      // If size changed and user didn't deliberately edit textSize after change, keep proportion.
      // We'll always keep proportion to meet requirement.
      const scaledTextSize = clamp(Math.round(modalTextSize * scale), 1, 200);
      m.textSize = scaledTextSize;

      m.weight = elMWeight.value || "800";
      m.textColor = normalizeHex(elMTextColor.value)||"#ffffff";

      // Apply category base sync rule:
      // if this marker is the 1st marker in its category on this page, then sync all markers in that category
      // else sync this marker to category base (by requirement category follows 1st marker)
      const catMarkers = getMarkers(game, page.id).filter(mm=>mm.catId===m.catId).sort((a,b)=>a.num-b.num);
      const first = catMarkers[0];
      if(first && first.id === m.id){
        // update category base across all
        applyCategoryBaseToAll(game, page.id, m.catId);
      }else{
        // force this marker to base
        const base = getCategoryBaseStyle(game, page.id, m.catId);
        m.size = base.size;
        m.textSize = base.textSize;
        m.weight = base.weight;
        m.textColor = base.textColor;
      }

      saveLocal();
      closeMarkerEditor();
      syncSelectedMarkerUI();
      refreshCategoriesUI();
      requestRender();
      toast("마커 저장 완료");
    }

    function deleteSelectedMarker(){
      const { game, page, markers } = activeContext();
      if(!game || !page) return;
      const m = markers.find(mm=>mm.id===markerModalId);
      if(!m) return;
      if(!confirm(`마커 삭제: ${m.name || ("#"+m.num)}\n삭제하시겠습니까?`)) return;

      // remove marker
      const idx = markers.findIndex(mm=>mm.id===m.id);
      if(idx >= 0) markers.splice(idx, 1);

      // If chain anchor points to this, clear
      const chainInfo = game.chain.perPage[page.id];
      if(chainInfo && chainInfo.anchorMarkerId === m.id) chainInfo.anchorMarkerId = null;

      interaction.selectedMarkerId = null;
      markerModalId = null;
      saveLocal();
      closeMarkerEditor();
      syncSelectedMarkerUI();
      requestRender();
      toast("마커 삭제 완료");
    }

    function startNewChain(){
      const { game, page } = activeContext();
      if(!game || !page) return;
      // new chain seed
      game.chain.perPage[page.id] = { anchorMarkerId:null, nextNum:1, chainIdSeed: uid() };
      saveLocal();
      closeMarkerEditor();
      toast("새로운 번호로 시작 설정");
    }

    function continueFromHere(){
      const { game, page, markers } = activeContext();
      if(!game || !page) return;
      const m = markers.find(mm=>mm.id===markerModalId);
      if(!m) return;

      const chainInfo = game.chain.perPage[page.id] || (game.chain.perPage[page.id] = { anchorMarkerId:null, nextNum:1, chainIdSeed: uid() });
      chainInfo.anchorMarkerId = m.id;

      // nextNum becomes max in that chain + 1
      const maxN = markers.filter(mm=>mm.chainId===m.chainId).reduce((a,mm)=>Math.max(a, mm.num||0), 0);
      chainInfo.nextNum = maxN + 1;

      saveLocal();
      closeMarkerEditor();
      toast("해당 마커 이어서 시작 설정");
    }

    /*****************************************************************
     * Category Editor
     *****************************************************************/
    let catModalSelectedId = null;

    function openCatEditor(){
      const game = getActiveGame();
      const page = game ? getActivePage(game) : null;
      if(!game || !page){
        toast("게임/페이지를 먼저 선택하세요");
        return;
      }
      elCatModalSub.textContent = `${game.name}/${page.name}`;
      catModalSelectedId = state.ui.selectedCatId || game.markerCats[0]?.id || null;

      buildQuickColors(elCatQuickColors, (hex)=>{
        elCatHex.value = hex;
      });

      refreshCatList();
      elCatOverlay.classList.add("show");
    }

    function closeCatEditor(){
      elCatOverlay.classList.remove("show");
      catModalSelectedId = null;
    }

    function refreshCatList(){
      const game = getActiveGame();
      if(!game) return;
      elCatList.innerHTML = "";

      game.markerCats.forEach((c, idx)=>{
        const card = document.createElement("div");
        card.className = "card";

        const top = document.createElement("div");
        top.className = "cardTop";

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = `CAT ${idx+1}`;

        const btnSel = document.createElement("button");
        btnSel.className = "btn small" + (catModalSelectedId===c.id ? " ok" : "");
        btnSel.textContent = (catModalSelectedId===c.id ? "선택됨" : "선택");
        btnSel.addEventListener("click", ()=>{
          catModalSelectedId = c.id;
          state.ui.selectedCatId = c.id;
          saveLocal();
          refreshCatList();
          refreshCategoriesUI();
          requestRender();
        });

        const btnRename = document.createElement("button");
        btnRename.className = "btn small ghost";
        btnRename.textContent = "이름";
        btnRename.addEventListener("click", ()=>{
          const nm = prompt("카테고리 이름 변경", c.name);
          if(!nm) return;
          c.name = nm.trim();
          saveLocal();
          refreshCatList();
          refreshCategoriesUI();
        });

        const btnDel = document.createElement("button");
        btnDel.className = "btn small danger";
        btnDel.textContent = "삭제";
        btnDel.addEventListener("click", ()=>{
          if(game.markerCats.length <= 1){
            alert("최소 1개의 카테고리는 유지되어야 합니다.");
            return;
          }
          if(!confirm(`카테고리 삭제: ${c.name}\n해당 카테고리의 마커는 '기본'으로 이동됩니다.`)) return;

          const fallback = game.markerCats.find(x=>x.id!==c.id);
          const page = getActivePage(game);
          if(page){
            const markers = getMarkers(game, page.id);
            for(const m of markers){
              if(m.catId === c.id) m.catId = fallback.id;
            }
          }

          game.markerCats = game.markerCats.filter(x=>x.id!==c.id);
          if(state.ui.selectedCatId === c.id) state.ui.selectedCatId = game.markerCats[0]?.id || null;
          if(catModalSelectedId === c.id) catModalSelectedId = state.ui.selectedCatId;

          saveLocal();
          refreshCatList();
          refreshCategoriesUI();
          requestRender();
        });

        top.appendChild(tag);
        top.appendChild(btnSel);
        top.appendChild(btnRename);
        top.appendChild(btnDel);

        const row = document.createElement("div");
        row.className = "row wrap";
        row.style.alignItems = "center";

        const dot = document.createElement("span");
        dot.className = "dot";
        dot.style.background = c.color || "#7cc4ff";
        dot.title = "카테고리 색";

        const nm = document.createElement("div");
        nm.style.fontWeight = "1000";
        nm.style.letterSpacing = ".2px";
        nm.style.flex = "1";
        nm.style.minWidth = "0";
        nm.style.overflow = "hidden";
        nm.style.textOverflow = "ellipsis";
        nm.style.whiteSpace = "nowrap";
        nm.textContent = c.name;

        const tog = document.createElement("button");
        tog.className = "btn small";
        tog.textContent = (c.enabled===false ? "OFF" : "ON");
        if(c.enabled===false) tog.classList.add("danger");
        else tog.classList.add("ok");
        tog.addEventListener("click", ()=>{
          c.enabled = !(c.enabled !== false);
          saveLocal();
          refreshCatList();
          refreshCategoriesUI();
          requestRender();
        });

        row.appendChild(dot);
        row.appendChild(nm);
        row.appendChild(tog);

        card.appendChild(top);
        card.appendChild(row);

        elCatList.appendChild(card);
      });
    }

    function addCategory(){
      const game = getActiveGame();
      if(!game) return;
      const nm = (elNewCatName.value||"").trim();
      if(!nm){
        toast("카테고리 이름을 입력하세요");
        return;
      }
      const c = { id: uid(), name: nm, color: "#7cc4ff", enabled: true };
      game.markerCats.push(c);
      elNewCatName.value = "";
      state.ui.selectedCatId = c.id;
      catModalSelectedId = c.id;
      saveLocal();
      refreshCatList();
      refreshCategoriesUI();
      requestRender();
      toast("카테고리 추가 완료");
    }

    function applyCatColor(){
      const game = getActiveGame();
      const page = game ? getActivePage(game) : null;
      if(!game || !page) return;
      const cid = catModalSelectedId || state.ui.selectedCatId;
      const cat = cid ? getCat(game, cid) : null;
      if(!cat) return;

      const hex = normalizeHex(elCatHex.value);
      if(!hex){
        toast("HEX 색상 형식이 올바르지 않습니다");
        return;
      }
      cat.color = hex;

      // reflect to all markers of that category (color is in category; draw uses it)
      saveLocal();
      refreshCatList();
      refreshCategoriesUI();
      requestRender();
      toast("카테고리 색상 적용 완료");
    }

    /*****************************************************************
     * Logo URL
     *****************************************************************/
    function refreshLogo(){
      elLogoImg.src = resolveMapUrl(state.logoUrl || "/assets/logo/MAPMODELOGO2.png");
    }

    function setLogoUrl(){
      const cur = state.logoUrl || "/assets/logo/MAPMODELOGO2.png";
      const url = prompt("로고 이미지 URL 입력", cur);
      if(url === null) return;
      state.logoUrl = url.trim();
      saveLocal();
      refreshLogo();
      toast("로고 URL 저장");
    }

    /*****************************************************************
     * Quick colors widgets
     *****************************************************************/
    function buildQuickColors(container, onPick){
      container.innerHTML = "";
      QUICK_COLORS.forEach(hex=>{
        const d = document.createElement("div");
        d.className = "colorSwatch";
        d.style.background = hex;
        d.title = hex;
        d.addEventListener("click", ()=>onPick(hex));
        container.appendChild(d);
      });
    }

    function initQuickColors(){
      buildQuickColors(elQuickColors, (hex)=>{
        // apply to selected category color (quick admin tool)
        const game = getActiveGame();
        const page = game ? getActivePage(game) : null;
        if(!game || !page){
          toast("게임/페이지를 먼저 선택하세요");
          return;
        }
        const cid = state.ui.selectedCatId || game.markerCats[0]?.id;
        const cat = cid ? getCat(game, cid) : null;
        if(!cat){
          toast("카테고리를 먼저 선택하세요");
          return;
        }
        cat.color = hex;
        saveLocal();
        refreshCategoriesUI();
        requestRender();
        toast("카테고리 색상 변경");
      });
    }

    /*****************************************************************
     * Auth UI
     *****************************************************************/
    function refreshAuthUI(){
      elAuthState.textContent = isAuthed() ? "OPEN" : "LOCK";
      elAuthState.style.borderColor = isAuthed() ? "rgba(57,217,138,.55)" : "rgba(255,93,93,.55)";
      elBtnLogin.textContent = isAuthed() ? "로그아웃" : "관리자 로그인";
      elBtnLogin.classList.toggle("danger", isAuthed());
      elBtnLogin.classList.toggle("ok", !isAuthed());
    }

    function openLogin(){
      elLoginPw.value = "";
      elLoginOverlay.classList.add("show");
      setTimeout(()=>elLoginPw.focus(), 50);
    }

    function closeLogin(){
      elLoginOverlay.classList.remove("show");
    }

    function doLogin(){
      const pw = (elLoginPw.value||"").trim();
      if(pw !== PASSWORD){
        toast("비밀번호가 올바르지 않습니다");
        elLoginPw.focus();
        return;
      }
      setAuthed();
      refreshAuthUI();
      closeLogin();
      toast("관리자 인증 완료 (24시간 유지)");
    }

    function toggleLoginButton(){
      if(isAuthed()){
        if(confirm("로그아웃 하시겠습니까? (인증 정보 삭제)")){
          clearAuth();
          refreshAuthUI();
          toast("로그아웃 완료");
        }
      }else{
        openLogin();
      }
    }

    /*****************************************************************
     * Global UI refresh
     *****************************************************************/
    function refreshAllUI(){
      refreshAuthUI();
      refreshLogo();
      refreshSlotsUI();
      refreshPagesUI();
      refreshCategoriesUI();
      syncSelectedMarkerUI();

      const game = getActiveGame();
      const page = game ? getActivePage(game) : null;
      if(game && page){
        // load background for active page
        loadBackground(resolveMapUrl(page.url));
      }else{
        bg.loaded = false;
        requestRender();
      }
    }

    /*****************************************************************
     * Bind events
     *****************************************************************/
    function bind(){
      window.addEventListener("resize", resize);

      // canvas events
      canvas.addEventListener("pointerdown", onPointerDown);
      canvas.addEventListener("pointermove", onPointerMove);
      canvas.addEventListener("pointerup", onPointerUp);
      canvas.addEventListener("pointercancel", onPointerUp);
      canvas.addEventListener("dblclick", onDblClick);
      canvas.addEventListener("contextmenu", onContextMenu);
      canvas.addEventListener("wheel", onWheel, { passive:false });

      // top
      elBtnExport.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        exportStateJson();
      });
      elBtnResetAll.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        resetAll();
      });
      elBtnLogin.addEventListener("click", toggleLoginButton);

      // login modal
      elBtnDoLogin.addEventListener("click", doLogin);
      elBtnCancelLogin.addEventListener("click", closeLogin);
      elLoginOverlay.addEventListener("click", (e)=>{
        if(e.target === elLoginOverlay) closeLogin();
      });
      elLoginPw.addEventListener("keydown", (e)=>{
        if(e.key === "Enter") doLogin();
        if(e.key === "Escape") closeLogin();
      });

      // logo
      elLogoBtn.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        setLogoUrl();
      });

      // pages
      elBtnAddPage.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        addPage();
      });
      elPageUrl.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){ addPage(); }
      });
      elPageName.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){ elPageUrl.focus(); }
      });

      // categories/tools
      elBtnToggleAllMarkers.addEventListener("click", toggleAllMarkers);
      elBtnShowAllLines.addEventListener("click", showAllLines);
      elBtnHideAllLines.addEventListener("click", hideAllLines);
      elBtnResetMarkers.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        resetMarkers();
      });
      elBtnHideNumbers.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        toggleHideNumbers();
      });

      elBtnOpenMarkerEditor.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        const m = getSelectedMarker();
        if(!m){ toast("편집할 마커를 선택하세요"); return; }
        openMarkerEditor(m.id);
      });

      // left youtube apply
      elBtnApplyYT.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        applyYTToSelected();
      });

      // marker modal
      elBtnCloseMarkerModal.addEventListener("click", closeMarkerEditor);
      elMarkerOverlay.addEventListener("click", (e)=>{
        if(e.target === elMarkerOverlay) closeMarkerEditor();
      });
      elBtnSaveMarker.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        saveMarkerFromModal();
      });
      elBtnDeleteMarker.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        deleteSelectedMarker();
      });
      elBtnStartNewChain.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        startNewChain();
      });
      elBtnContinueFromHere.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        continueFromHere();
      });

      // autosync yt title from name (only when ytTitle is empty or equals old)
      elMName.addEventListener("input", ()=>{
        const nm = (elMName.value||"").trim();
        const yt = (elMYtTitle.value||"").trim();
        if(!yt) elMYtTitle.value = nm;
      });

      // when marker size changes, scale text size in modal (live)
      elMSize.addEventListener("input", ()=>{
        const cur = clamp(Number(elMSize.value||24), 1, 100);
        if(markerModalPrevSize && markerModalPrevSize > 0){
          const scale = cur / markerModalPrevSize;
          const ts = clamp(Number(elMTextSize.value||12), 1, 200);
          const nts = clamp(Math.round(ts * scale), 1, 200);
          elMTextSize.value = nts;
        }
        markerModalPrevSize = cur;
      });

      // cat modal open
      elBtnOpenCatEditor.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        openCatEditor();
      });
      elBtnCloseCatModal.addEventListener("click", closeCatEditor);
      elBtnCloseCatModal2.addEventListener("click", closeCatEditor);
      elCatOverlay.addEventListener("click", (e)=>{
        if(e.target === elCatOverlay) closeCatEditor();
      });
      elBtnAddCat.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        addCategory();
      });
      elNewCatName.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){ addCategory(); }
      });
      elBtnApplyCatColor.addEventListener("click", ()=>{
        if(!isAuthed()){ openLogin(); return; }
        applyCatColor();
      });

      // ESC close modals
      window.addEventListener("keydown", (e)=>{
        if(e.key === "Escape"){
          if(elMarkerOverlay.classList.contains("show")) closeMarkerEditor();
          if(elCatOverlay.classList.contains("show")) closeCatEditor();
          if(elLoginOverlay.classList.contains("show")) closeLogin();
        }
      });
    }

    /*****************************************************************
     * Init
     *****************************************************************/
    async function init(){
      // load local first
      loadLocal();

      // try remote merge (best-effort)
      await loadRemoteMerge();

      // ensure there is at least one game/page if empty (optional; keep empty if user wants)
      // We'll keep empty unless local already has active game/page.

      // logo
      refreshLogo();

      // quick colors
      initQuickColors();

      // UI
      refreshAllUI();

      // size
      resize();

      // if active page exists, load background
      const g = getActiveGame();
      const p = g ? getActivePage(g) : null;
      if(g && p) loadBackground(resolveMapUrl(p.url));

      requestRender();
    }

    bind();
    init();

    /*****************************************************************
     * Safety: prevent selection / drag images
     *****************************************************************/
    document.addEventListener("dragstart", (e)=>e.preventDefault());

    // Keep selection marker UI consistent when clicking outside
    canvas.addEventListener("click", (e)=>{
      const hit = findMarkerAtScreen(e.clientX, e.clientY);
      if(hit){
        interaction.selectedMarkerId = hit.id;
        syncSelectedMarkerUI();
        requestRender();
      }else{
        // do not clear selection automatically (keeps selection stable)
        requestRender();
      }
    });

    // keep background not selectable
    document.body.style.userSelect = "none";
  </script>
</body>
</html>
