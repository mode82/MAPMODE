<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE · ADMIN</title>
  <style>
    :root{
      color-scheme: dark;
      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;
      --r12:12px;
      --r14:14px;
      --r16:16px;
      --r18:18px;
      --topH:56px;
      --leftW:280px;
      --rightW:320px;
      --pad:12px;
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--font); overflow:hidden; }
    a{ color:inherit; text-decoration:none; }
    button,input,select,textarea{ font-family:var(--font); color:var(--text); background:transparent; border:1px solid var(--stroke2); border-radius:12px; padding:10px 12px; outline:none; }
    input,select,textarea{ background:rgba(7,11,18,.55); }
    textarea{ resize:none; }
    button{ cursor:pointer; background:rgba(124,196,255,.10); border:1px solid rgba(124,196,255,.18); }
    button:hover{ background:rgba(124,196,255,.16); }
    button:active{ transform:translateY(1px); }
    button.danger{ background:rgba(255,93,93,.10); border-color:rgba(255,93,93,.24); }
    button.danger:hover{ background:rgba(255,93,93,.16); }
    button.ghost{ background:transparent; border-color:var(--stroke2); }
    button.ghost:hover{ background:rgba(255,255,255,.06); }
    button.ok{ background:rgba(57,217,138,.12); border-color:rgba(57,217,138,.22); }
    button.ok:hover{ background:rgba(57,217,138,.18); }
    .app{ position:fixed; inset:0; padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
    .topbar{
      position:absolute; left:0; right:0; top:0; height:var(--topH);
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background:linear-gradient(to bottom, rgba(11,18,32,.78), rgba(11,18,32,.55));
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(var(--blur));
      z-index:20;
    }
    .logoBtn{
      display:flex; align-items:center; gap:10px;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.04);
      border:1px solid var(--stroke2);
      max-width:320px;
      min-width:140px;
      height:40px;
    }
    .logoImg{
      height:26px; width:auto; max-width:240px; display:block;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.45));
    }
    .logoFallback{
      font-weight:800; letter-spacing:.6px; font-size:14px; opacity:.95;
      padding:0 6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .topTabs{ display:flex; gap:8px; flex:1; overflow:hidden; }
    .tabBtn{
      height:40px;
      padding:0 12px;
      border-radius:14px;
      display:flex; align-items:center; gap:8px;
      background:rgba(255,255,255,.03);
      border:1px solid var(--stroke2);
      white-space:nowrap;
      min-width:0;
    }
    .tabBtn.active{ border-color:rgba(124,196,255,.35); background:rgba(124,196,255,.10); }
    .chip{ font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid var(--stroke2); color:var(--muted); background:rgba(255,255,255,.03); }
    .topActions{ display:flex; gap:8px; align-items:center; }
    .mini{ height:40px; padding:0 10px; border-radius:14px; }
    .layout{
      position:absolute; left:0; right:0; top:var(--topH); bottom:0;
      display:grid;
      grid-template-columns: var(--leftW) 1fr var(--rightW);
      gap:0;
      z-index:10;
    }
    .panel{
      height:100%;
      background:linear-gradient(to bottom, rgba(11,18,32,.68), rgba(11,18,32,.52));
      border-right:1px solid var(--stroke);
      backdrop-filter: blur(var(--blur));
      overflow:hidden;
      position:relative;
    }
    .panel.right{ border-right:none; border-left:1px solid var(--stroke); }
    .panelInner{
      position:absolute; inset:0;
      padding:12px;
      overflow:auto;
      overscroll-behavior: contain;
      scrollbar-width: thin;
    }
    .section{
      background:rgba(14,22,38,.55);
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:12px;
      box-shadow: var(--shadow2);
      margin-bottom:12px;
    }
    .sectionTitle{
      display:flex; align-items:center; justify-content:space-between;
      font-weight:800; font-size:13px; letter-spacing:.2px; color:var(--text);
      margin-bottom:10px;
    }
    .muted{ color:var(--muted); font-size:12px; }
    .row{ display:flex; gap:8px; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .btnRow{ display:flex; gap:8px; flex-wrap:wrap; }
    .list{ display:flex; flex-direction:column; gap:8px; }
    .item{
      background:rgba(255,255,255,.03);
      border:1px solid var(--stroke2);
      border-radius:14px;
      padding:10px;
    }
    .itemHead{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .itemName{
      font-weight:800; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .itemBtns{ display:flex; gap:6px; }
    .tiny{ padding:6px 10px; border-radius:12px; font-size:12px; height:34px; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:14px;
      border:1px solid var(--stroke2); background:rgba(255,255,255,.03);
      font-size:12px; color:var(--muted);
      user-select:none;
    }
    .dot{ width:10px; height:10px; border-radius:999px; border:1px solid rgba(0,0,0,.35); }
    .canvasWrap{
      position:relative;
      height:100%;
      background:radial-gradient(900px 450px at 50% 15%, rgba(124,196,255,.10), transparent 60%),
                 radial-gradient(800px 520px at 15% 65%, rgba(57,217,138,.08), transparent 55%),
                 radial-gradient(700px 520px at 85% 70%, rgba(255,214,10,.07), transparent 55%),
                 linear-gradient(#070b12, #070b12);
      overflow:hidden;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .hud{
      position:absolute; left:12px; bottom:12px;
      display:flex; gap:8px; align-items:center;
      padding:8px 10px;
      border-radius:14px;
      background:rgba(11,18,32,.58);
      border:1px solid var(--stroke);
      backdrop-filter: blur(var(--blur));
      box-shadow: var(--shadow2);
      font-size:12px; color:var(--muted);
      z-index:5;
      user-select:none;
    }
    .modal{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:100;
      padding:20px;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(560px, 96vw);
      max-height:min(92vh, 760px);
      overflow:auto;
      background:rgba(14,22,38,.82);
      border:1px solid var(--stroke);
      border-radius:20px;
      backdrop-filter: blur(var(--blur));
      box-shadow: var(--shadow);
      padding:14px;
    }
    .modalTitle{ font-weight:900; font-size:14px; letter-spacing:.2px; margin-bottom:10px; }
    .field{ display:flex; flex-direction:column; gap:6px; }
    .label{ font-size:12px; color:var(--muted); }
    .hr{ height:1px; background:var(--stroke); margin:10px 0; }
    .toggle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px; border-radius:14px; border:1px solid var(--stroke2);
      background:rgba(255,255,255,.03);
    }
    .switch{
      width:46px; height:26px; border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid var(--stroke2);
      position:relative;
      flex:0 0 auto;
    }
    .switch:before{
      content:""; position:absolute; top:3px; left:3px;
      width:20px; height:20px; border-radius:50%;
      background:rgba(255,255,255,.75);
      transition: transform .18s ease;
    }
    .switch.on{ background:rgba(57,217,138,.20); border-color:rgba(57,217,138,.25); }
    .switch.on:before{ transform: translateX(20px); background:rgba(57,217,138,.95); }
    .inlineEditor{
      display:none;
      margin-top:8px;
      padding:10px;
      border-radius:14px;
      border:1px solid var(--stroke2);
      background:rgba(0,0,0,.12);
    }
    .inlineEditor.show{ display:block; }
    .warnText{ color:rgba(255,214,10,.92); font-size:12px; }
    .dangerText{ color:rgba(255,93,93,.92); font-size:12px; }
    .okText{ color:rgba(57,217,138,.95); font-size:12px; }
    @media (max-width: 960px){
      :root{ --leftW:260px; --rightW:300px; }
    }
    @media (max-width: 820px){
      :root{ --leftW:240px; --rightW:280px; --topH:56px; }
      .topTabs{ gap:6px; }
      .tabBtn{ padding:0 10px; }
      .logoBtn{ min-width:120px; }
    }
    @media (max-width: 720px){
      :root{ --leftW:220px; --rightW:260px; }
    }
    @media (max-width: 640px){
      :root{ --leftW:200px; --rightW:240px; }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <button class="logoBtn ghost" id="logoBtn" type="button">
      <img id="logoImg" class="logoImg" alt="" style="display:none">
      <div id="logoFallback" class="logoFallback">MAPMODE</div>
    </button>

    <div class="topTabs" id="contentTabs"></div>

    <div class="topActions">
      <button class="mini ghost" id="btnExport" type="button">state.json 내보내기</button>
      <button class="mini danger" id="btnResetAll" type="button">전체 초기화</button>
      <button class="mini" id="btnLogin" type="button">관리자 로그인</button>
    </div>
  </div>

  <div class="layout">
    <div class="panel left">
      <div class="panelInner">
        <div class="section">
          <div class="sectionTitle">
            <div>페이지</div>
            <span class="chip" id="activeCatChip">카테고리</span>
          </div>
          <div class="btnRow">
            <button class="tiny" id="btnAddPage" type="button">페이지 추가</button>
          </div>
          <div class="inlineEditor" id="pageAddEditor">
            <div class="col">
              <div class="field">
                <div class="label">페이지 이름</div>
                <input id="pageNewName" placeholder="예: 1번마을" />
              </div>
              <div class="field">
                <div class="label">지도 이미지 URL</div>
                <input id="pageNewUrl" placeholder="예: ./assets/maps/map1.png" />
              </div>
              <div class="row">
                <button class="tiny ok" id="pageAddConfirm" type="button">추가</button>
                <button class="tiny ghost" id="pageAddCancel" type="button">취소</button>
              </div>
            </div>
          </div>
          <div class="hr"></div>
          <div class="list" id="pageList"></div>
        </div>

        <div class="section">
          <div class="sectionTitle">
            <div>구글 로그인 (비활성 구조)</div>
          </div>
          <div class="toggle">
            <div class="muted">Enable/Disable 토글만 존재</div>
            <div class="switch" id="swGoogle"></div>
          </div>
        </div>

        <div class="section">
          <div class="sectionTitle">
            <div>결제 (비활성 구조)</div>
          </div>
          <div class="toggle">
            <div class="muted">Enable/Disable 토글만 존재</div>
            <div class="switch" id="swPay"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="canvasWrap">
      <canvas id="cv"></canvas>
      <div class="hud" id="hud">Ready</div>
    </div>

    <div class="panel right">
      <div class="panelInner">
        <div class="section">
          <div class="sectionTitle">
            <div>마커 카테고리</div>
            <button class="tiny ghost" id="btnEditMarkerCats" type="button">편집</button>
          </div>
          <div class="btnRow" style="margin-bottom:8px">
            <button class="tiny ghost" id="btnToggleAllMarkerCats" type="button">전체</button>
            <button class="tiny" id="btnAddMarkerCat" type="button">추가</button>
          </div>
          <div class="inlineEditor" id="markerCatAddEditor">
            <div class="col">
              <div class="field">
                <div class="label">카테고리 이름</div>
                <input id="markerCatNewName" placeholder="예: 길찾기" />
              </div>
              <div class="row">
                <button class="tiny ok" id="markerCatAddConfirm" type="button">추가</button>
                <button class="tiny ghost" id="markerCatAddCancel" type="button">취소</button>
              </div>
            </div>
          </div>
          <div class="list" id="markerCatList"></div>
        </div>

        <div class="section">
          <div class="sectionTitle">
            <div>관리자 툴</div>
          </div>
          <div class="grid2">
            <button class="tiny ghost" id="btnLinesHide" type="button">모든 선 제거</button>
            <button class="tiny ghost" id="btnLinesShow" type="button">모든 선 표시</button>
            <button class="tiny danger" id="btnMarkersClear" type="button">마커 초기화</button>
            <button class="tiny ghost" id="btnEditMarker" type="button">마커 편집</button>
          </div>
          <div class="hr"></div>
          <div class="grid2">
            <button class="tiny ghost" id="btnHideNumsInCat" type="button">마커 숫자 가리기</button>
            <div class="pill"><span class="muted">선택 마커:</span><span id="selMarkerName" style="color:var(--text);font-weight:800;max-width:140px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">없음</span></div>
          </div>
          <div class="hr"></div>
          <div class="col">
            <div class="muted">빠른 색상표</div>
            <div class="btnRow" id="quickColors"></div>
          </div>
        </div>

        <div class="section">
          <div class="sectionTitle">
            <div>유튜브 링크</div>
          </div>
          <div class="col">
            <div class="field">
              <div class="label">표시 이름</div>
              <input id="ytTitle" placeholder="예: 공략 영상" />
            </div>
            <div class="field">
              <div class="label">설명 텍스트</div>
              <textarea id="ytDesc" rows="3" placeholder="예: 2분 요약"></textarea>
            </div>
            <div class="field">
              <div class="label">URL</div>
              <input id="ytUrl" placeholder="https://youtube.com/..." />
            </div>
            <button class="tiny ok" id="ytApplyToMarker" type="button">선택 마커에 적용</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="modalLogin">
    <div class="modalCard">
      <div class="modalTitle">관리자 로그인</div>
      <div class="col">
        <div class="field">
          <div class="label">비밀번호</div>
          <input id="loginPw" type="password" inputmode="numeric" autocomplete="off" />
        </div>
        <div class="row">
          <button class="ok" id="loginOk" type="button">로그인</button>
          <button class="ghost" id="loginCancel" type="button">닫기</button>
        </div>
        <div class="muted">인증은 24시간 유지됩니다.</div>
      </div>
    </div>
  </div>

  <div class="modal" id="modalLogo">
    <div class="modalCard">
      <div class="modalTitle">로고 URL</div>
      <div class="col">
        <div class="field">
          <div class="label">로고 이미지 URL</div>
          <input id="logoUrlInput" placeholder="예: ./assets/logo/logo.png" />
        </div>
        <div class="row">
          <button class="ok" id="logoSave" type="button">저장</button>
          <button class="ghost" id="logoClose" type="button">닫기</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="modalMarkerEdit">
    <div class="modalCard">
      <div class="modalTitle">마커 편집</div>
      <div class="col" style="gap:10px">
        <div class="grid2">
          <div class="field">
            <div class="label">마커 이름</div>
            <input id="mkName" />
          </div>
          <div class="field">
            <div class="label">카테고리</div>
            <select id="mkCat"></select>
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <div class="label">유튜브 표시명</div>
            <input id="mkYtName" />
          </div>
          <div class="field">
            <div class="label">유튜브 URL</div>
            <input id="mkYtUrl" />
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <div class="label">마커 원 크기 (1~100)</div>
            <input id="mkSize" type="range" min="1" max="100" />
          </div>
          <div class="field">
            <div class="label">텍스트 크기 (원 크기 비율 연동)</div>
            <input id="mkText" type="range" min="6" max="80" />
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <div class="label">텍스트 굵기</div>
            <select id="mkWeight">
              <option value="400">400</option>
              <option value="500">500</option>
              <option value="600">600</option>
              <option value="700">700</option>
              <option value="800">800</option>
              <option value="900">900</option>
            </select>
          </div>
          <div class="field">
            <div class="label">글씨 색</div>
            <input id="mkTextColor" placeholder="#ffffff 또는 rgb(255,255,255)" />
          </div>
        </div>

        <div class="section" style="margin:0">
          <div class="sectionTitle" style="margin-bottom:8px">
            <div>빠른 색상표</div>
          </div>
          <div class="btnRow" id="mkQuickTextColors"></div>
        </div>

        <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:wrap">
          <div class="btnRow">
            <button class="ghost" id="mkStartNew" type="button">새로운 번호로 시작</button>
            <button class="ghost" id="mkStartFromHere" type="button">해당 마커를 이어서 시작</button>
          </div>
          <div class="btnRow">
            <button class="danger" id="mkDelete" type="button">삭제</button>
            <button class="ok" id="mkSave" type="button">저장</button>
            <button class="ghost" id="mkClose" type="button">닫기</button>
          </div>
        </div>

        <div class="muted">Enter 키로 저장 및 닫기</div>
      </div>
    </div>
  </div>

  <div class="modal" id="modalMarkerCats">
    <div class="modalCard">
      <div class="modalTitle">카테고리/색상 편집</div>
      <div class="col">
        <div class="muted">빠른 색상표</div>
        <div class="btnRow" id="catQuickColors"></div>
        <div class="hr"></div>
        <div class="list" id="catEditList"></div>
        <div class="row" style="justify-content:flex-end">
          <button class="ghost" id="catEditClose" type="button">닫기</button>
        </div>
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  const LS_AUTH_KEY = "mapmode_admin_auth_v99";
  const LS_KEY = "mapmode_state_v99";
  const PASSWORD = "0000000001";
  const AUTH_MS = 24 * 60 * 60 * 1000;
  const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

  const el = (id) => document.getElementById(id);
  const cv = el("cv");
  const ctx = cv.getContext("2d");

  const ui = {
    hud: el("hud"),
    contentTabs: el("contentTabs"),
    activeCatChip: el("activeCatChip"),
    pageList: el("pageList"),
    btnAddPage: el("btnAddPage"),
    pageAddEditor: el("pageAddEditor"),
    pageNewName: el("pageNewName"),
    pageNewUrl: el("pageNewUrl"),
    pageAddConfirm: el("pageAddConfirm"),
    pageAddCancel: el("pageAddCancel"),

    markerCatList: el("markerCatList"),
    btnAddMarkerCat: el("btnAddMarkerCat"),
    markerCatAddEditor: el("markerCatAddEditor"),
    markerCatNewName: el("markerCatNewName"),
    markerCatAddConfirm: el("markerCatAddConfirm"),
    markerCatAddCancel: el("markerCatAddCancel"),
    btnToggleAllMarkerCats: el("btnToggleAllMarkerCats"),
    btnEditMarkerCats: el("btnEditMarkerCats"),

    btnLinesHide: el("btnLinesHide"),
    btnLinesShow: el("btnLinesShow"),
    btnMarkersClear: el("btnMarkersClear"),
    btnHideNumsInCat: el("btnHideNumsInCat"),
    btnEditMarker: el("btnEditMarker"),
    selMarkerName: el("selMarkerName"),

    ytTitle: el("ytTitle"),
    ytDesc: el("ytDesc"),
    ytUrl: el("ytUrl"),
    ytApplyToMarker: el("ytApplyToMarker"),

    btnExport: el("btnExport"),
    btnResetAll: el("btnResetAll"),
    btnLogin: el("btnLogin"),

    logoBtn: el("logoBtn"),
    logoImg: el("logoImg"),
    logoFallback: el("logoFallback"),
    modalLogo: el("modalLogo"),
    logoUrlInput: el("logoUrlInput"),
    logoSave: el("logoSave"),
    logoClose: el("logoClose"),

    swGoogle: el("swGoogle"),
    swPay: el("swPay"),

    modalLogin: el("modalLogin"),
    loginPw: el("loginPw"),
    loginOk: el("loginOk"),
    loginCancel: el("loginCancel"),

    modalMarkerEdit: el("modalMarkerEdit"),
    mkName: el("mkName"),
    mkCat: el("mkCat"),
    mkYtName: el("mkYtName"),
    mkYtUrl: el("mkYtUrl"),
    mkSize: el("mkSize"),
    mkText: el("mkText"),
    mkWeight: el("mkWeight"),
    mkTextColor: el("mkTextColor"),
    mkStartNew: el("mkStartNew"),
    mkStartFromHere: el("mkStartFromHere"),
    mkDelete: el("mkDelete"),
    mkSave: el("mkSave"),
    mkClose: el("mkClose"),
    mkQuickTextColors: el("mkQuickTextColors"),

    modalMarkerCats: el("modalMarkerCats"),
    catQuickColors: el("catQuickColors"),
    catEditList: el("catEditList"),
    catEditClose: el("catEditClose"),

    quickColors: el("quickColors")
  };

  const quickPalette = [
    {name:"빨", v:"#ff5d5d"},
    {name:"주", v:"#ff9f3d"},
    {name:"노", v:"#ffd60a"},
    {name:"초", v:"#39d98a"},
    {name:"파", v:"#4aa3ff"},
    {name:"흰", v:"#ffffff"},
    {name:"검", v:"#0b0f16"}
  ];

  const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : ("id_"+Math.random().toString(16).slice(2)+Date.now().toString(16)));
  const clamp = (n,a,b) => Math.max(a, Math.min(b, n));
  const now = () => Date.now();

  const defaultState = () => ({
    version: 1,
    logoUrl: "",
    flags: { googleEnabled: false, payEnabled: false },
    contentCats: [
      { id: "cat1", name: "카테고리1", pages: [] },
      { id: "cat2", name: "카테고리2", pages: [] },
      { id: "cat3", name: "카테고리3", pages: [] },
      { id: "cat4", name: "카테고리4", pages: [] }
    ],
    active: { contentCatId: "cat1", pageId: "", markerCatId: "" },
    markerCats: [
      { id: "mcat1", name: "기본", color: "#ffd60a", visible: true, hideNumbers: false, base: { size: 26, text: 14, weight: 800, textColor: "#e7eef8", ratio: 14/26 } }
    ],
    markers: [],
    curves: [],
    view: { x: 0, y: 0, z: 1 },
    linesVisible: true
  });

  let state = defaultState();
  let authed = false;

  const authLoad = () => {
    try{
      const raw = localStorage.getItem(LS_AUTH_KEY);
      if(!raw) return false;
      const obj = JSON.parse(raw);
      if(!obj || !obj.t) return false;
      if((now() - obj.t) > AUTH_MS) return false;
      return true;
    }catch(e){ return false; }
  };
  const authSave = () => {
    localStorage.setItem(LS_AUTH_KEY, JSON.stringify({ t: now() }));
  };

  const saveLocalState = () => {
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  };

  const loadLocalState = () => {
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(!obj) return null;
      return obj;
    }catch(e){ return null; }
  };

  const mergeState = (base, incoming) => {
    const out = defaultState();
    const b = base || out;
    const i = incoming || {};
    const pick = (k, def) => (i[k] !== undefined ? i[k] : (b[k] !== undefined ? b[k] : def));
    out.version = pick("version", 1);
    out.logoUrl = pick("logoUrl", "");
    out.flags = { ...out.flags, ...(b.flags||{}), ...(i.flags||{}) };
    out.contentCats = Array.isArray(i.contentCats) ? i.contentCats : (Array.isArray(b.contentCats) ? b.contentCats : out.contentCats);
    out.active = { ...out.active, ...(b.active||{}), ...(i.active||{}) };
    out.markerCats = Array.isArray(i.markerCats) ? i.markerCats : (Array.isArray(b.markerCats) ? b.markerCats : out.markerCats);
    out.markers = Array.isArray(i.markers) ? i.markers : (Array.isArray(b.markers) ? b.markers : []);
    out.curves = Array.isArray(i.curves) ? i.curves : (Array.isArray(b.curves) ? b.curves : []);
    out.view = { ...out.view, ...(b.view||{}), ...(i.view||{}) };
    out.linesVisible = (i.linesVisible !== undefined ? i.linesVisible : (b.linesVisible !== undefined ? b.linesVisible : true));
    return out;
  };

  const fetchRemoteState = async () => {
    try{
      const res = await fetch(REMOTE_STATE_URL, { cache: "no-store" });
      if(!res.ok) throw new Error("fetch fail");
      const obj = await res.json();
      return obj;
    }catch(e){
      return null;
    }
  };

  const ensureActiveIds = () => {
    if(!state.contentCats?.length) state.contentCats = defaultState().contentCats;
    if(!state.active) state.active = defaultState().active;

    const cat = state.contentCats.find(c => c.id === state.active.contentCatId) || state.contentCats[0];
    state.active.contentCatId = cat.id;

    if(!cat.pages) cat.pages = [];
    if(!state.active.pageId && cat.pages[0]) state.active.pageId = cat.pages[0].id;
    if(state.active.pageId && !cat.pages.find(p => p.id === state.active.pageId)){
      state.active.pageId = cat.pages[0] ? cat.pages[0].id : "";
    }

    if(!state.markerCats?.length) state.markerCats = defaultState().markerCats;
    if(!state.active.markerCatId) state.active.markerCatId = state.markerCats[0].id;
    if(state.active.markerCatId && !state.markerCats.find(m => m.id === state.active.markerCatId)){
      state.active.markerCatId = state.markerCats[0].id;
    }
  };

  const getActiveContentCat = () => state.contentCats.find(c => c.id === state.active.contentCatId);
  const getActivePage = () => {
    const cat = getActiveContentCat();
    if(!cat) return null;
    return cat.pages.find(p => p.id === state.active.pageId) || null;
  };

  const getMarkerCat = (id) => state.markerCats.find(m => m.id === id);
  const getActiveMarkerCat = () => getMarkerCat(state.active.markerCatId);

  let mapImg = new Image();
  mapImg.crossOrigin = "anonymous";
  let mapImgReady = false;
  let mapImgUrl = "";

  const loadMapImage = (url) => {
    mapImgReady = false;
    mapImgUrl = url || "";
    if(!mapImgUrl){
      requestRender();
      return;
    }
    const im = new Image();
    im.crossOrigin = "anonymous";
    im.onload = () => { mapImg = im; mapImgReady = true; requestRender(); };
    im.onerror = () => { mapImgReady = false; requestRender(); };
    im.src = mapImgUrl;
  };

  const setHud = (t) => { ui.hud.textContent = t; };

  const setSwitch = (swEl, on) => {
    if(on) swEl.classList.add("on"); else swEl.classList.remove("on");
  };

  const downloadText = (filename, text) => {
    const blob = new Blob([text], { type:"application/json;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 5000);
  };

  const recalcMarkerCatBaseIfNeeded = (markerCatId) => {
    const mc = getMarkerCat(markerCatId);
    if(!mc) return;
    const m1 = state.markers
      .filter(m => m.markerCatId === markerCatId)
      .filter(m => m.num === 1)
      .sort((a,b)=> (a.createdAt||0)-(b.createdAt||0))[0];
    if(!m1) return;
    const ratio = (m1.textSize && m1.size) ? (m1.textSize / m1.size) : (mc.base?.ratio || (14/26));
    mc.base = {
      size: m1.size || mc.base.size || 26,
      text: m1.textSize || mc.base.text || 14,
      weight: m1.weight || mc.base.weight || 800,
      textColor: m1.textColor || mc.base.textColor || "#e7eef8",
      ratio
    };
    mc.color = m1.color || mc.color;
    state.markers.forEach(m => {
      if(m.markerCatId !== markerCatId) return;
      m.color = mc.color;
      m.size = mc.base.size;
      m.textSize = Math.round(mc.base.size * (mc.base.ratio || ratio));
      m.weight = mc.base.weight;
      m.textColor = mc.base.textColor;
    });
  };

  const applyMarkerCatColor = (markerCatId, color) => {
    const mc = getMarkerCat(markerCatId);
    if(!mc) return;
    mc.color = color;
    state.markers.forEach(m => {
      if(m.markerCatId !== markerCatId) return;
      m.color = color;
    });
  };

  const ensureCurveBetween = (aId, bId) => {
    const key = aId < bId ? (aId+"|"+bId) : (bId+"|"+aId);
    let c = state.curves.find(x => x.key === key);
    if(c) return c;
    const a = state.markers.find(m => m.id === aId);
    const b = state.markers.find(m => m.id === bId);
    if(!a || !b) return null;
    c = { key, aId, bId, cx: (a.x+b.x)/2, cy: (a.y+b.y)/2 };
    state.curves.push(c);
    return c;
  };

  const curveFor = (aId, bId) => {
    const key = aId < bId ? (aId+"|"+bId) : (bId+"|"+aId);
    return state.curves.find(x => x.key === key) || null;
  };

  const removeCurvesWithMarker = (mid) => {
    state.curves = state.curves.filter(c => c.aId !== mid && c.bId !== mid);
  };

  const markersInActivePage = () => {
    const page = getActivePage();
    if(!page) return [];
    return state.markers.filter(m => m.pageId === page.id && m.contentCatId === state.active.contentCatId);
  };

  const buildConnections = () => {
    const ms = markersInActivePage().slice();
    const byGroup = new Map();
    for(const m of ms){
      const k = m.groupId || "g0";
      if(!byGroup.has(k)) byGroup.set(k, []);
      byGroup.get(k).push(m);
    }
    const conns = [];
    for(const [gid, arr] of byGroup){
      arr.sort((a,b)=> (a.num||0)-(b.num||0));
      for(let i=0;i<arr.length-1;i++){
        conns.push({ a: arr[i], b: arr[i+1] });
        ensureCurveBetween(arr[i].id, arr[i+1].id);
      }
    }
    return conns;
  };

  let activeGroupId = uid();
  let lastMarkerId = null;
  let nextNum = 1;

  const resetSequence = () => {
    activeGroupId = uid();
    lastMarkerId = null;
    nextNum = 1;
  };

  const setSequenceFromMarker = (m) => {
    if(!m) return;
    activeGroupId = m.groupId || uid();
    lastMarkerId = m.id;
    nextNum = (m.num || 0) + 1;
  };

  const addMarkerAt = (wx, wy) => {
    const page = getActivePage();
    if(!page) return;
    const mc = getActiveMarkerCat();
    if(!mc) return;

    const base = mc.base || { size:26, ratio:14/26, weight:800, textColor:"#e7eef8", text:14 };
    const size = clamp(base.size || 26, 1, 100);
    const textSize = clamp(Math.round(size * (base.ratio || (14/26))), 6, 80);
    const m = {
      id: uid(),
      contentCatId: state.active.contentCatId,
      pageId: page.id,
      markerCatId: mc.id,
      groupId: activeGroupId,
      num: nextNum,
      x: wx,
      y: wy,
      name: "마커 " + nextNum,
      ytName: "",
      ytUrl: "",
      size,
      textSize,
      weight: base.weight || 800,
      textColor: base.textColor || "#e7eef8",
      color: mc.color || "#ffd60a",
      selected: false,
      createdAt: now()
    };
    state.markers.push(m);
    if(nextNum === 1){
      recalcMarkerCatBaseIfNeeded(mc.id);
    }
    const prev = lastMarkerId;
    lastMarkerId = m.id;
    nextNum += 1;

    if(prev){
      ensureCurveBetween(prev, m.id);
    }
    saveLocalState();
    requestRender();
  };

  const toggleMarkerSelected = (m) => {
    m.selected = !m.selected;
    saveLocalState();
    requestRender();
  };

  const clearAllMarkersInActivePage = () => {
    const page = getActivePage();
    if(!page) return;
    state.markers = state.markers.filter(m => !(m.pageId === page.id && m.contentCatId === state.active.contentCatId));
    state.curves = state.curves.filter(c => {
      const a = state.markers.find(m => m.id === c.aId);
      const b = state.markers.find(m => m.id === c.bId);
      return !!(a && b);
    });
    resetSequence();
    selectedMarkerId = null;
    ui.selMarkerName.textContent = "없음";
    saveLocalState();
    requestRender();
  };

  const updateSelectedMarkerName = () => {
    const m = getSelectedMarker();
    ui.selMarkerName.textContent = m ? (m.name || ("마커 "+(m.num||""))) : "없음";
  };

  const fitViewIfNeeded = () => {
    if(state.view && typeof state.view.x === "number" && typeof state.view.y === "number" && typeof state.view.z === "number") return;
    state.view = { x:0, y:0, z:1 };
  };

  const worldToScreen = (wx, wy) => {
    const z = state.view.z;
    return { x: (wx - state.view.x) * z, y: (wy - state.view.y) * z };
  };
  const screenToWorld = (sx, sy) => {
    const z = state.view.z;
    return { x: sx / z + state.view.x, y: sy / z + state.view.y };
  };

  const resize = () => {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = cv.getBoundingClientRect();
    cv.width = Math.round(rect.width * dpr);
    cv.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    requestRender();
  };

  let renderPending = false;
  const requestRender = () => {
    if(renderPending) return;
    renderPending = true;
    requestAnimationFrame(() => {
      renderPending = false;
      render();
    });
  };

  const drawRoundedRect = (x,y,w,h,r) => {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  };

  const parseColor = (s, fallback) => {
    if(!s) return fallback;
    const t = String(s).trim();
    if(!t) return fallback;
    return t;
  };

  const render = () => {
    fitViewIfNeeded();
    const rect = cv.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0,0,w,h);

    const page = getActivePage();
    if(page && page.url && page.url !== mapImgUrl){
      loadMapImage(page.url);
    }
    if(mapImgReady){
      const z = state.view.z;
      const x = (-state.view.x) * z;
      const y = (-state.view.y) * z;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(mapImg, x, y, mapImg.width * z, mapImg.height * z);
    } else {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.04)";
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      drawRoundedRect(20, 20, w-40, h-40, 18);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(159,176,198,.85)";
      ctx.font = "800 14px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
      ctx.fillText(page ? "지도 이미지 로딩/없음" : "페이지를 추가하세요", 40, 56);
      ctx.restore();
    }

    const mcAllVisible = allMarkerCatsVisible();
    const conns = buildConnections();

    if(state.linesVisible){
      for(const {a,b} of conns){
        const ca = getMarkerCat(a.markerCatId);
        const cb = getMarkerCat(b.markerCatId);
        if(!ca || !cb) continue;
        if(!mcAllVisible) {
          if(!ca.visible || !cb.visible) continue;
        }
        const c = curveFor(a.id, b.id);
        if(!c) continue;
        drawCurve(a, b, c, ca.color);
      }
    }

    const ms = markersInActivePage();
    ms.sort((m1,m2)=> (m1.num||0)-(m2.num||0));
    for(const m of ms){
      const mc = getMarkerCat(m.markerCatId);
      if(!mc) continue;
      if(!mcAllVisible && !mc.visible) continue;
      drawMarker(m, mc);
    }

    setHud(`줌 ${Math.round(state.view.z*100)}% · 마커 ${ms.length}`);
  };

  const allMarkerCatsVisible = () => {
    return !!state._allMarkerCats;
  };

  const drawCurve = (a, b, c, color) => {
    const sa = worldToScreen(a.x, a.y);
    const sb = worldToScreen(b.x, b.y);
    const sc = worldToScreen(c.cx, c.cy);

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sa.x, sa.y);
    ctx.quadraticCurveTo(sc.x, sc.y, sb.x, sb.y);
    ctx.stroke();

    const t = 0.97;
    const p = quadPoint(sa, sc, sb, t);
    const d = quadTangent(sa, sc, sb, t);
    const ang = Math.atan2(d.y, d.x);
    const arrowLen = 10;
    const arrowW = 6;
    ctx.fillStyle = "rgba(255,255,255,.65)";
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x - Math.cos(ang)*arrowLen + Math.cos(ang+Math.PI/2)*arrowW, p.y - Math.sin(ang)*arrowLen + Math.sin(ang+Math.PI/2)*arrowW);
    ctx.lineTo(p.x - Math.cos(ang)*arrowLen + Math.cos(ang-Math.PI/2)*arrowW, p.y - Math.sin(ang)*arrowLen + Math.sin(ang-Math.PI/2)*arrowW);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  };

  const quadPoint = (p0, p1, p2, t) => {
    const u = 1-t;
    return {
      x: u*u*p0.x + 2*u*t*p1.x + t*t*p2.x,
      y: u*u*p0.y + 2*u*t*p1.y + t*t*p2.y
    };
  };
  const quadTangent = (p0, p1, p2, t) => {
    return {
      x: 2*(1-t)*(p1.x - p0.x) + 2*t*(p2.x - p1.x),
      y: 2*(1-t)*(p1.y - p0.y) + 2*t*(p2.y - p1.y)
    };
  };

  const drawMarker = (m, mc) => {
    const s = worldToScreen(m.x, m.y);
    const z = state.view.z;

    const radius = (m.size || 26) * z;
    const alpha = m.selected ? 0.30 : 1.0;

    ctx.save();
    ctx.globalAlpha = alpha;

    ctx.beginPath();
    ctx.arc(s.x, s.y, radius, 0, Math.PI*2);
    ctx.fillStyle = parseColor(m.color || mc.color, mc.color || "#ffd60a");
    ctx.fill();

    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.lineWidth = Math.max(1, 2*z);
    ctx.stroke();

    const hideNum = !!mc.hideNumbers;
    if(!hideNum){
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#000000";
      const fz = Math.max(8, (m.textSize || 14) * z);
      const fw = (m.weight || 800);
      ctx.font = `${fw} ${fz}px ${getComputedStyle(document.documentElement).getPropertyValue("--font")}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(m.num || ""), s.x, s.y);
    }

    ctx.globalAlpha = 1;
    ctx.fillStyle = parseColor(m.textColor || "#e7eef8", "#e7eef8");
    const labelSize = Math.max(10, Math.round((m.textSize || 14) * z));
    ctx.font = `${m.weight || 800} ${labelSize}px ${getComputedStyle(document.documentElement).getPropertyValue("--font")}`;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const label = m.name || "";
    const tx = s.x + radius + 10;
    const ty = s.y;
    ctx.fillText(label, tx, ty);

    ctx.restore();
  };

  let pointer = {
    down:false,
    mode:"",
    sx:0, sy:0,
    wx:0, wy:0,
    vx0:0, vy0:0,
    z0:1,
    moved:false,
    activeId:null,
    curveKey:null
  };

  let selectedMarkerId = null;
  const getSelectedMarker = () => {
    const ms = markersInActivePage();
    return ms.find(m => m.id === selectedMarkerId) || null;
  };

  const hitMarker = (sx, sy) => {
    const ms = markersInActivePage();
    for(let i=ms.length-1;i>=0;i--){
      const m = ms[i];
      const mc = getMarkerCat(m.markerCatId);
      if(!mc) continue;
      if(!state._allMarkerCats && !mc.visible) continue;
      const s = worldToScreen(m.x, m.y);
      const r = (m.size || 26) * state.view.z;
      const dx = sx - s.x, dy = sy - s.y;
      if(dx*dx + dy*dy <= r*r) return m;
    }
    return null;
  };

  const distToQuad = (p0,p1,p2, p) => {
    let best = Infinity;
    let bestT = 0;
    for(let i=0;i<=32;i++){
      const t = i/32;
      const q = quadPoint(p0,p1,p2,t);
      const dx = p.x-q.x, dy = p.y-q.y;
      const d = Math.sqrt(dx*dx+dy*dy);
      if(d<best){ best=d; bestT=t; }
    }
    return { d: best, t: bestT };
  };

  const hitCurve = (sx, sy) => {
    if(!state.linesVisible) return null;
    const conns = buildConnections();
    const p = { x:sx, y:sy };
    for(let i=conns.length-1;i>=0;i--){
      const {a,b} = conns[i];
      const ca = getMarkerCat(a.markerCatId);
      const cb = getMarkerCat(b.markerCatId);
      if(!ca || !cb) continue;
      if(!state._allMarkerCats){
        if(!ca.visible || !cb.visible) continue;
      }
      const c = curveFor(a.id, b.id);
      if(!c) continue;
      const sa = worldToScreen(a.x, a.y);
      const sb = worldToScreen(b.x, b.y);
      const sc = worldToScreen(c.cx, c.cy);
      const r = distToQuad(sa, sc, sb, p);
      if(r.d <= 10) return { c, a, b };
    }
    return null;
  };

  const wheelZoom = (sx, sy, delta) => {
    const z0 = state.view.z;
    const z1 = clamp(z0 * (delta > 0 ? 0.92 : 1.08), 0.2, 6);
    const w0 = screenToWorld(sx, sy);
    state.view.z = z1;
    const w1 = screenToWorld(sx, sy);
    state.view.x += (w0.x - w1.x);
    state.view.y += (w0.y - w1.y);
    saveLocalState();
    requestRender();
  };

  const openModal = (m) => m.classList.add("show");
  const closeModal = (m) => m.classList.remove("show");

  const openMarkerEdit = (marker) => {
    if(!marker) return;
    selectedMarkerId = marker.id;
    updateSelectedMarkerName();

    ui.mkCat.innerHTML = "";
    for(const mc of state.markerCats){
      const opt = document.createElement("option");
      opt.value = mc.id;
      opt.textContent = mc.name;
      ui.mkCat.appendChild(opt);
    }
    ui.mkName.value = marker.name || "";
    ui.mkCat.value = marker.markerCatId || state.active.markerCatId;
    ui.mkYtName.value = marker.ytName || marker.name || "";
    ui.mkYtUrl.value = marker.ytUrl || "";
    ui.mkSize.value = clamp(marker.size || 26, 1, 100);
    ui.mkText.value = clamp(marker.textSize || Math.round((marker.size||26)*(14/26)), 6, 80);
    ui.mkWeight.value = String(marker.weight || 800);
    ui.mkTextColor.value = marker.textColor || "#e7eef8";

    openModal(ui.modalMarkerEdit);
    ui.mkName.focus();
  };

  const closeMarkerEdit = () => closeModal(ui.modalMarkerEdit);

  const setupQuickButtons = () => {
    ui.quickColors.innerHTML = "";
    for(const c of quickPalette){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tiny ghost";
      b.style.display = "inline-flex";
      b.style.alignItems = "center";
      b.style.gap = "8px";
      b.innerHTML = `<span class="dot" style="background:${c.v}"></span><span>${c.name}</span>`;
      b.onclick = () => {
        const m = getSelectedMarker();
        if(!m) return;
        m.textColor = c.v;
        ui.mkTextColor.value = c.v;
        saveLocalState();
        requestRender();
      };
      ui.quickColors.appendChild(b);
    }

    ui.mkQuickTextColors.innerHTML = "";
    for(const c of quickPalette){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tiny ghost";
      b.style.display = "inline-flex";
      b.style.alignItems = "center";
      b.style.gap = "8px";
      b.innerHTML = `<span class="dot" style="background:${c.v}"></span><span>${c.name}</span>`;
      b.onclick = () => ui.mkTextColor.value = c.v;
      ui.mkQuickTextColors.appendChild(b);
    }

    ui.catQuickColors.innerHTML = "";
    for(const c of quickPalette){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tiny ghost";
      b.style.display = "inline-flex";
      b.style.alignItems = "center";
      b.style.gap = "8px";
      b.innerHTML = `<span class="dot" style="background:${c.v}"></span><span>${c.name}</span>`;
      b.onclick = () => {
        const active = ui.modalMarkerCats.dataset.activeCatId;
        if(!active) return;
        applyMarkerCatColor(active, c.v);
        saveLocalState();
        renderMarkerCatUI();
        renderMarkerCatEditor();
        requestRender();
      };
      ui.catQuickColors.appendChild(b);
    }
  };

  const renderContentTabs = () => {
    ui.contentTabs.innerHTML = "";
    state.contentCats.forEach((c, idx) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "tabBtn" + (c.id === state.active.contentCatId ? " active" : "");
      const pagesCount = (c.pages || []).length;
      b.innerHTML = `<span style="font-weight:900">${c.name}</span><span class="chip">${pagesCount}</span>`;
      b.onclick = () => {
        state.active.contentCatId = c.id;
        ensureActiveIds();
        const page = getActivePage();
        loadMapImage(page ? page.url : "");
        selectedMarkerId = null;
        updateSelectedMarkerName();
        resetSequence();
        saveLocalState();
        renderAllUI();
        requestRender();
      };
      ui.contentTabs.appendChild(b);
    });
    const ac = getActiveContentCat();
    ui.activeCatChip.textContent = ac ? ac.name : "카테고리";
  };

  const renderPages = () => {
    const cat = getActiveContentCat();
    ui.pageList.innerHTML = "";
    if(!cat) return;
    (cat.pages || []).forEach(p => {
      const wrap = document.createElement("div");
      wrap.className = "item";
      const head = document.createElement("div");
      head.className = "itemHead";
      const name = document.createElement("div");
      name.className = "itemName";
      name.textContent = p.name || "페이지";
      const btns = document.createElement("div");
      btns.className = "itemBtns";
      const go = document.createElement("button");
      go.type = "button";
      go.className = "tiny ghost";
      go.textContent = (p.id === state.active.pageId ? "선택됨" : "열기");
      go.onclick = () => {
        state.active.pageId = p.id;
        selectedMarkerId = null;
        updateSelectedMarkerName();
        resetSequence();
        saveLocalState();
        loadMapImage(p.url || "");
        renderPages();
        requestRender();
      };
      const edit = document.createElement("button");
      edit.type = "button";
      edit.className = "tiny";
      edit.textContent = "수정";
      edit.onclick = () => {
        const editor = document.createElement("div");
        editor.className = "inlineEditor show";
        editor.style.marginTop = "10px";
        editor.innerHTML = `
          <div class="col">
            <div class="field"><div class="label">이름</div><input value="${escapeHtml(p.name||"")}" data-k="name"></div>
            <div class="field"><div class="label">URL</div><input value="${escapeHtml(p.url||"")}" data-k="url"></div>
            <div class="row">
              <button class="tiny ok" type="button" data-act="save">저장</button>
              <button class="tiny ghost" type="button" data-act="cancel">취소</button>
            </div>
          </div>
        `;
        wrap.appendChild(editor);
        const inputs = editor.querySelectorAll("input");
        editor.querySelector('[data-act="save"]').onclick = () => {
          const nv = {};
          inputs.forEach(inp => nv[inp.dataset.k] = inp.value.trim());
          p.name = nv.name || p.name;
          p.url = nv.url || p.url;
          if(p.id === state.active.pageId){
            loadMapImage(p.url || "");
          }
          saveLocalState();
          renderPages();
          requestRender();
        };
        editor.querySelector('[data-act="cancel"]').onclick = () => {
          editor.remove();
        };
        edit.disabled = true;
        setTimeout(()=>{ edit.disabled = false; }, 100);
      };
      const del = document.createElement("button");
      del.type = "button";
      del.className = "tiny danger";
      del.textContent = "삭제";
      del.onclick = () => {
        cat.pages = cat.pages.filter(x => x.id !== p.id);
        state.markers = state.markers.filter(m => !(m.pageId === p.id && m.contentCatId === cat.id));
        state.curves = state.curves.filter(cu => {
          const a = state.markers.find(m => m.id === cu.aId);
          const b = state.markers.find(m => m.id === cu.bId);
          return !!(a && b);
        });
        ensureActiveIds();
        const ap = getActivePage();
        loadMapImage(ap ? ap.url : "");
        resetSequence();
        selectedMarkerId = null;
        updateSelectedMarkerName();
        saveLocalState();
        renderAllUI();
        requestRender();
      };
      btns.appendChild(go);
      btns.appendChild(edit);
      btns.appendChild(del);
      head.appendChild(name);
      head.appendChild(btns);
      wrap.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "muted";
      meta.style.marginTop = "8px";
      meta.textContent = p.url ? p.url : "URL 없음";
      wrap.appendChild(meta);

      ui.pageList.appendChild(wrap);
    });
  };

  const renderMarkerCatUI = () => {
    ui.markerCatList.innerHTML = "";
    state.markerCats.forEach(mc => {
      const wrap = document.createElement("div");
      wrap.className = "item";
      const head = document.createElement("div");
      head.className = "itemHead";
      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "10px";
      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = mc.color || "#ffd60a";
      const name = document.createElement("div");
      name.className = "itemName";
      name.textContent = mc.name || "카테고리";
      left.appendChild(dot);
      left.appendChild(name);

      const btns = document.createElement("div");
      btns.className = "itemBtns";

      const pick = document.createElement("button");
      pick.type = "button";
      pick.className = "tiny" + (mc.id === state.active.markerCatId ? " ok" : "");
      pick.textContent = (mc.id === state.active.markerCatId ? "선택" : "선택");
      pick.onclick = () => {
        state.active.markerCatId = mc.id;
        saveLocalState();
        renderMarkerCatUI();
      };

      const vis = document.createElement("button");
      vis.type = "button";
      vis.className = "tiny ghost";
      vis.textContent = mc.visible ? "ON" : "OFF";
      vis.onclick = () => {
        mc.visible = !mc.visible;
        saveLocalState();
        requestRender();
        renderMarkerCatUI();
        renderMarkerCatEditor();
      };

      const ren = document.createElement("button");
      ren.type = "button";
      ren.className = "tiny ghost";
      ren.textContent = "이름";
      ren.onclick = () => {
        const editor = document.createElement("div");
        editor.className = "inlineEditor show";
        editor.innerHTML = `
          <div class="col">
            <div class="field"><div class="label">카테고리 이름</div><input value="${escapeHtml(mc.name||"")}" /></div>
            <div class="row">
              <button class="tiny ok" type="button" data-act="save">저장</button>
              <button class="tiny ghost" type="button" data-act="cancel">취소</button>
            </div>
          </div>
        `;
        wrap.appendChild(editor);
        const inp = editor.querySelector("input");
        editor.querySelector('[data-act="save"]').onclick = () => {
          mc.name = inp.value.trim() || mc.name;
          saveLocalState();
          renderMarkerCatUI();
          renderMarkerCatEditor();
        };
        editor.querySelector('[data-act="cancel"]').onclick = () => editor.remove();
      };

      const del = document.createElement("button");
      del.type = "button";
      del.className = "tiny danger";
      del.textContent = "삭제";
      del.onclick = () => {
        if(state.markerCats.length <= 1) return;
        state.markerCats = state.markerCats.filter(x => x.id !== mc.id);
        state.markers = state.markers.filter(m => m.markerCatId !== mc.id);
        state.curves = state.curves.filter(cu => {
          const a = state.markers.find(m => m.id === cu.aId);
          const b = state.markers.find(m => m.id === cu.bId);
          return !!(a && b);
        });
        ensureActiveIds();
        selectedMarkerId = null;
        updateSelectedMarkerName();
        saveLocalState();
        renderAllUI();
        requestRender();
      };

      btns.appendChild(pick);
      btns.appendChild(vis);
      btns.appendChild(ren);
      btns.appendChild(del);

      head.appendChild(left);
      head.appendChild(btns);
      wrap.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "row";
      meta.style.marginTop = "10px";
      meta.style.justifyContent = "space-between";
      meta.innerHTML = `
        <span class="pill"><span class="muted">숫자:</span><span style="color:var(--text);font-weight:800">${mc.hideNumbers ? "숨김" : "표시"}</span></span>
        <span class="pill"><span class="muted">색상:</span><span style="color:var(--text);font-weight:800">${mc.color || ""}</span></span>
      `;
      wrap.appendChild(meta);

      ui.markerCatList.appendChild(wrap);
    });
  };

  const renderMarkerCatEditor = () => {
    ui.catEditList.innerHTML = "";
    ui.modalMarkerCats.dataset.activeCatId = state.active.markerCatId || "";
    state.markerCats.forEach(mc => {
      const item = document.createElement("div");
      item.className = "item";
      const head = document.createElement("div");
      head.className = "itemHead";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.style.gap = "10px";
      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = mc.color || "#ffd60a";
      const name = document.createElement("div");
      name.className = "itemName";
      name.textContent = mc.name || "카테고리";
      left.appendChild(dot);
      left.appendChild(name);

      const btns = document.createElement("div");
      btns.className = "itemBtns";

      const act = document.createElement("button");
      act.type = "button";
      act.className = "tiny" + (mc.id === state.active.markerCatId ? " ok" : " ghost");
      act.textContent = (mc.id === state.active.markerCatId ? "선택됨" : "선택");
      act.onclick = () => {
        state.active.markerCatId = mc.id;
        ui.modalMarkerCats.dataset.activeCatId = mc.id;
        saveLocalState();
        renderMarkerCatEditor();
        renderMarkerCatUI();
      };

      const colorInput = document.createElement("input");
      colorInput.value = mc.color || "#ffd60a";
      colorInput.style.height = "34px";
      colorInput.style.borderRadius = "12px";
      colorInput.style.padding = "0 10px";
      colorInput.style.width = "140px";
      colorInput.onfocus = () => ui.modalMarkerCats.dataset.activeCatId = mc.id;
      colorInput.oninput = () => {
        const v = colorInput.value.trim();
        applyMarkerCatColor(mc.id, v);
        saveLocalState();
        renderMarkerCatUI();
        requestRender();
        dot.style.background = v;
      };

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "tiny ghost";
      toggle.textContent = mc.visible ? "ON" : "OFF";
      toggle.onclick = () => {
        mc.visible = !mc.visible;
        saveLocalState();
        renderMarkerCatUI();
        renderMarkerCatEditor();
        requestRender();
      };

      const hideNums = document.createElement("button");
      hideNums.type = "button";
      hideNums.className = "tiny ghost";
      hideNums.textContent = mc.hideNumbers ? "숫자숨김" : "숫자표시";
      hideNums.onclick = () => {
        mc.hideNumbers = !mc.hideNumbers;
        saveLocalState();
        renderMarkerCatUI();
        renderMarkerCatEditor();
        requestRender();
      };

      btns.appendChild(act);
      btns.appendChild(toggle);
      btns.appendChild(hideNums);

      head.appendChild(left);
      head.appendChild(btns);

      const body = document.createElement("div");
      body.className = "col";
      body.style.marginTop = "10px";
      body.innerHTML = `
        <div class="field">
          <div class="label">카테고리 이름</div>
          <input data-k="name" value="${escapeHtml(mc.name||"")}" />
        </div>
        <div class="field">
          <div class="label">색상</div>
        </div>
      `;
      const nameInp = body.querySelector('input[data-k="name"]');
      nameInp.oninput = () => {
        mc.name = nameInp.value.trim() || mc.name;
        saveLocalState();
        renderMarkerCatUI();
      };

      const colorRow = document.createElement("div");
      colorRow.className = "row";
      colorRow.appendChild(colorInput);
      const applyBase = document.createElement("button");
      applyBase.type = "button";
      applyBase.className = "tiny ghost";
      applyBase.textContent = "1번 기준 적용";
      applyBase.onclick = () => {
        recalcMarkerCatBaseIfNeeded(mc.id);
        saveLocalState();
        renderMarkerCatUI();
        requestRender();
      };
      colorRow.appendChild(applyBase);
      body.appendChild(colorRow);

      item.appendChild(head);
      item.appendChild(body);
      ui.catEditList.appendChild(item);
    });
  };

  const renderLogo = () => {
    const url = state.logoUrl || "";
    if(url){
      ui.logoImg.src = url;
      ui.logoImg.style.display = "block";
      ui.logoFallback.style.display = "none";
      ui.logoImg.onload = () => {
        requestRender();
      };
      ui.logoImg.onerror = () => {
        ui.logoImg.style.display = "none";
        ui.logoFallback.style.display = "block";
      };
    } else {
      ui.logoImg.style.display = "none";
      ui.logoFallback.style.display = "block";
    }
  };

  const renderAllUI = () => {
    ensureActiveIds();
    setSwitch(ui.swGoogle, !!state.flags.googleEnabled);
    setSwitch(ui.swPay, !!state.flags.payEnabled);
    renderLogo();
    renderContentTabs();
    renderPages();
    renderMarkerCatUI();
    renderMarkerCatEditor();
    updateSelectedMarkerName();
  };

  const escapeHtml = (s) => String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));

  const bindUI = () => {
    ui.btnAddPage.onclick = () => {
      ui.pageAddEditor.classList.toggle("show");
      if(ui.pageAddEditor.classList.contains("show")) ui.pageNewName.focus();
    };
    ui.pageAddCancel.onclick = () => {
      ui.pageAddEditor.classList.remove("show");
      ui.pageNewName.value = "";
      ui.pageNewUrl.value = "";
    };
    ui.pageAddConfirm.onclick = () => {
      const cat = getActiveContentCat();
      if(!cat) return;
      const name = ui.pageNewName.value.trim();
      const url = ui.pageNewUrl.value.trim();
      if(!name || !url) return;
      const p = { id: uid(), name, url };
      cat.pages = cat.pages || [];
      cat.pages.push(p);
      state.active.pageId = p.id;
      ui.pageAddEditor.classList.remove("show");
      ui.pageNewName.value = "";
      ui.pageNewUrl.value = "";
      selectedMarkerId = null;
      updateSelectedMarkerName();
      resetSequence();
      saveLocalState();
      renderAllUI();
      loadMapImage(p.url);
      requestRender();
    };

    ui.btnAddMarkerCat.onclick = () => {
      ui.markerCatAddEditor.classList.toggle("show");
      if(ui.markerCatAddEditor.classList.contains("show")) ui.markerCatNewName.focus();
    };
    ui.markerCatAddCancel.onclick = () => {
      ui.markerCatAddEditor.classList.remove("show");
      ui.markerCatNewName.value = "";
    };
    ui.markerCatAddConfirm.onclick = () => {
      const name = ui.markerCatNewName.value.trim();
      if(!name) return;
      const mc = {
        id: uid(),
        name,
        color: "#ffd60a",
        visible: true,
        hideNumbers: false,
        base: { size: 26, text: 14, weight: 800, textColor: "#e7eef8", ratio: 14/26 }
      };
      state.markerCats.push(mc);
      state.active.markerCatId = mc.id;
      ui.markerCatAddEditor.classList.remove("show");
      ui.markerCatNewName.value = "";
      saveLocalState();
      renderMarkerCatUI();
      renderMarkerCatEditor();
      requestRender();
    };

    ui.btnToggleAllMarkerCats.onclick = () => {
      state._allMarkerCats = !state._allMarkerCats;
      saveLocalState();
      renderMarkerCatUI();
      renderMarkerCatEditor();
      requestRender();
    };

    ui.btnEditMarkerCats.onclick = () => {
      ui.modalMarkerCats.dataset.activeCatId = state.active.markerCatId || "";
      openModal(ui.modalMarkerCats);
    };
    ui.catEditClose.onclick = () => closeModal(ui.modalMarkerCats);

    ui.btnLinesHide.onclick = () => {
      state.linesVisible = false;
      saveLocalState();
      requestRender();
    };
    ui.btnLinesShow.onclick = () => {
      state.linesVisible = true;
      saveLocalState();
      requestRender();
    };

    ui.btnMarkersClear.onclick = () => {
      if(confirm("초기화를 하시겠습니까?")){
        clearAllMarkersInActivePage();
      }
    };

    ui.btnHideNumsInCat.onclick = () => {
      const mc = getActiveMarkerCat();
      if(!mc) return;
      mc.hideNumbers = !mc.hideNumbers;
      saveLocalState();
      renderMarkerCatUI();
      renderMarkerCatEditor();
      requestRender();
    };

    ui.btnEditMarker.onclick = () => {
      const m = getSelectedMarker();
      if(!m) return;
      openMarkerEdit(m);
    };

    ui.ytApplyToMarker.onclick = () => {
      const m = getSelectedMarker();
      if(!m) return;
      m.ytName = ui.ytTitle.value.trim();
      m.ytUrl = ui.ytUrl.value.trim();
      saveLocalState();
      requestRender();
    };

    ui.btnExport.onclick = () => {
      saveLocalState();
      downloadText("state.json", JSON.stringify(state, null, 2));
    };

    ui.btnResetAll.onclick = () => {
      if(confirm("전체 초기화를 하시겠습니까?")){
        state = defaultState();
        resetSequence();
        selectedMarkerId = null;
        updateSelectedMarkerName();
        saveLocalState();
        ensureActiveIds();
        renderAllUI();
        loadMapImage("");
        requestRender();
      }
    };

    ui.btnLogin.onclick = () => {
      openModal(ui.modalLogin);
      ui.loginPw.value = "";
      ui.loginPw.focus();
    };
    ui.loginCancel.onclick = () => closeModal(ui.modalLogin);
    ui.loginOk.onclick = () => {
      if(ui.loginPw.value === PASSWORD){
        authSave();
        authed = true;
        closeModal(ui.modalLogin);
        ui.btnLogin.textContent = "인증됨";
      } else {
        ui.loginPw.value = "";
        ui.loginPw.focus();
      }
    };
    ui.loginPw.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        ui.loginOk.click();
      }
    });

    ui.logoBtn.onclick = () => {
      ui.logoUrlInput.value = state.logoUrl || "";
      openModal(ui.modalLogo);
      ui.logoUrlInput.focus();
    };
    ui.logoClose.onclick = () => closeModal(ui.modalLogo);
    ui.logoSave.onclick = () => {
      state.logoUrl = ui.logoUrlInput.value.trim();
      saveLocalState();
      renderLogo();
      closeModal(ui.modalLogo);
    };

    ui.swGoogle.onclick = () => {
      state.flags.googleEnabled = !state.flags.googleEnabled;
      setSwitch(ui.swGoogle, state.flags.googleEnabled);
      saveLocalState();
    };
    ui.swPay.onclick = () => {
      state.flags.payEnabled = !state.flags.payEnabled;
      setSwitch(ui.swPay, state.flags.payEnabled);
      saveLocalState();
    };

    ui.mkName.addEventListener("input", () => {
      const m = getSelectedMarker();
      if(!m) return;
      if(ui.mkYtName.value.trim() === (m.ytName || "").trim() || ui.mkYtName.value.trim() === (m.name||"").trim()){
        ui.mkYtName.value = ui.mkName.value;
      }
    });

    ui.mkSize.addEventListener("input", () => {
      const s = clamp(parseInt(ui.mkSize.value,10)||26, 1, 100);
      const t = clamp(parseInt(ui.mkText.value,10)||14, 6, 80);
      const ratio = t / (parseInt(ui.mkSize.dataset.lastSize||s,10) || s);
      const nt = clamp(Math.round(s * ratio), 6, 80);
      ui.mkText.value = nt;
      ui.mkSize.dataset.lastSize = String(s);
    });

    ui.mkText.addEventListener("input", () => {
      ui.mkText.dataset.lastText = ui.mkText.value;
    });

    const saveMarkerFromModal = () => {
      const m = getSelectedMarker();
      if(!m) return;
      const oldCat = m.markerCatId;
      const newName = ui.mkName.value.trim();
      const newCat = ui.mkCat.value;
      const newYtName = ui.mkYtName.value.trim();
      const newYtUrl = ui.mkYtUrl.value.trim();
      const newSize = clamp(parseInt(ui.mkSize.value,10)||26, 1, 100);
      const newText = clamp(parseInt(ui.mkText.value,10)||14, 6, 80);
      const newWeight = parseInt(ui.mkWeight.value,10)||800;
      const newTextColor = parseColor(ui.mkTextColor.value.trim(), "#e7eef8");

      m.name = newName || m.name;
      m.markerCatId = newCat;
      m.ytName = newYtName || m.ytName || m.name;
      m.ytUrl = newYtUrl || m.ytUrl || "";
      m.size = newSize;
      m.textSize = newText;
      m.weight = newWeight;
      m.textColor = newTextColor;

      const mc = getMarkerCat(newCat);
      if(mc){
        m.color = mc.color;
      }

      if(m.num === 1){
        const mcNow = getMarkerCat(m.markerCatId);
        if(mcNow){
          const ratio = m.textSize / m.size;
          mcNow.base = { size: m.size, text: m.textSize, weight: m.weight, textColor: m.textColor, ratio };
          mcNow.color = m.color || mcNow.color;
          state.markers.forEach(mm => {
            if(mm.markerCatId !== mcNow.id) return;
            mm.color = mcNow.color;
            mm.size = mcNow.base.size;
            mm.textSize = clamp(Math.round(mm.size * (mcNow.base.ratio || ratio)), 6, 80);
            mm.weight = mcNow.base.weight;
            mm.textColor = mcNow.base.textColor;
          });
        }
      } else {
        const mcNow = getMarkerCat(m.markerCatId);
        if(mcNow){
          m.color = mcNow.color;
        }
      }

      if(oldCat !== newCat){
        recalcMarkerCatBaseIfNeeded(oldCat);
        recalcMarkerCatBaseIfNeeded(newCat);
      }

      saveLocalState();
      renderMarkerCatUI();
      renderMarkerCatEditor();
      requestRender();
      updateSelectedMarkerName();
    };

    ui.mkSave.onclick = () => { saveMarkerFromModal(); closeMarkerEdit(); };
    ui.mkClose.onclick = () => closeMarkerEdit();
    ui.mkDelete.onclick = () => {
      const m = getSelectedMarker();
      if(!m) return;
      state.markers = state.markers.filter(x => x.id !== m.id);
      removeCurvesWithMarker(m.id);
      selectedMarkerId = null;
      updateSelectedMarkerName();
      saveLocalState();
      closeMarkerEdit();
      requestRender();
    };
    ui.mkStartNew.onclick = () => { resetSequence(); };
    ui.mkStartFromHere.onclick = () => {
      const m = getSelectedMarker();
      if(m) setSequenceFromMarker(m);
    };

    ui.modalMarkerEdit.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        saveMarkerFromModal();
        closeMarkerEdit();
      }
      if(e.key === "Escape"){
        e.preventDefault();
        closeMarkerEdit();
      }
    });

    ui.modalLogo.addEventListener("keydown", (e) => {
      if(e.key === "Escape"){ e.preventDefault(); closeModal(ui.modalLogo); }
      if(e.key === "Enter"){ e.preventDefault(); ui.logoSave.click(); }
    });

    ui.modalLogin.addEventListener("keydown", (e) => {
      if(e.key === "Escape"){ e.preventDefault(); closeModal(ui.modalLogin); }
    });

    window.addEventListener("resize", resize, { passive:true });
  };

  const preventContext = (e) => e.preventDefault();

  cv.addEventListener("contextmenu", preventContext);

  cv.addEventListener("wheel", (e) => {
    e.preventDefault();
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    wheelZoom(sx, sy, e.deltaY);
  }, { passive:false });

  const pointerDown = (sx, sy, button) => {
    const rect = cv.getBoundingClientRect();
    const wx = screenToWorld(sx, sy).x;
    const wy = screenToWorld(sx, sy).y;

    pointer.down = true;
    pointer.sx = sx;
    pointer.sy = sy;
    pointer.wx = wx;
    pointer.wy = wy;
    pointer.vx0 = state.view.x;
    pointer.vy0 = state.view.y;
    pointer.z0 = state.view.z;
    pointer.moved = false;
    pointer.mode = "";

    const m = hitMarker(sx, sy);
    if(m && button === 0){
      selectedMarkerId = m.id;
      updateSelectedMarkerName();
      pointer.mode = "dragMarker";
      pointer.activeId = m.id;
      saveLocalState();
      requestRender();
      return;
    }

    const hitC = hitCurve(sx, sy);
    if(hitC && button === 0){
      pointer.mode = "dragCurve";
      pointer.curveKey = hitC.c.key;
      ui.selMarkerName.textContent = "없음";
      selectedMarkerId = null;
      requestRender();
      return;
    }

    if(button === 0){
      pointer.mode = "pan";
      return;
    }

    if(button === 2){
      addMarkerAt(wx, wy);
      requestRender();
      pointer.down = false;
      return;
    }
  };

  const pointerMove = (sx, sy) => {
    if(!pointer.down) return;
    const dx = sx - pointer.sx;
    const dy = sy - pointer.sy;
    if(Math.abs(dx) + Math.abs(dy) > 2) pointer.moved = true;

    if(pointer.mode === "pan"){
      const z = state.view.z;
      state.view.x = pointer.vx0 - dx / z;
      state.view.y = pointer.vy0 - dy / z;
      saveLocalState();
      requestRender();
      return;
    }

    if(pointer.mode === "dragMarker"){
      const m = markersInActivePage().find(x => x.id === pointer.activeId);
      if(!m) return;
      const w = screenToWorld(sx, sy);
      m.x = w.x;
      m.y = w.y;
      const conns = buildConnections();
      for(const {a,b} of conns){
        ensureCurveBetween(a.id, b.id);
      }
      saveLocalState();
      requestRender();
      return;
    }

    if(pointer.mode === "dragCurve"){
      const c = state.curves.find(x => x.key === pointer.curveKey);
      if(!c) return;
      const w = screenToWorld(sx, sy);
      c.cx = w.x;
      c.cy = w.y;
      saveLocalState();
      requestRender();
      return;
    }
  };

  const pointerUp = (sx, sy, button) => {
    if(!pointer.down) return;
    const moved = pointer.moved;
    pointer.down = false;

    const m = hitMarker(sx, sy);

    if(button === 0 && !moved && m){
      toggleMarkerSelected(m);
      selectedMarkerId = m.id;
      updateSelectedMarkerName();
      requestRender();
      return;
    }

    requestRender();
  };

  cv.addEventListener("mousedown", (e) => {
    if(!authed) return;
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    pointerDown(sx, sy, e.button);
  });

  cv.addEventListener("mousemove", (e) => {
    if(!authed) return;
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    pointerMove(sx, sy);
  });

  cv.addEventListener("mouseup", (e) => {
    if(!authed) return;
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    pointerUp(sx, sy, e.button);
  });

  cv.addEventListener("dblclick", (e) => {
    if(!authed) return;
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const m = hitMarker(sx, sy);
    if(m){
      openMarkerEdit(m);
    }
  });

  let touch = {
    active:false,
    id1:null, id2:null,
    x1:0,y1:0,x2:0,y2:0,
    vx0:0, vy0:0, z0:1,
    wmid0:null,
    dist0:0,
    mode:""
  };

  const getTouchById = (ts, id) => {
    for(let i=0;i<ts.length;i++) if(ts[i].identifier === id) return ts[i];
    return null;
  };

  cv.addEventListener("touchstart", (e) => {
    if(!authed) return;
    e.preventDefault();
    const rect = cv.getBoundingClientRect();
    if(e.touches.length === 1){
      const t = e.touches[0];
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      touch.active = true;
      touch.mode = "pan";
      touch.id1 = t.identifier;
      touch.vx0 = state.view.x;
      touch.vy0 = state.view.y;
      touch.z0 = state.view.z;
      touch.x1 = sx; touch.y1 = sy;
      return;
    }
    if(e.touches.length >= 2){
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const x1 = t1.clientX - rect.left, y1 = t1.clientY - rect.top;
      const x2 = t2.clientX - rect.left, y2 = t2.clientY - rect.top;
      touch.active = true;
      touch.mode = "pinch";
      touch.id1 = t1.identifier;
      touch.id2 = t2.identifier;
      touch.x1 = x1; touch.y1 = y1; touch.x2 = x2; touch.y2 = y2;
      touch.vx0 = state.view.x;
      touch.vy0 = state.view.y;
      touch.z0 = state.view.z;
      const mx = (x1+x2)/2, my = (y1+y2)/2;
      touch.wmid0 = screenToWorld(mx, my);
      const dx = x2-x1, dy=y2-y1;
      touch.dist0 = Math.sqrt(dx*dx+dy*dy);
      return;
    }
  }, { passive:false });

  cv.addEventListener("touchmove", (e) => {
    if(!authed) return;
    e.preventDefault();
    if(!touch.active) return;
    const rect = cv.getBoundingClientRect();

    if(touch.mode === "pan" && e.touches.length === 1){
      const t = getTouchById(e.touches, touch.id1) || e.touches[0];
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const dx = sx - touch.x1;
      const dy = sy - touch.y1;
      const z = touch.z0;
      state.view.x = touch.vx0 - dx / z;
      state.view.y = touch.vy0 - dy / z;
      saveLocalState();
      requestRender();
      return;
    }

    if(touch.mode === "pinch" && e.touches.length >= 2){
      const t1 = getTouchById(e.touches, touch.id1) || e.touches[0];
      const t2 = getTouchById(e.touches, touch.id2) || e.touches[1];
      const x1 = t1.clientX - rect.left, y1 = t1.clientY - rect.top;
      const x2 = t2.clientX - rect.left, y2 = t2.clientY - rect.top;
      const dx = x2-x1, dy = y2-y1;
      const dist = Math.sqrt(dx*dx+dy*dy) || 1;
      const scale = dist / (touch.dist0 || dist);
      const z1 = clamp(touch.z0 * scale, 0.2, 6);
      state.view.z = z1;
      const mx = (x1+x2)/2, my = (y1+y2)/2;
      const w1 = screenToWorld(mx, my);
      state.view.x += (touch.wmid0.x - w1.x);
      state.view.y += (touch.wmid0.y - w1.y);
      saveLocalState();
      requestRender();
      return;
    }
  }, { passive:false });

  cv.addEventListener("touchend", (e) => {
    if(!authed) return;
    e.preventDefault();
    if(e.touches.length === 0){
      touch.active = false;
      touch.mode = "";
      touch.id1 = null;
      touch.id2 = null;
      return;
    }
    if(e.touches.length === 1){
      const rect = cv.getBoundingClientRect();
      const t = e.touches[0];
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      touch.mode = "pan";
      touch.id1 = t.identifier;
      touch.id2 = null;
      touch.x1 = sx; touch.y1 = sy;
      touch.vx0 = state.view.x;
      touch.vy0 = state.view.y;
      touch.z0 = state.view.z;
    }
  }, { passive:false });

  const init = async () => {
    setupQuickButtons();

    const local = loadLocalState();
    const remote = await fetchRemoteState();
    state = mergeState(local || defaultState(), remote || {});
    ensureActiveIds();
    resetSequence();
    authed = authLoad();
    ui.btnLogin.textContent = authed ? "인증됨" : "관리자 로그인";
    if(!authed) openModal(ui.modalLogin);

    bindUI();
    renderAllUI();
    const p = getActivePage();
    loadMapImage(p ? p.url : "");
    resize();
    requestRender();
  };

  init();
})();
</script>
</body>
</html>
