<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE · ADMIN99</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;

      --stroke:#1f2a3a;
      --stroke2:#27344a;

      --text:#e7eef8;
      --muted:#9fb0c6;

      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r12:12px;
      --r14:14px;
      --r16:16px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", sans-serif;
      background: radial-gradient(1200px 700px at 20% 0%, #0a1630 0%, var(--bg) 55%, #05070c 100%);
      color:var(--text);
      overflow:hidden;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 360px 1fr 360px;
      gap:16px;
      padding:16px;
      padding-bottom: calc(16px + env(safe-area-inset-bottom));
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: var(--r16);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(var(--blur));
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px 14px;
      border-bottom:1px solid var(--stroke);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .brand img{
      width:34px; height:34px; border-radius:10px;
      object-fit:contain;
      background:rgba(255,255,255,.06);
      border:1px solid var(--stroke2);
    }
    .brandTitle{
      display:flex; flex-direction:column; line-height:1.1;
    }
    .brandTitle b{ font-size:14px; letter-spacing:.2px; }
    .brandTitle span{ font-size:12px; color:var(--muted); }

    .pillRow{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      appearance:none;
      border:1px solid var(--stroke2);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      cursor:pointer;
      user-select:none;
      transition:.15s transform, .15s border-color, .15s background;
      display:inline-flex; align-items:center; gap:8px;
      white-space:nowrap;
    }
    .pill:hover{ transform: translateY(-1px); border-color:#33507a; background: rgba(124,196,255,.10); }
    .pill.primary{ border-color:#2e5f94; background: rgba(124,196,255,.12); }
    .pill.ok{ border-color:#1e6c4a; background: rgba(57,217,138,.10); }
    .pill.danger{ border-color:#7a2a2a; background: rgba(255,93,93,.10); }
    .pill.warn{ border-color:#6b5b10; background: rgba(255,214,10,.10); }
    .pill:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .scroll{
      padding:14px;
      overflow:auto;
      min-height:0;
    }
    .section{
      background: rgba(255,255,255,.04);
      border:1px solid var(--stroke);
      border-radius: var(--r14);
      padding:12px;
      margin-bottom:12px;
    }
    .section h3{
      margin:0 0 10px 0;
      font-size:13px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .muted{ color:var(--muted); font-size:12px; }
    .row{ display:flex; align-items:center; gap:10px; }
    .rowBetween{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }

    .field{
      width:100%;
      background: rgba(0,0,0,.22);
      border:1px solid var(--stroke2);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      font-size:13px;
      outline:none;
    }
    .field:focus{ border-color:#3b78c0; box-shadow:0 0 0 3px rgba(124,196,255,.12); }
    textarea.field{ resize:vertical; min-height:96px; }

    .select{
      width:100%;
      background: rgba(0,0,0,.22);
      border:1px solid var(--stroke2);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      font-size:13px;
      outline:none;
    }

    .kpi{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background: rgba(0,0,0,.22);
      font-size:12px;
      color:var(--muted);
    }

    .canvasWrap{
      position:relative;
      flex:1;
      min-height:0;
      padding:16px;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius: var(--r16);
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      touch-action: none; /* ✅ 모바일에서 페이지 밀림 방지 */
    }

    .topOverlay{
      position:absolute;
      left:28px;
      right:28px;
      top:28px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
    }
    .chipBar{
      pointer-events:auto;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .chip{
      border:1px solid var(--stroke2);
      background: rgba(10,16,28,.62);
      color:var(--text);
      border-radius:999px;
      padding:8px 10px;
      font-size:12px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(10px);
    }
    .chip.on{ border-color:#2e5f94; background: rgba(124,196,255,.12); }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:24px;
      transform:translateX(-50%);
      background: rgba(10,16,28,.92);
      border:1px solid var(--stroke2);
      color:var(--text);
      padding:10px 14px;
      border-radius: 12px;
      font-size:13px;
      box-shadow: var(--shadow2);
      opacity:0;
      pointer-events:none;
      transition:.2s opacity, .2s transform;
      z-index:50;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-4px);
    }

    /* ---- modals ---- */
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:60;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(720px, 100%);
      max-height:min(820px, calc(100vh - 32px));
      overflow:hidden;
      background: rgba(10,16,28,.92);
      border:1px solid var(--stroke2);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:14px 14px;
      border-bottom:1px solid var(--stroke);
    }
    .modalHead b{ font-size:14px; }
    .modalBody{
      padding:14px;
      overflow:auto;
      min-height:0;
    }
    .hr{ height:1px; background: var(--stroke); margin:12px 0; }

    .colorChip{
      width:42px; height:38px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
      position:relative;
    }
    .colorChip::after{
      content:"";
      position:absolute; inset:6px;
      border-radius:10px;
      background: var(--c, #7cc4ff);
      box-shadow: 0 0 0 3px rgba(0,0,0,.25) inset;
    }

    .swGrid{ display:flex; flex-wrap:wrap; gap:10px; }
    .swWrap{ display:flex; flex-direction:column; align-items:center; gap:6px; cursor:pointer; }
    .sw{
      width:34px; height:34px; border-radius:12px;
      border:1px solid var(--stroke2);
      background: var(--c, #fff);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .swLabel{ font-size:11px; color:var(--muted); }

    @media (max-width: 1100px){
      .app{ grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; }
      .panel.left{ order:1; }
      .panel.center{ order:2; }
      .panel.right{ order:3; }
      .panel{ min-height: 240px; }
      .panel.center{ min-height: 520px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- LEFT -->
    <section class="panel left">
      <div class="panelHeader">
        <div class="brand" id="brand">
          <img id="logoImg" alt="logo" />
          <div class="brandTitle">
            <b>MAPMODE · ADMIN99</b>
            <span id="authBadge">인증 필요</span>
          </div>
        </div>
        <div class="pillRow">
          <button class="pill primary" id="btnAuth">관리자 인증</button>
          <button class="pill" id="btnExport">내보내기</button>
        </div>
      </div>

      <div class="scroll">
        <div class="section">
          <h3>게임</h3>
          <div class="rowBetween" style="margin-bottom:10px;">
            <select class="select" id="selGame"></select>
            <button class="pill" id="btnGameMgr">관리</button>
          </div>
          <div class="muted">게임별 페이지/마커를 따로 관리합니다.</div>
        </div>

        <div class="section">
          <h3>페이지</h3>
          <div class="rowBetween" style="margin-bottom:10px;">
            <select class="select" id="selPage"></select>
            <button class="pill" id="btnAddPage">추가</button>
          </div>
          <div class="grid2" style="margin-bottom:10px;">
            <button class="pill" id="btnEditPage">편집</button>
            <button class="pill danger" id="btnDelPage">삭제</button>
          </div>
          <div class="kpi" id="kpi">표시 중 마커: 0 / 페이지 전체: 0</div>
        </div>

        <div class="section">
          <h3>지도</h3>
          <div class="grid2" style="margin-bottom:10px;">
            <button class="pill" id="btnFit">화면 맞춤</button>
            <button class="pill" id="btnLoadFromUrl">페이지 URL 적용</button>
          </div>
          <div class="row" style="margin-bottom:10px;">
            <input class="field" id="mapUrl" placeholder="지도 이미지 URL (예: /assets/aion2/maps/map1.png 또는 https://...)" />
          </div>
          <div class="rowBetween" style="margin-bottom:10px;">
            <label class="pill" style="cursor:pointer;">
              지도 업로드
              <input id="fileMap" type="file" accept="image/*" style="display:none;" />
            </label>
            <button class="pill danger" id="btnClearMap">지도 제거</button>
          </div>
          <div class="muted">업로드는 state.json에 DataURL로 저장됩니다(간편). 큰 지도는 URL 방식 권장.</div>
        </div>

        <div class="section">
          <h3>카테고리</h3>
          <div class="rowBetween">
            <button class="pill" id="btnEditCats">편집</button>
            <button class="pill" id="btnRechain">선 표시</button>
            <button class="pill" id="btnClearLines">선 숨김</button>
          </div>
          <div class="muted" style="margin-top:8px;">“전체” ON이어도 개별 OFF는 우선.</div>
        </div>

        <div class="section">
          <h3>전체</h3>
          <div class="grid2">
            <button class="pill danger" id="btnResetMarkers">마커 초기화</button>
            <button class="pill danger" id="btnResetAll">전체 초기화</button>
          </div>
        </div>
      </div>
    </section>

    <!-- CENTER -->
    <section class="panel center">
      <div class="panelHeader">
        <div class="row" style="gap:10px;">
          <span class="muted">우클릭:</span><span style="font-size:12px;">마커 추가</span>
          <span class="muted">·</span>
          <span class="muted">더블클릭:</span><span style="font-size:12px;">마커 편집</span>
        </div>
        <div class="pillRow">
          <button class="pill" id="btnNewChain">새 번호로 시작</button>
        </div>
      </div>

      <div class="canvasWrap">
        <div class="topOverlay">
          <div class="chipBar" id="catChips"></div>
          <div class="chipBar">
            <div class="chip" id="tgShowChainSameCat"><span class="dot"></span>선 표시</div>
          </div>
        </div>
        <canvas id="cv"></canvas>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="panel right">
      <div class="panelHeader">
        <div class="row" style="gap:10px;">
          <b style="font-size:14px;">선택 마커</b>
          <span class="muted" id="selName">(이름 없음)</span>
        </div>
        <div class="pillRow">
          <button class="pill" id="btnOpenMarkerEdit" disabled>편집</button>
        </div>
      </div>

      <div class="scroll">
        <div class="section">
          <h3>유튜브 링크</h3>
          <input class="field" id="selYtTitle" placeholder="제목" />
          <div style="height:8px"></div>
          <input class="field" id="selLink" placeholder="https://youtube.com/..." />
          <div class="muted" style="margin-top:8px;">(유저 페이지에서 표시/동작)</div>
        </div>

        <div class="section">
          <h3>빠른 색상</h3>
          <div class="swGrid" id="palette"></div>
          <div style="height:10px"></div>
          <div class="rowBetween">
            <button class="pill" id="btnApplyQuick" disabled>선택 색 적용</button>
            <button class="pill" id="btnUseCatColor" disabled>카테고리 색</button>
          </div>
        </div>

        <div class="section">
          <h3>상태</h3>
          <div class="muted">- 상태 파일: <b>/aion2/data/state.json</b> (GitHub Pages)</div>
          <div class="muted" style="margin-top:6px;">- REMOTE_STATE_URL: new URL("./data/state.json", location.href)</div>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <!-- MARKER MODAL -->
  <div class="modal" id="mMarker">
    <div class="modalCard">
      <div class="modalHead">
        <b>마커 편집</b>
        <div class="pillRow">
          <button class="pill" id="btnInsertAfter">중간 삽입</button>
          <button class="pill danger" id="btnDeleteMarker">삭제</button>
          <button class="pill" id="btnCloseMarker">닫기</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="grid2">
          <div>
            <div class="muted">이름</div>
            <input class="field" id="mfName" />
          </div>
          <div>
            <div class="muted">카테고리</div>
            <select class="select" id="mfCat"></select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div>
            <div class="muted">색상</div>
            <div class="row" style="gap:10px;">
              <input class="field" id="mfColor" placeholder="#rrggbb 또는 비움" />
              <div class="colorChip" id="mfColorChip"></div>
            </div>
            <div style="height:8px"></div>
            <label class="row" style="gap:8px; font-size:13px;">
              <input type="checkbox" id="mfUseCatColor" />
              카테고리 색 사용
            </label>
          </div>
          <div>
            <div class="muted">텍스트 색</div>
            <input class="field" id="mfLabelColor" placeholder="#e7eef8" />
            <div style="height:8px"></div>
            <button class="pill" id="mfLabelDefault" type="button">기본값</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid3">
          <div>
            <div class="muted">원 크기(r)</div>
            <input type="range" min="2" max="80" step="1" id="mfR" style="width:100%;" />
            <div class="muted">값: <span id="mfRVal">10</span></div>
          </div>
          <div>
            <div class="muted">텍스트 크기(fs)</div>
            <input type="range" min="4" max="80" step="1" id="mfFs" style="width:100%;" />
            <div class="muted">값: <span id="mfFsVal">15</span></div>
          </div>
          <div>
            <div class="muted">굵기(fw)</div>
            <select class="select" id="mfFw">
              <option value="700">700</option>
              <option value="800">800</option>
              <option value="900" selected>900</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid2">
          <div>
            <div class="muted">유튜브 링크</div>
            <input class="field" id="mfYt" placeholder="https://youtube.com/..." />
            <div style="height:8px"></div>
            <input class="field" id="mfYtTitle" placeholder="제목" />
          </div>
          <div>
            <div class="muted">메모(관리자만 작성)</div>
            <textarea class="field" id="mfMemo" placeholder="메모"></textarea>
          </div>
        </div>

        <div class="hr"></div>

        <div class="rowBetween">
          <div class="muted" id="mfPos">좌표(비율): -</div>
          <button class="pill ok" id="btnSaveMarker">저장</button>
        </div>
      </div>
    </div>
  </div>

  <!-- CATEGORY MODAL -->
  <div class="modal" id="mCats">
    <div class="modalCard">
      <div class="modalHead">
        <b>카테고리 편집</b>
        <div class="pillRow">
          <button class="pill" id="btnCatsDefault">기본값</button>
          <button class="pill ok" id="btnSaveCats">저장</button>
          <button class="pill" id="btnCloseCats">닫기</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="rowBetween" style="margin-bottom:10px;">
          <div class="muted">카테고리(“전체” 제외)</div>
          <button class="pill" id="btnAddCat">추가</button>
        </div>

        <div class="rowBetween" style="margin-bottom:12px;">
          <div class="muted">선 표시(카테고리 필터 반영)</div>
          <div class="chip" id="tgShowLinesWithCatFilter"><span class="dot"></span>ON</div>
        </div>

        <div class="section" style="margin-bottom:12px;">
          <h3>빠른 색상</h3>
          <div class="swGrid" id="catQuickPalette"></div>
          <div class="muted" style="margin-top:8px;">행을 선택한 뒤 색을 누르면 적용됩니다.</div>
        </div>

        <div id="catRows"></div>
      </div>
    </div>
  </div>

  <!-- SIMPLE POPUP (input/confirm) -->
  <div class="modal" id="mPop">
    <div class="modalCard" style="width:min(520px,100%);">
      <div class="modalHead">
        <b id="popTitle">제목</b>
        <button class="pill" id="popClose">닫기</button>
      </div>
      <div class="modalBody">
        <div class="muted" id="popMsg" style="white-space:pre-line; margin-bottom:10px;"></div>
        <input class="field" id="popInput" style="display:none;" />
        <div class="rowBetween" style="margin-top:12px;">
          <button class="pill" id="popCancel">취소</button>
          <button class="pill ok" id="popOk">확인</button>
        </div>
      </div>
    </div>
  </div>

<script>
(()=> {
  // =========================
  // MAPMODE · ADMIN99 (single HTML)
  // - LS_AUTH_KEY=mapmode_admin_auth_v99
  // - LS_KEY=mapmode_state_v99
  // - PASSWORD=0000000001
  // - AUTH 24h
  // - REMOTE_STATE_URL = new URL("./data/state.json", location.href)
  // =========================

  const LS_AUTH_KEY = "mapmode_admin_auth_v99";
  const LS_KEY      = "mapmode_state_v99";
  const PASSWORD    = "0000000001";
  const AUTH_MS     = 24*60*60*1000;
  const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

  const $ = (id)=>document.getElementById(id);
  const clamp = (v,min,max)=>Math.max(min, Math.min(max, v));
  const uid = ()=>Math.random().toString(16).slice(2) + Date.now().toString(16);

  // -------- toast --------
  let toastTimer=null;
  function toast(msg){
    const t=$("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>t.classList.remove("show"), 1300);
  }

  // -------- pop (input/confirm) --------
  let popResolve=null;
  function openPop({title,message,showInput,placeholder,value,okText,cancelText}){
    $("popTitle").textContent = title || "알림";
    $("popMsg").textContent = message || "";
    const inp = $("popInput");
    inp.style.display = showInput ? "block":"none";
    inp.placeholder = placeholder || "";
    inp.value = value || "";
    $("popOk").textContent = okText || "확인";
    $("popCancel").textContent = cancelText || "취소";
    $("mPop").classList.add("show");

    return new Promise((resolve)=>{
      popResolve = resolve;
      setTimeout(()=>{ if(showInput) inp.focus(); }, 0);
    });
  }
  function closePop(result){
    $("mPop").classList.remove("show");
    const inp = $("popInput");
    if(popResolve){
      const r = (result==="ok")
        ? (inp.style.display==="block" ? inp.value : true)
        : null;
      popResolve(r);
      popResolve=null;
    }
  }
  $("popClose").addEventListener("click", ()=>closePop("cancel"));
  $("popCancel").addEventListener("click", ()=>closePop("cancel"));
  $("popOk").addEventListener("click", ()=>closePop("ok"));
  $("mPop").addEventListener("keydown", (e)=>{
    if(e.key==="Escape") closePop("cancel");
    if(e.key==="Enter"){
      if($("popInput").style.display==="block"){
        e.preventDefault();
        closePop("ok");
      }
    }
  });

  async function openPopInput(opts){
    return await openPop({ ...opts, showInput:true });
  }
  async function openPopConfirm(opts){
    const r = await openPop({ ...opts, showInput:false });
    return r === true;
  }

  // -------- auth --------
  function isAuthed(){
    try{
      const raw = localStorage.getItem(LS_AUTH_KEY);
      if(!raw) return false;
      const v = JSON.parse(raw);
      return v && v.until && Date.now() < v.until;
    }catch{ return false; }
  }
  function setAuthed(){
    localStorage.setItem(LS_AUTH_KEY, JSON.stringify({ until: Date.now()+AUTH_MS }));
    renderAuth();
  }
  async function requireAuth(){
    if(isAuthed()) return true;
    const pw = await openPopInput({
      title:"관리자 인증",
      message:"비밀번호를 입력하세요.",
      placeholder:"비밀번호",
      value:"",
      okText:"인증",
      cancelText:"취소"
    });
    if(pw === null) return false;
    if((pw||"").trim() === PASSWORD){
      setAuthed();
      toast("인증 완료 (24시간 유지)");
      return true;
    }
    toast("비밀번호 오류");
    return false;
  }
  function renderAuth(){
    $("authBadge").textContent = isAuthed() ? "인증됨 (24시간)" : "인증 필요";
    $("btnAuth").classList.toggle("ok", isAuthed());
    $("btnAuth").textContent = isAuthed() ? "인증됨" : "관리자 인증";
  }

  $("btnAuth").addEventListener("click", async ()=>{
    await requireAuth();
    renderAuth();
  });

  // -------- default state --------
  const defaultCats = [
    { id:"전체", name:"전체", color:"#7cc4ff", on:true },
    { id:"기텔", name:"기텔", color:"#ffffff", on:true }
  ];
  const defaultState = {
    v: 99,
    game: "아이온2",
    games: ["아이온2"],
    logoUrl: "/assets/logo/MAPMODELOGO2.png",

    pagesByGame: {
      "아이온2": [
        { id:"p_"+uid(), name:"1번마을", mapUrl:"/assets/aion2/maps/map1.png" }
      ]
    },

    currentPageId: null,

    categories: structuredClone(defaultCats),

    // 지도: 현재 페이지의 mapUrl 또는 imgDataUrl 사용
    map: {
      pageMapUrl: "",
      imgDataUrl: "",
      naturalW: 0,
      naturalH: 0,
      scale: 0,
      tx: 0,
      ty: 0
    },

    markers: [],

    showLinesWithCatFilter: true
  };

  let S = structuredClone(defaultState);

  // -------- state helpers --------
  function saveLocal(){
    localStorage.setItem(LS_KEY, JSON.stringify(S));
  }

  function loadLocal(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch{ return null; }
  }

  function mergeState(st){
    const out = structuredClone(defaultState);
    if(!st || typeof st !== "object") return out;

    // shallow merge
    for(const k of Object.keys(out)){
      if(st[k] !== undefined) out[k] = st[k];
    }

    if(!Array.isArray(out.categories) || !out.categories.length){
      out.categories = structuredClone(defaultCats);
    }
    // ensure "전체"
    if(!out.categories.some(c=>c.id==="전체")){
      out.categories.unshift({ id:"전체", name:"전체", color:"#7cc4ff", on:true });
    }
    if(!Array.isArray(out.games) || !out.games.length){
      out.games = ["아이온2"];
    }
    if(!out.game || !out.games.includes(out.game)){
      out.game = out.games[0];
    }
    if(!out.pagesByGame || typeof out.pagesByGame !== "object"){
      out.pagesByGame = {};
    }
    if(!Array.isArray(out.pagesByGame[out.game]) || !out.pagesByGame[out.game].length){
      out.pagesByGame[out.game] = [{ id:"p_"+uid(), name:"1번마을", mapUrl:"" }];
    }

    // currentPageId
    const pages = out.pagesByGame[out.game];
    if(!out.currentPageId || !pages.some(p=>p.id===out.currentPageId)){
      out.currentPageId = pages[0].id;
    }

    // map pageMapUrl sync
    const cur = pages.find(p=>p.id===out.currentPageId);
    out.map = out.map || structuredClone(defaultState.map);
    out.map.pageMapUrl = cur?.mapUrl || out.map.pageMapUrl || "";

    // markers array
    if(!Array.isArray(out.markers)) out.markers = [];

    return out;
  }

  async function loadStateRemoteFirst(){
    // remote -> local fallback
    try{
      const res = await fetch(REMOTE_STATE_URL.href, { cache:"no-store" });
      if(res.ok){
        const j = await res.json();
        return j;
      }
    }catch{}
    return loadLocal() || structuredClone(defaultState);
  }

  // -------- UI render: logo --------
  function renderLogo(){
    const img = $("logoImg");
    img.src = S.logoUrl || "/assets/logo/MAPMODELOGO2.png";
    img.onerror = ()=>{ img.src=""; };
  }
  async function changeLogoUrl(){
    if(!(await requireAuth())) return;
    const next = await openPopInput({
      title:"로고 URL",
      message:"로고 이미지 URL을 입력하세요.",
      placeholder:"예: /assets/logo/MAPMODELOGO2.png",
      value: S.logoUrl || "",
      okText:"저장",
      cancelText:"취소"
    });
    if(next === null) return;
    S.logoUrl = (next||"").trim();
    saveLocal(); renderLogo();
    toast("로고 저장");
  }
  $("brand").addEventListener("click", changeLogoUrl);

  // -------- games/pages --------
  function getPages(){
    const list = S.pagesByGame[S.game];
    return Array.isArray(list) ? list : [];
  }
  function ensureCurrentPage(){
    const pages = getPages();
    if(!S.currentPageId || !pages.some(p=>p.id===S.currentPageId)){
      S.currentPageId = pages[0]?.id || null;
    }
    const cur = pages.find(p=>p.id===S.currentPageId);
    if(cur){
      S.map.pageMapUrl = cur.mapUrl || "";
      $("mapUrl").value = cur.mapUrl || "";
    }
  }
  function renderGamesTop(){
    const sel = $("selGame");
    sel.innerHTML = "";
    for(const g of S.games){
      const o = document.createElement("option");
      o.value = g;
      o.textContent = g;
      sel.appendChild(o);
    }
    sel.value = S.game;
  }
  function renderPages(){
    ensureCurrentPage();
    const sel = $("selPage");
    sel.innerHTML = "";
    for(const p of getPages()){
      const o = document.createElement("option");
      o.value = p.id;
      o.textContent = p.name;
      sel.appendChild(o);
    }
    sel.value = S.currentPageId;
  }

  $("selGame").addEventListener("change", ()=>{
    S.game = $("selGame").value;
    // default page for this game
    if(!S.pagesByGame[S.game]) S.pagesByGame[S.game]=[{ id:"p_"+uid(), name:"1번마을", mapUrl:"" }];
    S.currentPageId = S.pagesByGame[S.game][0]?.id || null;
    ensureCurrentPage();
    saveLocal();
    renderAll();
    loadMap();
  });

  $("selPage").addEventListener("change", ()=>{
    S.currentPageId = $("selPage").value;
    ensureCurrentPage();
    saveLocal();
    renderAll();
    loadMap();
  });

  $("btnAddPage").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const name = await openPopInput({
      title:"페이지 추가",
      message:"페이지 이름을 입력하세요.",
      placeholder:"예: 2번마을",
      value:"",
      okText:"추가",
      cancelText:"취소"
    });
    if(name === null) return;
    const nm = (name||"").trim();
    if(!nm) return;

    const url = await openPopInput({
      title:"페이지 지도 URL",
      message:"해당 페이지에 사용할 지도 이미지 URL을 입력하세요.\n(비워도 됨)",
      placeholder:"예: /assets/aion2/maps/map2.png",
      value:"",
      okText:"저장",
      cancelText:"건너뛰기"
    });

    const p = { id:"p_"+uid(), name:nm, mapUrl: (url===null ? "" : (url||"").trim()) };
    if(!S.pagesByGame[S.game]) S.pagesByGame[S.game]=[];
    S.pagesByGame[S.game].push(p);
    S.currentPageId = p.id;
    ensureCurrentPage();
    saveLocal();
    renderPages();
    loadMap();
    toast("페이지 추가");
  });

  $("btnEditPage").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    if(!cur) return;

    const nm = await openPopInput({
      title:"페이지 이름 편집",
      message:"페이지 이름을 수정하세요.",
      placeholder:"페이지 이름",
      value: cur.name || "",
      okText:"저장",
      cancelText:"취소"
    });
    if(nm === null) return;
    cur.name = (nm||"").trim() || cur.name;

    const url = await openPopInput({
      title:"페이지 지도 URL 편집",
      message:"지도 URL을 수정하세요.\n(비우면 URL 제거)",
      placeholder:"/assets/aion2/maps/...",
      value: cur.mapUrl || "",
      okText:"저장",
      cancelText:"취소"
    });
    if(url !== null){
      cur.mapUrl = (url||"").trim();
      if(cur.id === S.currentPageId){
        S.map.pageMapUrl = cur.mapUrl || "";
        $("mapUrl").value = cur.mapUrl || "";
        loadMap();
      }
    }
    saveLocal();
    renderPages();
    toast("페이지 저장");
  });

  $("btnDelPage").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const ok = await openPopConfirm({
      title:"페이지 삭제",
      message:"현재 페이지를 삭제할까요?\n(해당 페이지 마커도 함께 삭제됩니다)",
      okText:"삭제",
      cancelText:"취소"
    });
    if(!ok) return;

    const pid = S.currentPageId;
    S.pagesByGame[S.game] = getPages().filter(p=>p.id!==pid);
    if(!S.pagesByGame[S.game].length){
      S.pagesByGame[S.game] = [{ id:"p_"+uid(), name:"1번마을", mapUrl:"" }];
    }
    S.markers = (S.markers||[]).filter(m=>m.pageId!==pid);
    S.currentPageId = S.pagesByGame[S.game][0].id;
    ensureCurrentPage();
    saveLocal();
    renderAll();
    loadMap();
    toast("페이지 삭제");
  });

  // -------- game manager (simple) --------
  $("btnGameMgr").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const nm = await openPopInput({
      title:"게임 추가",
      message:"추가할 게임 이름을 입력하세요.\n(예: 아이온2, POE, ...)",
      placeholder:"게임 이름",
      value:"",
      okText:"추가",
      cancelText:"취소"
    });
    if(nm === null) return;
    const g = (nm||"").trim();
    if(!g) return;
    if(S.games.includes(g)){ toast("이미 존재"); return; }
    S.games.push(g);
    if(!S.pagesByGame[g]) S.pagesByGame[g] = [{ id:"p_"+uid(), name:"1번마을", mapUrl:"" }];
    saveLocal();
    renderGamesTop();
    toast("게임 추가");
  });

  // -------- categories --------
  function getCat(id){
    return (S.categories||[]).find(c=>c.id===id) || null;
  }
  function ensureCat(id, color){
    if(!id) return;
    if(!S.categories.some(c=>c.id===id)){
      S.categories.push({ id, name:id, color: color||"#ffffff", on:true });
    }
  }

  function setChipToggle(el, on){
    el.classList.toggle("on", !!on);
    el.querySelector(".dot").style.opacity = on ? "1" : ".35";
  }

  function renderCats(){
    const wrap = $("catChips");
    wrap.innerHTML = "";
    for(const c of S.categories){
      const d = document.createElement("div");
      d.className = "chip " + (c.on ? "on":"");
      d.innerHTML = `<span class="dot" style="background:${c.color||'#7cc4ff'}"></span>${c.name}`;
      d.addEventListener("click", async ()=>{
        if(!(await requireAuth())) return;
        c.on = !c.on;
        renderCats();
        renderKpi();
        saveLocal();
        draw();
      });
      wrap.appendChild(d);
    }
  }

  // category modal
  let catSelectedRowId = null;
  const QUICK = [
    {name:"빨", c:"#ff3b30"},
    {name:"주", c:"#ff9500"},
    {name:"노", c:"#ffd60a"},
    {name:"초", c:"#34c759"},
    {name:"파", c:"#0a84ff"},
    {name:"흰", c:"#ffffff"},
    {name:"검", c:"#0b0b0f"},
  ];

  $("btnEditCats").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    openCatsModal();
  });
  $("btnCloseCats").addEventListener("click", ()=>$("mCats").classList.remove("show"));

  const tgShowLinesWithCatFilter = $("tgShowLinesWithCatFilter");
  tgShowLinesWithCatFilter.addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    S.showLinesWithCatFilter = !S.showLinesWithCatFilter;
    setChipToggle(tgShowLinesWithCatFilter, !!S.showLinesWithCatFilter);
    saveLocal();
    draw();
  });

  function openCatsModal(){
    catSelectedRowId = null;
    setChipToggle(tgShowLinesWithCatFilter, !!S.showLinesWithCatFilter);
    renderCatRows();
    renderCatQuickPalette();
    $("mCats").classList.add("show");
  }

  function renderCatQuickPalette(){
    const wrap = $("catQuickPalette");
    wrap.innerHTML = "";
    for(const q of QUICK){
      const w = document.createElement("div");
      w.className = "swWrap";
      w.innerHTML = `<div class="sw" style="--c:${q.c}"></div><div class="swLabel">${q.name}</div>`;
      w.querySelector(".sw").addEventListener("click", ()=>{
        if(!catSelectedRowId){ toast("카테고리 행을 먼저 선택"); return; }
        const c = S.categories.find(x=>x.id===catSelectedRowId);
        if(!c) return;
        c.color = q.c;
        renderCatRows();
      });
      wrap.appendChild(w);
    }
  }

  function renderCatRows(){
    const rows = $("catRows");
    rows.innerHTML = "";

    const list = S.categories.filter(c=>c.id!=="전체");
    for(const c of list){
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridTemplateColumns = "1fr 70px 90px";
      row.style.gap = "10px";
      row.style.alignItems = "center";
      row.style.marginBottom = "10px";

      row.innerHTML = `
        <input class="field" value="${escapeHtml(c.name)}" />
        <div class="colorChip" style="--c:${c.color}; cursor:pointer;"></div>
        <button class="pill danger" type="button">삭제</button>
      `;

      const inp = row.querySelector("input");
      const chip = row.querySelector(".colorChip");
      const del = row.querySelector("button");

      row.addEventListener("click", ()=>{
        catSelectedRowId = c.id;
        toast("카테고리 선택");
      });

      inp.addEventListener("input", ()=>{
        c.name = inp.value;
        c.id = inp.value; // id == name 정책
      });

      chip.addEventListener("click", async (e)=>{
        e.stopPropagation();
        catSelectedRowId = c.id;
        const next = await openPopInput({
          title:"카테고리 색상",
          message:"색상 코드를 입력하세요. (예: #ff0000)",
          placeholder:"#rrggbb",
          value:c.color || "",
          okText:"저장",
          cancelText:"취소"
        });
        if(next === null) return;
        const v = (next||"").trim();
        if(v) c.color = v;
        renderCatRows();
        renderCats();
        applyAllChainStylesOnPage(S.currentPageId);
        saveLocal();
        draw();
      });

      del.addEventListener("click", (e)=>{
        e.stopPropagation();
        // 즉시 삭제
        const fallback = S.categories.find(x=>x.id==="기텔") || S.categories[0];
        for(const m of S.markers){
          if(m.cat === c.id) m.cat = fallback.id;
        }
        S.categories = S.categories.filter(x=>x.id!==c.id);
        applyAllCatStylesOnPage(S.currentPageId);
        applyAllChainStylesOnPage(S.currentPageId);
        renderCatRows();
        renderCats();
        saveLocal();
        draw();
      });

      rows.appendChild(row);
    }
  }

  $("btnAddCat").addEventListener("click", async ()=>{
    const name = await openPopInput({
      title:"카테고리 추가",
      message:"추가할 카테고리 이름을 입력하세요.",
      placeholder:"예: 11",
      value:"",
      okText:"추가",
      cancelText:"취소"
    });
    if(name === null) return;
    const id = (name||"").trim();
    if(!id) return;
    if(S.categories.some(c=>c.id===id)){ toast("이미 존재"); return; }
    S.categories.push({ id, name:id, color:"#ffffff", on:true });
    renderCatRows();
  });

  $("btnCatsDefault").addEventListener("click", async ()=>{
    const ok = await openPopConfirm({
      title:"기본값으로",
      message:"기본 카테고리로 되돌릴까요?",
      okText:"되돌리기",
      cancelText:"취소"
    });
    if(!ok) return;
    S.categories = structuredClone(defaultCats);
    renderCatRows();
  });

  $("btnSaveCats").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;

    const cleaned = [];
    const seen = new Set(["전체"]);
    for(const c of S.categories){
      const name = (c.name||c.id||"").trim();
      if(!name) continue;
      const finalId = name;
      if(seen.has(finalId)) continue;
      seen.add(finalId);
      cleaned.push({ id:finalId, name, color:(c.color||"#ffffff"), on:!!c.on });
    }
    const all = { id:"전체", name:"전체", color:"#7cc4ff", on:true };
    S.categories = [all, ...cleaned];

    const valid = new Set(S.categories.map(x=>x.id));
    const fb = valid.has("기텔") ? "기텔" : (S.categories[1]?.id || "전체");
    for(const m of S.markers){
      if(!valid.has(m.cat)) m.cat = fb;
    }

    applyAllCatStylesOnPage(S.currentPageId);
    applyAllChainStylesOnPage(S.currentPageId);

    saveLocal();
    renderCats();
    renderKpi();
    draw();
    $("mCats").classList.remove("show");
    toast("카테고리 저장");
  });

  // -------- map load --------
  const cv = $("cv");
  const ctx = cv.getContext("2d");
  let mapImg = null;

  async function loadMap(){
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    const url = cur?.mapUrl || S.map.pageMapUrl || "";
    S.map.pageMapUrl = url || "";

    if(S.map.imgDataUrl){
      mapImg = new Image();
      mapImg.onload = ()=>{
        S.map.naturalW = mapImg.naturalWidth;
        S.map.naturalH = mapImg.naturalHeight;
        if(!S.map.scale || S.map.scale<=0) fitToScreen();
        draw();
      };
      mapImg.src = S.map.imgDataUrl;
      return;
    }

    if(url){
      mapImg = new Image();
      mapImg.crossOrigin = "anonymous";
      mapImg.onload = ()=>{
        S.map.naturalW = mapImg.naturalWidth;
        S.map.naturalH = mapImg.naturalHeight;
        if(!S.map.scale || S.map.scale<=0) fitToScreen();
        draw();
      };
      mapImg.onerror = ()=>fallbackSvg();
      mapImg.src = url;
      return;
    }

    fallbackSvg();
  }

  function fallbackSvg(){
    mapImg = new Image();
    mapImg.onload = ()=>draw();
    mapImg.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="1400" height="1000">
        <defs>
          <radialGradient id="g" cx="50%" cy="40%" r="70%">
            <stop offset="0%" stop-color="#ffffff"/>
            <stop offset="100%" stop-color="#e8edf7"/>
          </radialGradient>
        </defs>
        <rect width="100%" height="100%" fill="url(#g)"/>
        <text x="50%" y="50%" text-anchor="middle" font-family="Arial" font-size="28" fill="#7a889e">페이지 URL 또는 지도 업로드가 필요</text>
      </svg>`
    );
  }

  $("btnLoadFromUrl").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    if(!cur) return;
    cur.mapUrl = ($("mapUrl").value || "").trim();
    S.map.imgDataUrl = ""; // URL 우선
    S.map.scale = 0; // 새 지도면 fit
    saveLocal();
    loadMap();
    toast("페이지 URL 적용");
  });

  $("fileMap").addEventListener("change", async (e)=>{
    if(!(await requireAuth())) return;
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const dataUrl = await readFileAsDataURL(f);
    S.map.imgDataUrl = dataUrl;
    S.map.pageMapUrl = "";
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    if(cur) cur.mapUrl = "";
    S.map.scale = 0;
    saveLocal();
    loadMap();
    toast("지도 업로드 저장");
    e.target.value = "";
  });

  $("btnClearMap").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    S.map.imgDataUrl = "";
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    if(cur) cur.mapUrl = "";
    S.map.pageMapUrl = "";
    $("mapUrl").value = "";
    S.map.scale = 0;
    saveLocal();
    loadMap();
    toast("지도 제거");
  });

  $("btnFit").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    fitToScreen();
    saveLocal();
    draw();
    toast("화면 맞춤");
  });

  // -------- export / reset --------
  $("btnExport").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const blob = new Blob([JSON.stringify(S, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "state.json";
    a.click();
    URL.revokeObjectURL(a.href);
    toast("state.json 다운로드");
  });

  $("btnResetAll").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const ok = await openPopConfirm({
      title:"전체 초기화",
      message:"전체 초기화할까요?\n(게임/페이지/마커/지도 포함)",
      okText:"초기화",
      cancelText:"취소"
    });
    if(!ok) return;
    S = structuredClone(defaultState);
    saveLocal();
    renderAll();
    loadMap();
    toast("전체 초기화 완료");
  });

  $("btnResetMarkers").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    const ok = await openPopConfirm({
      title:"마커 초기화",
      message:"현재 페이지의 마커를 모두 삭제할까요?",
      okText:"삭제",
      cancelText:"취소"
    });
    if(!ok) return;

    const pid = S.currentPageId;
    S.markers = S.markers.filter(m=>m.pageId!==pid);
    selectedMarker = null;
    insertAfterMarkerId = null;
    saveLocal();
    syncSelectedPanel();
    renderKpi();
    draw();
    toast("마커 초기화");
  });

  // -------- canvas sizing --------
  function resizeCanvas(){
    const wrap = cv.parentElement;
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    // real pixels
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width = Math.max(900, Math.floor(w * dpr));
    cv.height = Math.max(650, Math.floor(h * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  window.addEventListener("resize", ()=>{ resizeCanvas(); draw(); });

  function fitToScreen(){
    const pad = 40;
    const iw = S.map.naturalW || (mapImg?.naturalWidth||1);
    const ih = S.map.naturalH || (mapImg?.naturalHeight||1);
    const rect = cv.getBoundingClientRect();
    const cw = rect.width, ch = rect.height;
    const scale = Math.min((cw - pad)/iw, (ch - pad)/ih);
    S.map.scale = clamp(scale, 0.05, 10);
    S.map.tx = (cw - iw*S.map.scale)/2;
    S.map.ty = (ch - ih*S.map.scale)/2;
  }

  // -------- markers / chains --------
  let currentChainByPage = {};
  function renumberPage(pageId){
    const ms = (S.markers||[]).filter(m=>m.pageId===pageId);
    ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
    for(let i=0;i<ms.length;i++) ms[i].order = i+1;
  }
  function ensureMarkerChain(m){
    if(!m.chainId) m.chainId = "c0";
    return m.chainId;
  }
  function getPageMarkersSorted(pageId){
    return (S.markers||[]).filter(m=>m.pageId===pageId).slice()
      .sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
  }
  function getChainMarkersOnPage(pageId, chainId){
    return getPageMarkersSorted(pageId).filter(m=>ensureMarkerChain(m)===chainId);
  }
  function recomputeChainIndices(pageId){
    const ms = getPageMarkersSorted(pageId);
    const byChain = new Map();
    for(const m of ms){
      const cid = ensureMarkerChain(m);
      if(!byChain.has(cid)) byChain.set(cid, []);
      byChain.get(cid).push(m);
    }
    for(const [cid, arr] of byChain){
      for(let i=0;i<arr.length;i++) arr[i].chainIndex = i+1;
    }
  }
  function getActiveChainIdForPage(pageId){
    const v = currentChainByPage[pageId];
    if(v) return v;
    const ms = getPageMarkersSorted(pageId);
    const last = ms[ms.length-1];
    const cid = last ? ensureMarkerChain(last) : "c0";
    currentChainByPage[pageId] = cid;
    return cid;
  }
  function setActiveChainIdForPage(pageId, cid){
    currentChainByPage[pageId] = cid;
  }

  function leaderOfCat(pageId, catId){
    const ms = (S.markers||[]).filter(m=>m.pageId===pageId && m.cat===catId);
    if(!ms.length) return null;
    ms.sort((a,b)=>(a.order||0)-(b.order||0));
    return ms[0];
  }
  function applyCatLeaderStyle(pageId, catId){
    const leader = leaderOfCat(pageId, catId);
    if(!leader) return;
    const ms = (S.markers||[]).filter(m=>m.pageId===pageId && m.cat===catId);
    for(const m of ms){
      if(m.id===leader.id) continue;
      m.r = leader.r;
      m.fs = leader.fs;
      m.fw = leader.fw;
      m.labelColor = leader.labelColor;
      m.useCatColor = leader.useCatColor;
      m.colorOverride = leader.colorOverride || "";
    }
  }
  function applyAllCatStylesOnPage(pageId){
    const cats = new Set((S.markers||[]).filter(m=>m.pageId===pageId).map(m=>m.cat));
    for(const catId of cats) applyCatLeaderStyle(pageId, catId);
  }

  function markerColor(m){
    if(m.useCatColor){
      const c = getCat(m.cat);
      return (c && c.color) ? c.color : "#7cc4ff";
    }
    return m.colorOverride || "#7cc4ff";
  }

  function leaderOfChain(pageId, chainId){
    const ms = getChainMarkersOnPage(pageId, chainId).slice();
    if(!ms.length) return null;
    ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
    return ms[0];
  }
  function applyChainLeaderStyle(pageId, chainId){
    const ms = getChainMarkersOnPage(pageId, chainId).slice();
    if(ms.length < 2) return;
    ms.sort((a,b)=>(a.order||0)-(b.order||0) || (a.id>b.id?1:-1));
    const leader = ms[0];
    const leaderCol = markerColor(leader);
    for(let i=1;i<ms.length;i++){
      const m = ms[i];
      m.r = leader.r;
      m.fs = leader.fs;
      m.fw = leader.fw;
      m.labelColor = leader.labelColor;
      m.useCatColor = false;
      m.colorOverride = leaderCol;
    }
  }
  function applyAllChainStylesOnPage(pageId){
    const ms = getPageMarkersSorted(pageId);
    const chainIds = new Set();
    for(const m of ms) chainIds.add(ensureMarkerChain(m));
    for(const cid of chainIds) applyChainLeaderStyle(pageId, cid);
  }

  function splitBaseAndNumber(name){
    const s = (name||"").trim();
    const mFront = s.match(/^(\s*)(\d+)(\s*)번(.*)$/);
    if(mFront){
      const num = parseInt(mFront[2], 10);
      if(Number.isFinite(num)) return { kind:"front_bun", pre:mFront[1]||"", num, mid:mFront[3]||"", rest:mFront[4]||"" };
    }
    const mTail = s.match(/^(.*?)(\d+)(\s*)$/);
    if(mTail){
      const num = parseInt(mTail[2], 10);
      if(Number.isFinite(num)) return { kind:"tail", base:(mTail[1]||""), num, tailSpace:(mTail[3]||"") };
    }
    return { kind:"none", raw:s };
  }
  function makeAutoNameFromLeader(leaderName, idx){
    const info = splitBaseAndNumber(leaderName);
    const delta = Math.max(0, (idx||1) - 1);
    if(info.kind === "front_bun"){
      const nextNum = info.num + delta;
      return `${info.pre}${nextNum}${info.mid}번${info.rest}`;
    }
    if(info.kind === "tail"){
      const nextNum = info.num + delta;
      return `${info.base}${nextNum}${info.tailSpace}`;
    }
    return `${(leaderName||"").trim()}${idx}`;
  }
  function applyAutoNamesForChainOnPage(pageId, chainId){
    const ms = getChainMarkersOnPage(pageId, chainId);
    if(!ms.length) return;
    const leader = ms[0];
    const leaderName = (leader.name||"").trim();
    if(!leaderName) return;
    for(let i=1;i<ms.length;i++){
      const m = ms[i];
      if((m.name||"").trim()) continue;
      const idx = (m.chainIndex || (i+1));
      m.name = makeAutoNameFromLeader(leaderName, idx);
    }
  }

  function getVisibleMarkers(){
    const curPage = S.currentPageId;
    const allCat = getCat("전체");
    if(allCat && allCat.on === false) return [];

    const onCats = new Set(S.categories.filter(c=>c.on).map(c=>c.id));
    const allOn = onCats.has("전체");
    return (S.markers||[]).filter(m=>{
      if(m.pageId !== curPage) return false;
      if(allOn){
        const c = getCat(m.cat);
        if(c && c.on === false) return false;
        return true;
      }
      return onCats.has(m.cat);
    }).sort((a,b)=>(a.order||0)-(b.order||0));
  }

  function renderKpi(){
    const curPage = S.currentPageId;
    const total = (S.markers||[]).filter(m=>m.pageId===curPage).length;
    const shown = getVisibleMarkers().length;
    $("kpi").textContent = `표시 중 마커: ${shown} / 페이지 전체: ${total}`;
  }

  // -------- drawing --------
  function worldFromNorm(nx, ny){
    const iw = S.map.naturalW || (mapImg?.naturalWidth||1);
    const ih = S.map.naturalH || (mapImg?.naturalHeight||1);
    return { x:nx*iw, y:ny*ih };
  }
  function screenFromWorld(wx, wy){
    return { sx: wx*S.map.scale + S.map.tx, sy: wy*S.map.scale + S.map.ty };
  }

  let circleHitboxes = [];
  function drawArrowheadWorld(x1,y1,x2,y2, sizeWorld){
    const dx = x2-x1, dy = y2-y1;
    const len = Math.hypot(dx,dy);
    if(len < 1e-6) return;
    const ux = dx/len, uy = dy/len;
    const px = -uy, py = ux;

    const tipX = x2, tipY = y2;
    const backX = x2 - ux*sizeWorld;
    const backY = y2 - uy*sizeWorld;
    const wing = sizeWorld*0.55;

    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(backX + px*wing, backY + py*wing);
    ctx.lineTo(backX - px*wing, backY - py*wing);
    ctx.closePath();
    ctx.fill();
  }

  function draw(){
    const rect = cv.getBoundingClientRect();
    const cw = rect.width, ch = rect.height;

    ctx.clearRect(0,0,cw,ch);
    circleHitboxes = [];

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.22)";
    ctx.fillRect(0,0,cw,ch);
    ctx.restore();

    ctx.save();
    ctx.translate(S.map.tx, S.map.ty);
    ctx.scale(S.map.scale, S.map.scale);

    if(mapImg && mapImg.complete){
      const iw = S.map.naturalW || (mapImg.naturalWidth||1);
      const ih = S.map.naturalH || (mapImg.naturalHeight||1);
      ctx.drawImage(mapImg, 0,0, iw, ih);
    }

    const visible = getVisibleMarkers();
    recomputeChainIndices(S.currentPageId);

    if(S.showLinesWithCatFilter){
      const byChain = new Map();
      for(const m of visible){
        const cid = ensureMarkerChain(m);
        if(!byChain.has(cid)) byChain.set(cid, []);
        byChain.get(cid).push(m);
      }

      for(const [cid, ms] of byChain){
        ms.sort((a,b)=>(a.order||0)-(b.order||0));
        if(ms.length < 2) continue;

        const baseR = ms.reduce((acc,m)=>acc + (m.r ?? 10), 0) / Math.max(1, ms.length);
        const lineW = clamp(baseR * 0.18, 0.9, 2.4);
        const arrowSize = clamp(baseR * 0.95, 4.5, 18);

        ctx.save();
        ctx.globalAlpha = 0.92;

        ctx.lineWidth = lineW;
        ctx.strokeStyle = "rgba(255,255,255,.78)";
        ctx.fillStyle = "rgba(255,255,255,.78)";
        ctx.beginPath();
        for(let i=0;i<ms.length;i++){
          const p = worldFromNorm(ms[i].x, ms[i].y);
          if(i===0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        for(let i=0;i<ms.length-1;i++){
          const a = worldFromNorm(ms[i].x, ms[i].y);
          const b = worldFromNorm(ms[i+1].x, ms[i+1].y);
          const ar = (ms[i].r ?? 10);
          const br = (ms[i+1].r ?? 10);

          const dx = b.x-a.x, dy = b.y-a.y;
          const len = Math.hypot(dx,dy);
          if(len < 1e-6) continue;
          const ux = dx/len, uy = dy/len;

          const halfStroke = (lineW * 0.5);
          const endX = b.x - ux*(br + halfStroke);
          const endY = b.y - uy*(br + halfStroke);
          const startX = a.x + ux*(ar + halfStroke);
          const startY = a.y + uy*(ar + halfStroke);

          if(Math.hypot(endX-startX, endY-startY) < 10) continue;
          drawArrowheadWorld(startX, startY, endX, endY, arrowSize);
        }
        ctx.restore();
      }
    }

    for(const m of visible){
      const p = worldFromNorm(m.x, m.y);
      const r = (m.r ?? 10);
      const col = markerColor(m);

      ctx.save();
      ctx.globalAlpha = m.dim ? 0.30 : 1;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fillStyle = col;
      ctx.fill();
      ctx.lineWidth = 2 / S.map.scale;
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.stroke();
      ctx.restore();

      const num = (typeof m.chainIndex === "number" && m.chainIndex > 0) ? String(m.chainIndex) : "";
      if(num){
        const digits = num.length;
        const ratio = (digits===1) ? 1.20 : (digits===2 ? 1.00 : 0.86);
        const numFs = Math.max(1, Math.round(r * ratio));

        ctx.save();
        ctx.globalAlpha = 0.98;
        ctx.fillStyle = "rgba(0,0,0,.75)";
        ctx.font = `${m.fw ?? 900} ${numFs}px ui-sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(num, p.x, p.y);
        ctx.restore();
      }

      if(m.name){
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.fillStyle = m.labelColor || "#e7eef8";
        ctx.font = `${m.fw ?? 900} ${m.fs ?? 15}px ui-sans-serif`;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        const off = r + 8;
        ctx.fillText(m.name, p.x + off, p.y);
        ctx.restore();
      }

      const sp = screenFromWorld(p.x, p.y);
      circleHitboxes.push({ id:m.id, sx:sp.sx, sy:sp.sy, rPx: r*S.map.scale });
    }

    ctx.restore();
  }

  function pickCircleAt(sx, sy){
    let best=null, bestD=Infinity;
    for(const c of circleHitboxes){
      const d = Math.hypot(c.sx - sx, c.sy - sy);
      if(d <= c.rPx*1.25 && d < bestD){
        best = c;
        bestD = d;
      }
    }
    return best;
  }

  // -------- pan/zoom + marker drag --------
  let isPanning=false, lastX=0,lastY=0;
  let draggingMarkerId = null;
  let dragStartSX=0, dragStartSY=0;
  let dragMoved = false;
  let dragPointerId = null;

  function screenToWorld(sx, sy){
    const wx = (sx - S.map.tx) / S.map.scale;
    const wy = (sy - S.map.ty) / S.map.scale;
    return { wx, wy };
  }
  function worldToNorm(wx, wy){
    const iw = S.map.naturalW || (mapImg?.naturalWidth||1);
    const ih = S.map.naturalH || (mapImg?.naturalHeight||1);
    return { nx: clamp(wx / iw, 0, 1), ny: clamp(wy / ih, 0, 1) };
  }

  cv.addEventListener("pointerdown", async (e)=>{
    if(!(await requireAuth())) return;
    cv.setPointerCapture(e.pointerId);
    dragPointerId = e.pointerId;

    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    lastX=e.clientX; lastY=e.clientY;
    dragMoved = false;

    const hit = pickCircleAt(sx, sy);
    if(hit){
      draggingMarkerId = hit.id;
      dragStartSX = sx;
      dragStartSY = sy;
      isPanning = false;
      return;
    }
    draggingMarkerId = null;
    isPanning = true;
  });

  cv.addEventListener("pointermove", (e)=>{
    if(dragPointerId !== e.pointerId) return;

    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    if(draggingMarkerId){
      const dist = Math.hypot(sx - dragStartSX, sy - dragStartSY);
      if(dist > 3) dragMoved = true;

      const m = S.markers.find(x=>x.id===draggingMarkerId);
      if(!m) return;

      const { wx, wy } = screenToWorld(sx, sy);
      const { nx, ny } = worldToNorm(wx, wy);
      m.x = nx; m.y = ny;

      draw();
      return;
    }

    if(!isPanning) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    if(Math.hypot(dx,dy) > 2) dragMoved = true;
    lastX=e.clientX; lastY=e.clientY;
    S.map.tx += dx;
    S.map.ty += dy;
    draw();
  });

  cv.addEventListener("pointerup", ()=>{
    if(draggingMarkerId){
      const m = S.markers.find(x=>x.id===draggingMarkerId);
      if(m){
        if(!dragMoved){
          m.dim = !m.dim;
          selectedMarker = m;
          syncSelectedPanel();
          toast(m.dim ? "불투명화" : "불투명 해제");
        }else{
          toast("마커 이동 완료");
        }
        saveLocal();
      }
      draggingMarkerId = null;
      dragPointerId = null;
      dragMoved = false;
      draw();
      return;
    }
    isPanning=false;
    dragPointerId = null;
  });

  cv.addEventListener("pointercancel", ()=>{
    draggingMarkerId = null;
    isPanning=false;
    dragPointerId = null;
  });

  cv.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const rect = cv.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const old = S.map.scale || 1;
    const zoom = Math.exp(-e.deltaY * 0.0012);
    const next = clamp(old * zoom, 0.05, 10);

    const wx = (mx - S.map.tx) / old;
    const wy = (my - S.map.ty) / old;

    S.map.scale = next;
    S.map.tx = mx - wx * next;
    S.map.ty = my - wy * next;

    draw();
  }, {passive:false});

  // -------- marker create / select --------
  let selectedMarker = null;
  let insertAfterMarkerId = null;

  function nextOrderForPage(pageId){
    const ms = (S.markers||[]).filter(m=>m.pageId===pageId);
    const max = ms.reduce((acc,m)=>Math.max(acc, (m.order||0)), 0);
    return max + 1;
  }

  function newMarkerAt(normX, normY){
    const pageId = S.currentPageId;

    const m = {
      id:"m_"+uid(),
      pageId:pageId,
      x:normX, y:normY,
      name:"",
      cat: (S.categories.find(c=>c.on && c.id!=="전체")?.id) || "기텔",
      colorOverride:"",
      useCatColor:true,
      yt:"",
      ytTitle:"",
      memo:"",
      r:10,
      fs:15,
      fw:900,
      labelColor:"#e7eef8",
      order: nextOrderForPage(pageId),
      dim:false,
      chainId:null,
      chainIndex:null,
    };

    if(insertAfterMarkerId){
      const base = S.markers.find(x=>x.id===insertAfterMarkerId);
      if(base && base.pageId===m.pageId){
        m.chainId = ensureMarkerChain(base);
        const insertAt = (base.order||0) + 1;
        for(const mm of S.markers){
          if(mm.pageId===m.pageId && (mm.order||0) >= insertAt){
            mm.order = (mm.order||0) + 1;
          }
        }
        m.order = insertAt;
        renumberPage(m.pageId);
      }
    }else{
      m.chainId = getActiveChainIdForPage(pageId);
    }
    ensureMarkerChain(m);

    S.markers.push(m);

    const leader = leaderOfCat(m.pageId, m.cat);
    if(leader && leader.id !== m.id){
      m.r = leader.r; m.fs = leader.fs; m.fw = leader.fw; m.labelColor = leader.labelColor;
      m.useCatColor = leader.useCatColor; m.colorOverride = leader.colorOverride || "";
    }

    renumberPage(pageId);
    recomputeChainIndices(pageId);

    applyAutoNamesForChainOnPage(pageId, ensureMarkerChain(m));
    applyAllCatStylesOnPage(pageId);
    applyAllChainStylesOnPage(pageId);

    saveLocal();
    selectMarker(m.id);
    renderKpi();
    draw();
  }

  function selectMarker(id){
    selectedMarker = S.markers.find(m=>m.id===id) || null;
    syncSelectedPanel();
  }

  function syncSelectedPanel(){
    $("selName").textContent = selectedMarker ? (selectedMarker.name || "(이름 없음)") : "(이름 없음)";
    $("selLink").value = selectedMarker ? (selectedMarker.yt || "") : "";
    $("selYtTitle").value = selectedMarker ? (selectedMarker.ytTitle || "") : "";
    $("btnOpenMarkerEdit").disabled = !selectedMarker;
    $("btnApplyQuick").disabled = !selectedMarker;
    $("btnUseCatColor").disabled = !selectedMarker;
  }

  cv.addEventListener("click", async (e)=>{
    if(!(await requireAuth())) return;
    if(dragMoved) return;

    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const hit = pickCircleAt(sx, sy);
    if(hit){
      selectMarker(hit.id);
      return;
    }
    selectedMarker = null;
    insertAfterMarkerId = null;
    syncSelectedPanel();
  });

  cv.addEventListener("contextmenu", async (e)=>{
    e.preventDefault();
    if(!(await requireAuth())) return;

    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    const { wx, wy } = screenToWorld(sx, sy);

    const iw = S.map.naturalW || (mapImg?.naturalWidth||1);
    const ih = S.map.naturalH || (mapImg?.naturalHeight||1);

    const nx = clamp(wx / iw, 0, 1);
    const ny = clamp(wy / ih, 0, 1);

    newMarkerAt(nx, ny);
    toast("마커 추가");
  });

  $("selLink").addEventListener("input", ()=>{
    if(!selectedMarker) return;
    selectedMarker.yt = $("selLink").value.trim();
    saveLocal();
  });
  $("selYtTitle").addEventListener("input", ()=>{
    if(!selectedMarker) return;
    selectedMarker.ytTitle = $("selYtTitle").value;
    saveLocal();
  });

  $("btnOpenMarkerEdit").addEventListener("click", ()=>{
    if(!selectedMarker) return;
    openMarkerModal(selectedMarker.id);
  });

  // quick palette
  let pickedQuick = null;
  function renderPalette(){
    const palette = $("palette");
    palette.innerHTML = "";
    for(const q of QUICK){
      const wrap = document.createElement("div");
      wrap.className = "swWrap";
      wrap.innerHTML = `
        <div class="sw" style="--c:${q.c}" title="${q.name}"></div>
        <div class="swLabel">${q.name}</div>
      `;
      wrap.querySelector(".sw").addEventListener("click", ()=>{
        pickedQuick = q.c;
        toast("색상 선택");
      });
      palette.appendChild(wrap);
    }
  }

  $("btnApplyQuick").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    if(!selectedMarker){ toast("마커를 선택"); return; }
    if(!pickedQuick){ toast("빠른 색상 선택"); return; }

    const cid = ensureMarkerChain(selectedMarker);
    const leader = leaderOfChain(S.currentPageId, cid);
    const target = leader || selectedMarker;
    target.colorOverride = pickedQuick;
    target.useCatColor = false;

    applyAllCatStylesOnPage(S.currentPageId);
    applyAllChainStylesOnPage(S.currentPageId);

    saveLocal();
    draw();
    toast("색상 적용");
  });

  $("btnUseCatColor").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    if(!selectedMarker){ toast("마커를 선택"); return; }

    const cid = ensureMarkerChain(selectedMarker);
    const leader = leaderOfChain(S.currentPageId, cid);
    const target = leader || selectedMarker;
    target.colorOverride = "";
    target.useCatColor = true;

    applyAllCatStylesOnPage(S.currentPageId);
    applyAllChainStylesOnPage(S.currentPageId);

    saveLocal();
    draw();
    toast("카테고리 색상");
  });

  // chain lines toggles
  const tg = $("tgShowChainSameCat");
  tg.addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    S.showLinesWithCatFilter = !S.showLinesWithCatFilter;
    setChipToggle(tg, !!S.showLinesWithCatFilter);
    saveLocal();
    draw();
  });

  $("btnClearLines").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    S.showLinesWithCatFilter = false;
    setChipToggle(tg, false);
    saveLocal();
    draw();
    toast("선 숨김");
  });

  $("btnRechain").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    renumberPage(S.currentPageId);
    recomputeChainIndices(S.currentPageId);
    S.showLinesWithCatFilter = true;
    setChipToggle(tg, true);
    applyAllCatStylesOnPage(S.currentPageId);
    applyAllChainStylesOnPage(S.currentPageId);
    saveLocal();
    draw();
    toast("선 표시");
  });

  // -------- marker modal --------
  let editingId = null;
  function openMarkerModal(markerId){
    const m = S.markers.find(x=>x.id===markerId);
    if(!m) return;

    editingId = markerId;

    const sel = $("mfCat");
    sel.innerHTML = "";
    for(const c of S.categories){
      if(c.id==="전체") continue;
      const o = document.createElement("option");
      o.value = c.id;
      o.textContent = c.name;
      sel.appendChild(o);
    }

    $("mfName").value = m.name || "";
    $("mfCat").value = m.cat || "기텔";

    $("mfColor").value = m.colorOverride || "";
    $("mfUseCatColor").checked = !!m.useCatColor;

    $("mfYt").value = m.yt || "";
    $("mfYtTitle").value = m.ytTitle || "";
    $("mfMemo").value = m.memo || "";

    $("mfR").value = m.r ?? 10;
    $("mfFs").value = m.fs ?? 15;
    $("mfFw").value = String(m.fw ?? 900);
    $("mfLabelColor").value = m.labelColor || "#e7eef8";

    $("mfRVal").textContent = $("mfR").value;
    $("mfFsVal").textContent = $("mfFs").value;

    $("mfPos").textContent = `좌표(비율): ${m.x.toFixed(6)}, ${m.y.toFixed(6)}`;

    updateColorChip();
    $("mMarker").classList.add("show");
    setTimeout(()=>$("mfName").focus(), 0);
  }

  function closeMarkerModal(){
    $("mMarker").classList.remove("show");
    editingId = null;
  }

  $("btnCloseMarker").addEventListener("click", closeMarkerModal);
  $("btnSaveMarker").addEventListener("click", saveMarkerModal);
  $("btnDeleteMarker").addEventListener("click", deleteMarkerModal);

  $("mMarker").addEventListener("keydown", (e)=>{
    if(e.key==="Enter"){
      if(e.target && e.target.tagName==="TEXTAREA") return;
      e.preventDefault();
      saveMarkerModal();
    }
    if(e.key==="Escape"){
      closeMarkerModal();
    }
  });

  function getEditing(){
    if(!editingId) return null;
    return S.markers.find(x=>x.id===editingId) || null;
  }

  function updateColorChip(){
    const m = getEditing();
    if(!m) return;
    const chip = $("mfColorChip");
    const col = $("mfUseCatColor").checked ? (getCat($("mfCat").value)?.color || "#7cc4ff") : ($("mfColor").value || markerColor(m));
    chip.style.setProperty("--c", col);
  }
  $("mfColor").addEventListener("input", updateColorChip);
  $("mfUseCatColor").addEventListener("change", updateColorChip);
  $("mfCat").addEventListener("change", updateColorChip);

  let ytTouched = false, memoTouched = false;
  $("mfYtTitle").addEventListener("input", ()=>{ ytTouched = true; syncSelectedPanelLive(); });
  $("mfMemo").addEventListener("input", ()=>{ memoTouched = true; syncSelectedPanelLive(); });

  $("mfName").addEventListener("input", ()=>{
    const v = $("mfName").value;
    if(!ytTouched) $("mfYtTitle").value = v;
    if(!memoTouched) $("mfMemo").value = v;
    syncSelectedPanelLive();
  });

  function syncSelectedPanelLive(){
    if(!editingId) return;
    if(selectedMarker && selectedMarker.id === editingId){
      $("selName").textContent = $("mfName").value || "(이름 없음)";
      $("selYtTitle").value = $("mfYtTitle").value || "";
      $("selLink").value = $("mfYt").value || "";
    }
  }

  $("mfR").addEventListener("input", ()=>{
    $("mfRVal").textContent = $("mfR").value;
    const r = Number($("mfR").value);
    const fs = clamp(Math.round(r * 1.5), 4, 80);
    $("mfFs").value = fs;
    $("mfFsVal").textContent = fs;
  });
  $("mfFs").addEventListener("input", ()=>{ $("mfFsVal").textContent = $("mfFs").value; });
  $("mfLabelDefault").addEventListener("click", ()=>{ $("mfLabelColor").value = "#e7eef8"; });

  function saveMarkerModal(){
    const m = getEditing();
    if(!m) return;

    const prevCat = m.cat;

    m.name = ($("mfName").value || "").trim();
    m.cat = $("mfCat").value || "기텔";
    ensureCat(m.cat, "#ffffff");

    m.useCatColor = $("mfUseCatColor").checked;
    m.colorOverride = ($("mfColor").value || "").trim();

    m.yt = ($("mfYt").value || "").trim();
    m.ytTitle = ($("mfYtTitle").value || "").trim();
    m.memo = ($("mfMemo").value || "").trim();

    m.r = Number($("mfR").value);
    m.fs = Number($("mfFs").value);
    m.fw = Number($("mfFw").value);
    m.labelColor = ($("mfLabelColor").value || "#e7eef8").trim();

    renumberPage(m.pageId);
    recomputeChainIndices(m.pageId);

    applyCatLeaderStyle(m.pageId, prevCat);
    applyCatLeaderStyle(m.pageId, m.cat);
    applyAllChainStylesOnPage(m.pageId);
    applyAutoNamesForChainOnPage(m.pageId, ensureMarkerChain(m));

    saveLocal();
    selectMarker(m.id);
    renderCats();
    renderKpi();
    draw();
    toast("저장 완료");
    closeMarkerModal();
  }

  function deleteMarkerModal(){
    const m = getEditing();
    if(!m) return;

    const pid = m.pageId;
    const catId = m.cat;

    S.markers = S.markers.filter(x=>x.id!==m.id);
    renumberPage(pid);
    recomputeChainIndices(pid);

    applyCatLeaderStyle(pid, catId);
    applyAllChainStylesOnPage(pid);

    saveLocal();
    closeMarkerModal();
    selectedMarker = null;
    syncSelectedPanel();
    renderKpi();
    draw();
    toast("삭제 완료");
  }

  $("btnNewChain").addEventListener("click", async ()=>{
    if(!(await requireAuth())) return;
    if(!selectedMarker){ toast("마커 선택"); return; }
    const m = selectedMarker;

    const pid = m.pageId;
    const newCid = "c_" + uid();
    m.chainId = newCid;
    ensureMarkerChain(m);
    setActiveChainIdForPage(pid, newCid);

    renumberPage(pid);
    recomputeChainIndices(pid);

    applyCatLeaderStyle(pid, m.cat);
    applyAllChainStylesOnPage(pid);

    insertAfterMarkerId = null;
    saveLocal();
    draw();
    toast("새로운 번호로 시작");
  });

  $("btnInsertAfter").addEventListener("click", ()=>{
    const m = getEditing();
    if(!m) return;
    insertAfterMarkerId = m.id;
    toast("중간 삽입 모드");
  });

  cv.addEventListener("dblclick", async (e)=>{
    if(!(await requireAuth())) return;
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const hit = pickCircleAt(sx, sy);
    if(hit){
      selectMarker(hit.id);
      ytTouched = false; memoTouched = false;
      openMarkerModal(hit.id);
    }
  });

  // -------- helpers / render all --------
  function renderAll(){
    renderAuth();
    renderLogo();
    renderGamesTop();
    renderPages();
    renderCats();
    renderPalette();
    syncSelectedPanel();
    renderKpi();
    resizeCanvas();

    if(!S.map.scale || S.map.scale<=0) fitToScreen();

    renumberPage(S.currentPageId);
    recomputeChainIndices(S.currentPageId);
    applyAllCatStylesOnPage(S.currentPageId);
    applyAllChainStylesOnPage(S.currentPageId);

    setChipToggle($("tgShowChainSameCat"), !!S.showLinesWithCatFilter);
    draw();
  }

  // -------- init --------
  async function init(){
    renderAuth();
    const st = await loadStateRemoteFirst();
    S = mergeState(st);

    if(typeof S.showLinesWithCatFilter !== "boolean") S.showLinesWithCatFilter = true;

    // sync mapUrl input
    const pages = getPages();
    const cur = pages.find(p=>p.id===S.currentPageId);
    $("mapUrl").value = cur?.mapUrl || "";

    renderAll();
    loadMap();

    if(!S.map.scale || S.map.scale<=0){
      setTimeout(()=>{
        fitToScreen();
        saveLocal();
        draw();
      }, 0);
    }else{
      draw();
    }
  }

  init();

  // -------- utils --------
  function escapeHtml(s){
    return String(s||"")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject)=>{
      const r = new FileReader();
      r.onload = ()=>resolve(r.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

})();
</script>
</body>
</html>
